
#!title:    计算原理
#!date:     2017-09-30

#!content

**版本记录**

- 2016年9月5日：作为λ演算和Y组合子的学习笔记，完成《奇妙的Y组合子》第一版。
- 2017年9月30日：开始起草《我想给你整个世界》。
- 2018年9月18日：完成《奇妙的Y组合子》最终版。
- 2021年3月：将《奇妙的Y组合子》合并到本文。
- 2022年1月：将构造monus的方法（原为独立文章）合并到本文。
- 2022年5月：将《一条永恒的金带》文中部分内容整合到本文。《金带》一文完成于2018年7月，此后没有做过大规模的补充。
- 2022年9月：将《一条永恒的金带》文中剩余的关于数学基础和哥德尔不完全性定理的全部内容迁移到本文第八章“超越无穷”，《金带》一文被完全吸收至本文，不复存在。
- 2023年4月：将Continuation简介、阴阳问题分析、计算理论（递归论）笔记的全部内容迁移到本文第七章“无穷”；将Brainfuck解释器的全部内容迁移到本文第六章“解释”。
- 2023年9月：从《我想给你整个世界》重新命名为更直白的《计算原理》；彻底重构目录结构；将 The Little Schemer 学习笔记、SICP学习笔记迁移到本文，作为附录，后续逐渐合并到正文。

# 参考资料总览

- 侯世达. **哥德尔、艾舍尔、巴赫——集异璧之大成**[M]. 本书翻译组译. 商务印书馆, 2016.
- 郝兆宽, 杨睿之, 杨跃. **数理逻辑：证明及其限度**（第二版）[M]. 复旦大学出版社, 2020.
- 余俊伟, 赵晓玉, 裘江杰, 张立英. **数理逻辑**[M]. 中国人民大学出版社, 2020.
- 郝兆宽, 杨睿之, 杨跃. **递归论：算法与随机性基础**[M]. 复旦大学出版社, 2018.
- 杨睿之. **作为哲学的数理逻辑**[M]. 复旦大学出版社, 2018.
- R Smullyan. **数理逻辑入门**[M]. 刘新文等译. 中国轻工业出版社, 2021.
- E Nagel, J Newman. **哥德尔证明**[M]. 侯世达编, 陈东威等译. 中国人民大学出版社, 2008.
- E Nagel, J Newman. **哥德尔证明**[M]. 侯世达编, 刘新文译. 中国轻工业出版社, 2021.
- 朱水林. **哥德尔不完全性定理**[M]. 辽宁教育出版社, 1987.
- R Smullyan. **哥德尔不完全性定理**[M]. 余俊伟译. 科学出版社, 2019.
- Martin Hirzel. [**On formally undecidable propositions of Principia Mathematica and related systems I (An English translation)**](https://web.archive.org/web/20040916041216/http://www.research.ibm.com/people/h/hirzel/papers/canon00-goedel.pdf). 2000.
- 方弦(fwjmath). [**计算的极限**（系列文章）](https://fwjmath.wordpress.com/recommended-list/)[OL].
- Tom Stuart. **计算的本质**[M]. 张伟译. 人民邮电出版社, 2014.
- Friedman D P, Wand M. [**Essentials of Programming Languages (3rd Edition)**](http://www.eopl3.com/)[M]. The MIT Press, 2008.
- 张立昂. **可计算性与计算复杂性导引**（第3版）[M]. 北京大学出版社, 2011.
- [类型与程序设计语言](https://book.douban.com/subject/1318672/)

# 第一章：代数和集合

<details>
<summary>一篇有趣的小故事。</summary>

> 引用来源：[用数学知识写出的小说是怎样的？ - 戴为的回答](https://www.zhihu.com/question/39422784/answer/129979885)

> 起初，神创造逻辑。逻辑是空虚的。神的零运行在水面上，这是trivial的。神说，要有集合，于是就有了集合。神看集合是好的，就将其公理化。有集合，有运算，就是一个代数结构。

> 神照自己的样子造人。于是神创造了0。神在东方的伊甸建立了一个园子，称之为群。神将0安置在那里，让它作单位元。起初，伊甸园是平凡的。神说，园中所有果子你可以随便吃，只有后继树上果子，你不能吃。因为你吃的时候必死。

> 神说，那人独居不好。于是要为它造一个配偶。神让0沉睡，取它的后继数1。神把1带到伊甸园，让它和0配对，二人从此一起生活。神教给他们加法的运算，让他们可以互相交合。0依然是伊甸园的单位元。0的逆元是0，1的逆元是1，0和1彼此交合则又得到1。

> 神所造的，惟有皮亚诺比一切的活物更狡猾。皮亚诺对1说，神岂是真说不许你们吃园中所有树上的果子么。1对皮亚诺说，园中树上的果子我们可以吃，唯有后继树上的果子不可，免得我们死。皮亚诺说，你们不会死。神是怕你们吃了后继树上的果子能自己创造新的数。皮亚诺告诉1它自己是怎么来的。1对单调的只有0和1的加法已经厌烦。它看后继树上的果子可做食物，而且悦人眼目，是可喜爱的，就摘下果子来吃了。

> 于是1对自己取了后继数，是为2。1又摘下果子给2，2也吃了。于是2对自己取了后继数，是为3。很快，后继树下生成了所有正整数。

> 正整数们很快开始彼此进行加法，互相交合。因为是1最先吃了果子，因此正整数们公认1为生成元，并定义任何数与1做加法等价于取后继数。0从始至终没有参与这件事，因此正整数们认为0对他们没有任何影响。

> 当神发现这件事的时候，伊甸园里已经有无穷多个元素了。神命令希尔伯特将后继树生成的所有数一个个删去。但希尔伯特发现这件事做不到，因为无穷集删去一个元素后仍与原集合同构。神只得放任这些数存在，却发现新生成的那些数没有逆元了。为了保证伊甸园仍为一个群，神只得为这些数添加逆元，将负数加入伊甸园中。被迫引入的负数是不自然的，与自然数相对。神依然令0为单位元，并定义0的逆元为0，它既非正也非负。至此，伊甸园成为一个整数加群。

> 一些数在加法中日益放纵自己，开始滥加、杂加，甚至觉得单次交合无法满足自己，开始进行连加。一种新运算被引入来描述这样的行为，它们称之为乘法。伊甸园成为一个整环。1受其他数的喜爱，它们便推举1为乘法的单位元。乘法最初仅是为了方便引入的。但在寻找乘法的逆运算时，它们偶然发现了一种新体位——一个数趴在另一个数上面，它们称之为over，或称除法。不同的数相除，生产出之前从未见过的畸形后代，这些不详的产物被称为分数。有整数，有分数，这是有理数。有多少整数，就有多少有理数。

> 神认为分数是罪恶的。神说，伊甸园中不能容纳这样的数。神见数的罪很大，终日所思想的都是恶，便打发他们离开伊甸园，将它们降到地上。神对1说，这所有一切罪的根源都在于你。你既做了这事，就必受诅咒。我必多多增加你的苦楚。你将被千人踏，万人踩，所有数都可以将你压在身下。自此，任何数over1都得到那数本身。

> 分数是稠密的。它们很快铺满了大地，任何两个分数之间都必有第三个分数。有理数对乘法构成群。骄傲的0声称自己是神照着祂的样子造的，因此自己不能被over。其他数鄙夷它，因此不接纳0为乘法群的元素。有加法，有乘法，所有有理数构成域。大地上诞生了第一个数域。

</details>



# 第二章：语言和推理

命题逻辑

一阶逻辑语言和形式证明

![自动机层次](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Automata_theory.svg/320px-Automata_theory.svg.png)

- 正则语言/文法（3）-有限状态自动机
- 上下文无关语言/文法（2）-下推自动机
- 上下文有关语言/文法（1）-线性有界图灵机
- 递归可枚举语言/短语结构文法（0）-图灵机

## λ演算

据说，有些人坐电梯时，如果想上楼，会按向下的按钮。因为在他们看来，向下的按钮，可以把楼上的电梯轿厢召唤下来。这是一种指令式的思维：想做一件事，首先考虑的是“How”，也就是手段和方案。而大多数人在处理这类问题时，首先考虑的是“What”，也就是意图和目标：因为想上楼，所以按向上的按钮。图灵机和λ演算两种计算模型，似乎分别代表了这两种思维方式。

1930年，丘奇（Alonzo Church）在研究一阶逻辑的判定性问题时，设计了λ演算。这是一套非常简洁的符号推理系统，只有三种语法形式和三条推理规则。1936年，图灵证明了λ演算与他设计的著名的**图灵机**在计算能力上是等价的。

**λ演算**是一个形式语言，它的基本元素称为“项”（term），分为三种：

- **符号**：任何有效的名字
- **函数**：(**lambda** (%%symbol%%...) %%term%%)
- **调用**：(%%term%%...)

这里采用的语法形式实际上是Scheme的语法，与原始的λ演算并不同，但形式是一致的。本文采用Scheme的语法表示λ演算。在λ演算中，函数不仅可以被调用，还可以当作值传递。

在λ演算中，每个函数都定义了一个“作用域”。在函数的参数列表中出现的符号，可以在函数被调用时被其他项所替换，因而称为作用域中有效的“变量”。函数体中通过使用这些参数，来实现对外部输入的“使用”。由于函数体内还可以嵌套其他函数，因此在内层函数中定义的变量，会“覆盖”外层函数定义的同名变量。例如，表达式`(lambda (x) (lambda (x) x))`中，出现在函数体的`x`，实际上是内层的那个`x`，而不是外层的那个。根据变量定义所在的函数层级，变量分为两种：

- **自由变量**指在函数体中出现，但是没有在本级函数参数列表中出现的符号。
- **约束变量**指的是在函数体中出现，且在本级函数参数列表中出现的符号。

例如，对于表达式`(lambda (x) (lambda (y) (+ x y)))`的内层函数`(lambda (y) (+ x y))`而言，`x`就是它的**自由变量**；而对于整个外层函数来说，它又是**约束变量**。

λ演算的推理规则有三条：

**α-变换**：在不覆盖到同一作用域内部的自由变量的前提下，约束变量的名字可以任意替换。α-变换揭示了一个普遍的现象——形式参数的名称是不重要的。在某些语言中（例如JavaScript），不需要显式地声明函数列表，而直接用arg[n]代表第n个形式参数；在Java中，也常见arg0、arg1这样的说法。

```:lisp
(lambda (阿猫) [阿猫]) = (lambda (阿狗) [阿狗])
```

**β-归约**：可以用λ项去“调用”一个函数，方法是将函数体内出现的所有有效的（没有被内层函数覆盖的）参数约束变量都替换成λ项。

```:lisp
[(lambda (x) T) 喵] => T[x→喵]
```

箭头符号`=>`代表λ项在β-归约前后的变化。β-归约描述的这个符号变换过程，也可以称为“调用”（apply/call/invoke）。尽管λ演算本身并没有定义变量替换的顺序，但是在实际的语言中，有这样几种归约（化简、求值）策略：

一、应用序求值：优先求值参数，以参数的最终值进行β-归约。从语法树的角度来看，可以看成是结果从叶子节点逐步汇集到根节点的过程。应用序求值是绝大多数编程语言所采用的求值策略。**本文采用应用序求值，这也是Scheme的默认求值顺序。**例如：

```:Scheme
((lambda (x y) (+ x y)) (* 3 3) (* 4 4))
((lambda (x y) (+ x y)) 9 16)
(+ 9 16)
25
```

二、正则序求值：优先进行β-归约，将所有参数保留原形代入函数，消除所有函数定义后统一求值。从语法树的角度来看，可以看成是根节点逐步下移，语法树逐渐缩小成一个值的过程。例如：

```:Scheme
((lambda (x y) (+ x y)) (* 3 3) (* 4 4))
(+ (* 3 3) (* 4 4))
(+ 9 16)
25
```

三、按需调用（延迟求值/懒惰求值）：这种策略可以说是前述两种策略的一个折中，在不同的具体语言中有不同的操作语义。最为典型的就是Scheme的`if`原语，此结构并不会积极地求值每个参数，更不会把所有参数都推迟到完全展开后再计算，而是根据条件的真值，“选择”一项进行求值。这个“选择”显得非常玄幻，看起来像是超脱于λ演算的某种东西，实际上并没有那么玄幻，这里就是后文所述的η-变换的用武之地了。

**η-变换**：可以对任何λ项作抽象，将其封装成一个新的λ函数。

```:lisp
f := (λ (x) (f x))
```

尽管λ项在η-变换后变成了形式上不同的另一个λ项，但是在行为上，二者是完全一致的，也就是说，给新的λ项和旧的λ项相同的输入，它们的输出也是相同的，这称为“外延等价”，即行为上的等价。这可以与集合论中的外延公理相类比。因此，η-变换可以理解成是对旧λ项的封装和抽象。

此外，有几点说明：

- 为了方便起见，引入了一个给λ项命名的手段：`(define 符号 λ项)`。有了`define`，就可以使用名字代替被命名的λ项。但是，`define`本身并不是λ演算的一部分，而是研究λ演算时所使用的元语言的一部分。递归定理表明，`define`这个命名机制实际上可以在λ演算中实现。因此，请放心使用吧。
- λ演算默认所有的函数都只有一个参数。仍然是为了方便，本文会使用支持多个参数的λ演算。通过一种叫做**柯里化**（currying）的方法，可以把多参数的λ函数变换成多层单参数λ函数的嵌套。嵌套携带有层次顺序的信息，因此在多参数的函数中，参数列表中各个形式参数是有顺序的。**参数的顺序，实际上是一种隐含的数据结构。**
- λ演算采用前缀形式的写法。前缀表达式的好处在于：其一：可以不对运算符的“目数”加以限制，后面可以跟一个甚至多于两个操作数。其二：运算符在前缀式中更能凸显其“函数”本质。其三：前缀式实际上就是AST的线性表达，相比于中缀式，可以无歧义地表达出中缀式所隐含的东西（例如“运算符优先级”等约定）。
- 作为可以实际执行的程序，而不仅仅是在纸面上抽象的符号推导，必须事先规定几个“基本（**primitive**）符号”或者“基本操作”，而这些基本操作并不属于λ演算本身，而是所谓的native的语言，即依赖于宿主机器自身的语言。在数理逻辑中，对应语言的“结构”。
- 进一步思考，四则运算等操作，能否使用λ演算的语言定义出来呢？之所以提这个问题，是因为在编程语言中，衡量一门语言的成熟程度，就看它的标准库能否用自己写出来。尽管从效率等实际的工程因素来考虑，一般是使用C甚至是汇编去写底层库，但这里我们关心的是：如此简练的λ演算，能否在自身内部定义一些基本的运算呢？这正是本文要说明的问题。

# 第三章：语义和诠释

涵义和指称

对应《数理逻辑：证明及其限度》（第二版）第五章“结构与真”。

![ ](./image/G2/缩进错误.jpg)

+ 求值顺序：积极求值和惰性求值
+ 约束变量和自由变量：闭包、环境和作用域

环境、理论

静态作用域今天看似自然且合理，但实际上在Emacs Lisp等早期的Lisp方言中，设计者并没有意识到将定义环境与运行环境分开解释，事实上使用了充满歧义的动态作用域机制。（[来源](http://www.yinwang.org/blog-cn/2012/08/01/interpreter)）后来，绝大多数语言都采用了更加严谨、易于分析的静态作用域策略。现在，在完善的OO机制的保证下，动态绑定本身已经成了一种非常灵活好用的机制，但，仍然容易令初学者迷惑。

动态作用域与“**环境**”（environment）是息息相关的。所谓的“环境”，指的是一种抽象的东西，里面保存了一段程序的**上下文**（context），以及程序运行所需的符号的具体绑定。环境是语言的背景知识，是语言创造出的虚拟空间。说到环境，就不得不提一个更加令人费解的概念——**闭包**（closure）。

# 第四章：递归和计算

本章从2017-09-22开始编写，2023-09大幅度更新。

+ 递归和迭代的区别和联系（栈vs寄存器）
+ μ-递归函数（递归论）
+ 自相似数据结构（列表）和数学归纳法
+ SICP的最大和问题，以及多步递归与多个寄存器、时域平移的关系
+ Ackermann函数

## 递归函数与可计算性

**合成和原始递归操作**

**合成**操作可以理解为函数的嵌套调用。（部分）可计算函数合成后得到的函数也是（部分）可计算的。

**原始递归**操作的一般形式如下：

$$
\begin{cases}
{prf}(\sigma , 0) = {init}(\sigma), \\\\
{prf}(\sigma , t + 1) = {step}(\sigma, {prf}(\sigma , t) , t)
\end{cases}
$$

写成Scheme是：

```:Scheme
(define prf
  (lambda (input t)
    (cond ((= t 0) (init input))
          (else (step input (prf input (- t 1)) (- t 1))))))
```

函数`prf`是`init`和`step`两个函数经过原始递归得到的。如果`init`和`step`都是可计算的，那么`prf`也是可计算的。

函数`init`给出了递归终止条件下的、在某个输入上的、原始递归函数的返回值；而函数`step`则给出了每次递归要对上次递归的结果执行怎样的处理。

**由初始函数构造原始递归函数**

合成和原始递归是构造原始递归函数的基本规则，按照这些规则将**初始函数**进行有限次处理，得到的就是**原始递归函数**。**原始递归函数是可计算的。**

初始函数有：

- 后继函数（+1，加法器）
- 零函数（返回常数0）
- 投影函数（查线性表，译码器）

在图灵机的语境下，这三个函数非常容易理解，也非常容易实现。但是在lambda演算的语境下，则显得不够简洁。例如，使用Scheme实现的列表投影函数，就不够“基本”。造成这种现象的根本原因是二者数据结构的基础不同：图灵机基于线性表和状态机，而lisp是基于嵌套表的。这本薄薄的教材暂时没有就这个问题给出更多解释。

虽然写出来会很繁琐，但是我觉得仍然有必要将感兴趣的函数用Scheme写出来。

在书中举出的若干个例子里，前驱函数是构造起来比较巧妙的一个。由于后继函数只能提供后继信息，在下一次递归后，调用前的前驱信息将丢失，因此必须以某种方式，在递归过程中保存前驱信息。对于Scheme来说，可以利用原生的表结构存储(前驱,后继)信息，每次递归调用时，同时为二者+1，递归结束时取前驱项返回即可。代码如下：

```:Scheme
;前驱函数
(define prec
  (lambda (n)
    (define prec-iter
      (lambda (x pair)
        (cond ((= x 0) 0)
              ((= x (cdr pair)) (car pair))
              (else (prec-iter x (cons (succ (car pair)) (succ (cdr pair))))))))
    (prec-iter n '(0 . 1))))
```

基于这种想法，还可以有更多简洁的写法。归根结底，都是通过保存“状态”来实现。对于命令式编程而言，状态就是存储器格局；对于函数式编程而言，状态就是堆或者栈中的参数列表。

至于补码加法实现减法这种邪术，和现在所讨论的问题已经不是同一个层次的问题了。

参见：SICP习题1.11。

对于谓词，同样有**原始递归谓词**的说法。可以证明，条件分支函数是原始递归函数。

**迭代**运算定义为原始递归函数的有限累加或者累乘，迭代后的原始递归函数也是原始递归函数。

**有界量词**可以转化到有限次的谓词迭代运算，因此使用了有界量词的谓词也是原始递归谓词。Scheme代码如下：

```:Scheme
;有界量词
(define arbitrary
  (lambda (p max)
    (cond ((= 0 max) (p max))
          (else (and (p max) (arbitrary p (- max 1)))))))
(define exist
  (lambda (p max)
    (cond ((= 0 max) (p max))
          (else (or (p max) (exist p (- max 1)))))))
```

利用现有的量词，可以构造出素数判断谓词如下：

```:Scheme
;y是否整除x
(define idiv
  (lambda (y x)
    (exist (lambda (t) (= x (* y t))) x)))

;Prime
(define is-prime
  (lambda (x)
    (and (> x 1) (arbitrary (lambda (t) (or (= t 1) (not (idiv t x)))) (- x 1)))
  ))
```

**极小化和递归函数**

**有界极小化**运算求谓词$ P(\sigma ,t)$在输入$\sigma$的条件下，取得真值的$t$的最小值；如果找不到最小值，则返回0。记作：

$$ \mathrm{min}_{t \le y}(P(\sigma ,t)) $$其中，y是极小化上界。

例如对于谓词$P(t)=5 \ge t$，其极小化的结果就是5，因为5是使谓词为真的最小自然数。

利用有界极小化算子和其他函数，可以拼凑出求素数的函数：

```:Scheme
;有界极小化（itor赋0）
(define minimalization
  (lambda (predicate max itor)
    (cond ((> itor max) 0)
          ((predicate itor) itor)
          (else (minimalization predicate max (+ itor 1))))))

;阶乘
(define fac
  (lambda (n)
    (cond ((= n 0) 1)
          (else (* n (fac (- n 1)))))))

;求第n个素数
(define prime
  (lambda (x)
    (cond ((= x 0) 0)
          (else ((lambda (y z) (minimalization (lambda (t) (and (is-prime t) (> t y))) z 0)) (prime (- x 1)) (+ 1 (fac (prime (- x 1)))))
          ))))
```

如果取消有界极小化的上界限制，则得到一般的**极小化**算子。取消了上界的极小化算子不再是全函数，因为有可能永远也找不到最小成真赋值。

因此定义**部分递归函数**（[μ-递归函数](https://zh.wikipedia.org/zh-cn/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0)）如下：由初始函数经过

- 有限次合成
- 原始递归（迭代的本质是原始递归，量词的本质是迭代）
- 极小化

三种运算得到的函数称作部分递归函数。其全函数就是传说中的**递归函数**。

## 编码和解码

**配对函数**

$$ \langle x,y \rangle =2^x(2y+1)-1 $$

**哥德尔（Gödel）数**

进制数可以看做是对自然数的一种编码方式，它将一个自然数编码为一个（并不唯一的）基本数字符号序列。与此相对，哥德尔数试图将有穷数列编码为一个唯一的自然数，其编码规则如下：

$$ [{array}(1:n)] = \prod_{i=1}^n {\mathrm {Prime}(i)^{ {array}[i]} } $$

注意，在哥德尔编码语境下的数组，约定起始下标是1。

类似于$k$进制数，哥德尔数也是带权数，只不过哥德尔数的基数是（第$i$个）素数。哥德尔数与进制数有这样几点不同：

- 哥德尔数是用乘的，而进制数用加；
- 任何有穷数列经哥德尔编码得到的哥德尔数是唯一的，而进制数一定不唯一（例如十进制25和025代表同一个数）；
- 哥德尔数的计算顺序是从左到右的，而进制数一般是高位在左的；

每一个有穷数列经哥德尔编码都可以得到唯一哥德尔数，但是反过来，哥德尔数并不对应唯一的有穷数组，例如{1,2}和{1,2,0,0}的哥德尔数是一样的，都等于18。这并不妨碍使用，尤其是解码工作。

哥德尔数的解码同编码一样是原始递归的。为了求某个哥德尔数$gcode$对应的数列的某一项（就第$i$项吧），因为所有因子项必然是整数，只需要考察整除$gcode$的第$i$个素数的几次幂，这个次数的最大值就是原数列的第$i$项，再多一项就不可能整除了。只要找到了这个不能整除的次数的最小值，就找到了原数列的第$i$项。如果找遍了所有的次数（最大肯定不能超过$gcode$）还没有遇到无法整除的情况，那就是0了。这与极小化算子的操作步骤是一致的，所以解码算法如下：

$$
\begin{align}
& \mathrm {GDecode}(gcode, i) = \\\\
& {min}_{t \le gcode} (\lnot (\mathrm {Prime}(i)^{(t+1)} | gcode))
\end{align}
$$

但由于哥德尔数不可能是0，为了使解码算法成为全函数，规定对于每个$i$，$ \mathrm {GDecode}(0,i) = 0 $；并且对于数组中没有的下标，函数也返回0。

> 以上：2017.9.22

有了哥德尔数之后，通过极小化算子也可以求出对应的最短数组的长度。

用Scheme编写哥德尔数编解码算法如下：

```:Scheme
;哥德尔数编码（itor赋1）
(define g-encode
  (lambda (ln itor)
    (cond ((null? ln) 1)
          (else (* (exp (prime itor) (car ln)) (g-encode (cdr ln) (+ itor 1)))))))

;哥德尔数解码
(define g-decode
  (lambda (gcode index)
    (minimalization (lambda (t) (not (idiv (exp (prime index) (+ t 1)) gcode))) gcode 0)))

(g-encode '(3 2 1) 1)
(g-decode 360 1)
```

**还有一些特殊的递归也是原始递归**

除了原始递归之外，书中还介绍了联立递归、多步递归和多变量递归。联立递归通过形式上的变换就可以得到原始递归的形式，所以联立递归无疑是原始递归。但对于多步递归和多变量递归，事情就没有那么简单了。

多步递归的可计算性证明：所谓的多步递归，就是每次递归都要用到不止一个过往的递归结果，甚至用到所有的递归结果。求斐波那契数列的递归过程就是一个典型的多步递归。多步递归的复杂性在于，它的递归展开和回溯过程并不是线性的，而是树状的。为了证明多步递归的原始递归本质，书中考虑了极端情况——所有过往计算的返回值都有用到。考虑函数$mr$：

$$
\begin{cases}
{mr}(0) = {init}, \\\\
{mr}(t + 1) = {step}({mr}(0) , {mr}(1) , ... , {mr}(t) , t)
\end{cases}
$$

这里特地把书中的累加抽象成了原始递归的step函数。这个step函数接受一个参数列表，其中就有从0到$t$的所有过往结果。将它们视为数列，计算哥德尔数：

$$ {MR}(t) = \prod_{i=0}^{t} {\mathrm {Prime}(i+1) ^{mr(i)}} \tag{1}$$

对其进行解码，就可以计算出每一个${mr}(i)$的值：

$$
\begin{gathered}
{mr}(i) = \mathrm {GDecode}({MR}(t), i+1) , \\\\
0 \le i \le t
\end{gathered} \tag{2}
$$

之所以要这样构造，是因为已知哥德尔数的编解码过程都是原始递归，如果可以证明${MR}(t)$是原始递归的话，说明${mr}(t)$也是原始递归。

那么就用(2)右边的式子换掉$ {mr}(t+1) $的右边的各个函数调用，就得到新的含有${MR}(t)$的形式：

$$
\begin{align}
{mr}(t + 1) &= \\\\
{step}(& \mathrm {GDecode}({MR}(t), 1) , \\\\
       & \mathrm {GDecode}({MR}(t), 2) , ... , \\\\
       & \mathrm {GDecode}({MR}(t), t+1) , t)
\end{align} \tag{3}
$$

进一步将

$$
\begin{align}
{step}(& \mathrm {GDecode}(\bullet, 1), \\\\
       & \mathrm {GDecode}(\bullet, 2) , ... , \\\\
       & \mathrm {GDecode}(\bullet, t+1) , t) \\\\
\end{align}
$$

抽象为${gstep}(\bullet, t)$，${gstep}$显然也是原始递归函数。那么$ {mr}(t + 1) $就可以写成更简洁的形式：

$$ {mr}(t + 1) = {gstep}({MR}(t), t) \tag{4}$$

到这里，就可以开始考虑${MR}$本身了。因为已经有了${mr}(t + 1)$，所以将$ {MR}(t+1) $写成递归的形式，以暴露出${mr}(t + 1)$：

$$
\begin{align}
& {MR}(t+1) = \\\\
& {MR}(t) \cdot \mathrm {Prime}(t+2)^{mr(t+1)}
\end{align} \tag{5}
$$

将(4)代入(5)得到：

$$
\begin{align}
& {MR}(t+1) = \\\\
& {MR}(t) \cdot \mathrm {Prime}(t+2)^{ {gstep}({MR}(t),t)}
\end{align} \tag{6}
$$

现在可以进一步将$ (\bullet) \cdot \mathrm {Prime}(t+2)^{ {gstep}(\bullet,t)} $抽象为$ {GSTEP}(\bullet,t) $，简化(6)得到：

$$ {MR}(t+1) = {GSTEP}({MR}(t),t) \tag{7} $$

由于$ {gstep} $是原始递归函数，所以$ {GSTEP} $也是原始递归函数。这样的话，(7)式以及${MR}(0)=2^{init}$的事实说明${MR}$也是原始递归函数。

既然${MR}$是原始递归函数，那么**多步递归${mr}$也是原始递归函数，也就是可计算函数。**

多变量递归可计算性的证明同样利用了哥德尔编解码。

**Ex 2.1 原始递归性证明**

试证明：仅在有穷个点取非零值，其余点取值均为0的函数$f(x)$必为原始递归函数。

**证明**：设$f(i)$为非零函数值，$I$是非零取值自变量集合，$i \in I$。则构造包含所有非零函数值的有穷数列$A=\{f(i)\}$，其中$f(i)$的下标是$i$，其余下标不属于$I$的项都等于0。因此可以计算出$A$的哥德尔数

$$ {gcode} = \mathrm {GEncoding} (A) $$

对其进行解码：

$$ g(x) = \mathrm {GDecode} ({gcode}, x) $$

若$x \notin I$，则$g(x)=f(x)=0$；若$x \in I$，则$g(x)=f(x)\neq 0$。也就是说，$g(x)=f(x)$。

由于$\mathrm {GDecode}$是原始递归的，因此$f(x)$也是原始递归的。原命题得证。

书中将其构造为反向函数+时域平移+求和的形式，从而构造性地证明了题设函数的原始递归性。这很像表达离散时域信号的方式。

**Ex 2.12 最大公约数的原始递归性**

试证明：最大公约数`gcd(x,y)`是原始递归函数。

**证明**：由于有界极大化是原始递归，并且$\mathrm {GCD}(x,y) = \mathrm {max}_{t\le y} (t | x \land t | y)$，因此`gcd`是原始递归的。

**阿克曼（Ackermann）函数**

阿克曼函数可以说是可计算函数里面的一股清流了。前段时间在做SICP的习题1.10时就觉察出这个函数的变态之处，但是当时并不晓得这个函数的意义所在。The Little Schemer也有专门提到这个函数。从实际意义上来说，这个函数的增长阶极高，以至于没什么实际用处；但是在可计算理论中，这个函数被证明是可计算的并且是非原始递归的。它的存在，意味着“可计算”并不等价于“原始递归”。

> 原始递归是可计算的充分条件，但不是必要条件。

> 以上：2017.9.23

**字函数的可计算性**

2.2.2节中，已经考虑到了进制数这一编码形式。进制数的实质是字符串，所使用的字母表就是基本数字和一些其他的字母。书中证明，进制数的编解码是原始递归的，并且通过舍弃“0”这一字符，避免了进制数的不唯一性。经过编码的字函数，本质上是数论函数。由于字函数编解码过程都是原始递归的，所以经进制数编码的可计算（部分可计算、原始递归）数论函数，即对应的字函数，也是可计算（部分可计算、原始递归）的；并且可以证明，这一结论不受字母表符号顺序的影响。

## 丘奇-图灵论题

**图灵机与部分递归函数**

书中给出的语言有四条基本语句：空语句、增量、减量和条件（为0）跳转。但是这个指令集完备吗？这里暂时没有给出回答。

所有变量及其取值组成的有穷映射称为程序的**状态**，这个在调试的时候很清楚。

程序状态与下条指令组成的有序对称为程序的**快照**。

对某个非终点快照按照指令行为加以解释，可得到它的**后继快照**。

由快照→后继快照组成的有穷快照序列称为一个**计算**。如果程序陷入死循环，或者不考虑资源消耗的无穷递归，那么快照序列就是无穷的，这就属于不可计算了。无法在有限的步骤内给出有意义的结果，就属于是不可计算。

当然，对于计算机（尤其是图灵机）而言，获得结果并不是唯一的目的，计算过程中的“**副作用**”也是需要加以利用的。比如说操作系统本质上就是一个大的死循环，它并不以输出什么为目的，它只要一直运转就行了，就像一台自动扶梯一样。很多人用C语言写程序的时候，尤其是初学者写嵌入式程序的时候，往往会忽视返回值的问题，甚至无视规范写出`void main()`这样的函数，这就是忽视了程序的“初衷”，毕竟跑马灯不需要返回什么结果。所以我们说C语言是“过程式”语言，因为它非常关注计算过程本身，也引导程序员通过分析计算过程来编写程序。

**可计算性与可计算函数**

The Little Schemer 第九章给出了这样的一个函数：

```:Scheme
(define looking
  (lambda (a lat)
    (keep-looking a (pick 1 lat) lat)))

(define keep-looking
  (lambda (a sorn lat)
    (cond ((number? sorn) (keep-looking a (pick sorn lat) lat))
          (else (eq? sorn a)))))
```

这个函数的特点是：对于某些输入，可以终止并输出结果；但对于另外一些输入，例如`(2,1,a)`，程序就会陷入死循环，永远无法停止。

所谓的数论函数，就是从自然数笛卡尔积集到自然数的函数。下文首先考虑数论函数。

设程序所计算的（数论）函数为$\psi (\mathbf \sigma )$，其中$ \mathbf \sigma $是初始状态，也就是算法的输入参数。对于程序终止且输出有效结果的情形，$\psi (\mathbf \sigma ) = Y $，其中$ Y $是最终状态中代表结果的变量；对于程序无法终止的情形，$\psi (\mathbf \sigma ) \uparrow$。函数$ \psi $在这里显然是一个部分函数，称为**部分可计算函数**。如果它恰好是一个全函数，也就是说，并没有那种能够导致死循环的输入，那它就是**可计算函数**。

**谓词**是值域为{0, 1}的全函数，相应地存在**可计算谓词**的概念。

**丘奇-图灵论题：直观可计算与（等价）图灵机可计算是同一回事。**

基于这个“论题”，只要是图灵机可实现的计算，那么就认为它是直观可计算的。所谓的直观可计算并不是一个严格的形式化概念，所以这个论题也只能叫“论题”。因为还没有发现“直观可计算”但图灵机无法计算的算法，所以大家默认CT论题是正确的。

## 递归定理与通用计算机

克林尼（Kleene）正规型定理

前面两章初步构建了基于递归函数的计算模型。为了在既有的数论基础上研究“程序”，首先要对程序进行编码，得到的就是“代码”。代码的存在，消除了数据与程序的界限，也因为代码的无穷尽性，让人们看到了递归函数的“能”与“不能”。

**程序的代码**

代码，就是指代程序的编码。书中，使用配对函数为快照进行编码，使用哥德尔数对计算过程（即快照序列）编码进行编码。为了避免麻烦，规定最后一条语句的后面不允许再有空语句。由于哥德尔编解码和配对函数都是可计算的，因此每一个程序都可以得到它的编码。又由于空指令的快照编码（被钦定）为0，所以程序末尾的空语句并不会影响程序的哥德尔编码，这样就保证了**①每一个程序都对应唯一的一个自然数**。反过来，对于任意的一个整数，**②总可以通过解码得到它对应的程序**，虽然这样得到的程序可能（大概率的可能）并没有什么卵用。这样，就保证了**每一个程序都与自然数有一一对应的关系**。

程序，也即部分可计算函数与自然数的这种双射关系，是后面许多术语带有“枚举”二字的根本原因。因为我们可以通过（递增地）枚举所有自然数，得到所有可能的程序，如《计算的本质》书中妙语所言，只要你愿意等待，总可以枚举出诸如Ajax或者Windows这样的伟大程序然后回家睡觉。

**通用程序**

这一节论述了这样一个事实：**可以构造这样一台计算机：它接受某个程序（的代码）以及该程序的输入作为输入，输出的结果就是输入程序的输出结果。**这意味着宿主机器是具有**通用性**的，它可以模拟任何一台其他的机器。在Windows系统里面可以运行Ubuntu虚拟机，在Ubuntu虚拟机中可以运行Python解释器，在Python解释器中可以运行Lisp解释器，这个Lisp解释器同样可以解释其他的Lisp程序……如此直至无穷，唯一的限制便是时间和空间，以及递归集之外无法穷尽的思维角落。通用性定理是计算机的理论基础，揭示了“程序即数据”最本质的原因。

**定理3.2 通用性定理**

所有程序可通过哥德尔编码与自然数集合建立一一对应关系。设程序$P$的代码为$p$，其计算的部分可计算函数为$\psi (\mathbf x)$，其中$\mathbf x$是程序的输入（向量）。现有函数

$$\Phi (\mathbf x, p) = \psi (\mathbf x)$$

当$p$取0、1、2……即可枚举出**所有**的部分可计算函数。上式中，$\Phi $体现出解释器的行为，即以程序代码为输入，以输入程序的输出为自己的输出。可以证明，函数$\Phi (\mathbf x, p)$都是部分可计算的。这就是通用性定理。

由于$\Phi $本身是部分可计算的，所以同样可以构造出解释$\Phi $的$\Phi (\Phi)$，也就可以构造出解释$\Phi (\Phi)$的$\Phi (\Phi (\Phi))$……这是好事，也是坏事。好事是总可以通过恰当的封装和抽象去方便地实现某种功能，而不削弱功能；坏事是我们似乎看到了图灵等价计算模型（部分递归函数类的计算能力与图灵机是等价的）的计算能力极限，无论如何抽象，都不能突破计算能力的天花板……

**定理3.3 计步定理**

通用性证明的过程中构造了计步谓词$\mathrm {STP}(\mathbf x, p, t)$及其对应的程序，该谓词表示代码为$p$的程序能够在$\mathbf x$的输入下在$t$步后停机。既然可以构造出计步谓词对应的程序，意味着计步谓词是可计算的。$\mathrm {STP}$与$\mathrm {HALT}$的区别有点像有界极小化和极小化的区别。至于计步谓词为何是可计算的，其实很容易理解，如果在有限步骤内没有结束，则返回false，无论如何总能返回一个结果，所以是可计算的。

------

所谓图灵机的通用性，指的是**[[#ff0000:可以构造一个通用图灵机（UTM），它可以模拟出包括通用机在内的任何一台图灵机的行为#]]**。如何理解这句话呢？

至今为止，我们写出的每一段程序，都对应一部图灵机，都只能完成某一个特定的任务。通用性定理告诉我们，可以写出一台**[[#ff0000:可编程#]]**的机器，它可以“运行”其他的图灵机，完成其他图灵机的任务。进一步说，我们可以写出足够强大的通用图灵机，在它的上面可以运行另外一个通用图灵机……如此嵌套，理论上可以嵌套无穷层。

通用性定理带给我们的另一个重要启示是：**[[#ff0000:程序代码本身，也可以作为输入程序的数据#]]**。这一点，其实是非常自然的，也就是“解释器本身就是解释程序的程序”，JVM本质上也只不过是磁盘上的一个文件而已。许多高级语言，也提供了各种机制，帮助我们站在数据的角度上，去看待和操纵数据。例如，C++的模板和泛型、Java的反射、函数式语言的一等函数、Ruby强大的元编程等等。这些技术，都可以统称为“元编程”，即使用代码操纵代码的编程。

是不是很熟悉？没错，实际机器中，不同结构层次的UTM，有不同的名字：**解释器**、**虚拟机**、**指令集**，等等。尽管每一层的任务都不同，但是在理论上，每一层都是通用的。

许多语言也提供了运行时解释/编译的能力，名字可能叫做“动态编译”等等。总而言之，这类机制一般会提供一个诸如JS的`eval(code)`的接口，可以在运行时执行代码。对于一般的开发者而言，程序的功能是明确而有限的，一般不需要这些动态执行接口。但是，在某些场景下，例如手机App热更新代码还有某些计算机病毒，这些场景下就必须将数据作为代码，并在运行时动态地执行。这种动态执行的功能是极其强大，同时又极端危险的，所以各大平台一般都会封堵掉编程语言提供的这类接口，例如微信小程序就封堵了JavaScript的`eval`函数和`Function`类，避免开发者热更新内部代码。但是根据通用性定理，只要平台提供的语言是本身图灵完备的，理论上就可以手工写出`eval()`函数，相信鹅厂的工程师也明白这一点。在杀毒软件、iOS和现代浏览器中，普遍使用的“沙箱”，实际上就是一个UTM，它模拟出一个虚拟的但是与物理机完全隔离的世界，而这个世界实际上是运行在物理机这个UTM上面的，只不过它们中间还有一道关口，用来隔离二者。这种“隔离”，只要明白了我们上一节讨论的“闭包”和“作用域”思想，就很容易理解了。

使用以下代码说明什么是“部分可计算”：

```:js
function foo(array, index) {
    if(index === 100) {
        return 'Surprise!';
    }
    else {
        return foo(array, array[index]);
    }
}
```

**递归定理**

撰文时恰好发现一个绝妙的Quine，在这里：https://github.com/mame/quine-relay

数据即代码——自我解释

![截自《南家三姐妹》第4季第4话](./image/G2/kanousei.jpg)

## 递归可枚举集

从第一章的`looking`程序可以看到，对于部分可计算函数来说，它们的定义域是自然数集的子集。我们已经在3.1中知道，部分可计算函数，也就是“程序”的个数是可数的，那么，所有部分可计算函数的定义域所构成的集合，同样是可数的，并且不会比自然数集合要“多”。可是问题在于，自然数集的全体子集构成的集合并不是可数的，也就是说，部分可计算函数的定义域，比自然数集的子集要少得“多”。既然我们可以枚举出所有部分可计算函数的定义域，因此，给这种并不平凡的集合类起了个名字——递归可枚举（recursively-enumerable，r.e.）集合。

形式化地表述就是，如果存在部分可计算函数$g(x)$，使得

$$ E=\{x\in \mathbb N | g(x) \downarrow \} $$

则称$E$为**递归可枚举集**。

如果一个自然数有幸成为r.e.集的元素，那么它必然导致某个程序停机。反过来，如果一个自然数可以导致某个程序停机，那么它必定是某个r.e.集的元素。然而，如果一个自然数并没有使某个程序停机，那么它**未必不属于**该程序对应的r.e.集，因为它可能只是需要更长的时间才能停机而你却等不及。所以，r.e.集在成员资格判定这个问题上，能力是有限的，其根本原因就在于部分可计算函数的“部分”性。

如果$g(x)$是全函数呢？由于$g(x)$是全函数，对于任何一个输入都可以得到结果，因此可以对集合元素加更多限制，得到新的集合类。如果定义可计算谓词$ \chi_{B} (x)$，表示某元素$x$是否属于集合$B$，那么

$$ B=\{x\in \mathbb N | \chi_{B} (x) \} $$

谓词$ \chi_{B} (x)$称为集合$B$的特征函数，若特征函数$ \chi_{B} (x)$可计算，则集合$B$是**递归**的。

从上面的论述就可以感觉到，递归集很可能是递归可枚举集的子类，事实确实如此。如果将递归集看做是二分类之后的r.e.集，就比较容易理解了。因此，

** 定理3.5 递归集必是递归可枚举集。**

既然说到了“二分类”，考虑这个问题：如果一个r.e.集$E$和它的补集$\overline E$都是r.e.集，那么就可以从正反两个方面确定两个集合各自可计算的“领域”，换言之，可以确定某个元素要么在$E$中，要么在$\overline E$中，并没有其他可能。这就相当于构造出了对$E$（或者$\overline E$）的可计算特征函数。因此，结合定理3.5，可以证明，

**定理3.6 集合$E$是递归的，当且仅当$E$和$\overline E$都是递归可枚举的。**

书中通过构造联合计步程序的方式证明了这一定理。不管用什么方法，总觉得这就是排中律的某个具体结论而已。

在GEB中，侯世达用“可以流畅画出”的图形来比喻递归可枚举集。可以流畅画出，意味着这个图形本身是具有某种意义的，但是如果把这个图案从背景上抠掉，那么背景所形成的图案也许就没有任何意义了，这是非常平常的。然而，艾舍尔以它非凡的想象力创造出许多名作，在这些精美的镶嵌画中，不仅前景是有意义可解释的，背景也是有意义可解释的；前景和背景一起，组成了一种宏观的和谐，侯世达将这种和谐称为“倍流畅”的。如果一个图形在它的前景和背景都具有可解释的意义，那么这个图形就是“递归”的。

递归可枚举集合类关于交、并运算是封闭的，这也很容易理解，因为与、或运算都是原始递归的。因此得：

**定理3.7 递归可枚举集合的交集和并集也是递归可枚举集合。**

推广到递归集就是书中的定理3.4了。不同的是，递归集的补集仍是递归集，因为递归集是非黑即白嘛。

那么，递归可枚举集的补集是什么呢？

本节开头就点明了“递归可枚举集就是部分递归函数的定义域”这一事实，并以此引入了r.e.的概念，这也是书中定理5.11明确指出的。根据定理3.2通用性定理，如果将部分可计算函数$g(x)$写成虚拟机在通用机中运行的形式$\Phi (x,p)$，那么集合

$$ W_p = \{ x \in \mathbb N | \Phi (x,p) \downarrow \} $$

显然是递归可枚举集合。并且，由于$p$可以取遍所有自然数，因此可以枚举出所有的$W_p$。这就是：

**定理3.8 枚举定理：集合$B$是递归可枚举的，当且仅当存在$n \in \mathbb N$使得$B=W_n$。**

与停机问题类似，不可计算的问题要远远多于可计算甚至部分可计算的问题，但停机问题是最典型的一个不可计算的问题。为了思考r.e.集的补集的问题，不妨借用停机问题的思路，构造一个集合$K$，它的元素是所有自己在自己的代码上停机的程序代码的集合

$$ K = \{ n\in \mathbb N | n \in W_n \} $$

按照上面给出的$W_n$的定义，也可以写成

$$ K = \{ n\in \mathbb N | \Phi (n,n)\downarrow \} $$

这明显是一个r.e.集。

它的补集$ \overline K $，也就是所有不在自己的代码上停机的程序代码的集合也是r.e.吗？为此，考虑$K$的特征函数，也就是$\mathrm{HALT}(n,n)$，而这个特征函数是不可计算的，也就是说，$K$并非递归集，从而$ \overline K $也不是递归可枚举集。

整个自然数集合是递归可枚举集，因为根据枚举定理，可以写出诸如`(lambda (x) x)`这样的函数，它的定义域是$\mathbb N$。同样的，可以将空集视为递归可枚举集，因为可以写出诸如`(define wtf (lambda (x) (wtf x)))`这样的函数。所以自然数集和空集都是递归集。

在书中5.4节中，给出了这样的结论：如果非空集合$B$是递归可枚举集，那么以下命题等价：

- $B$是部分可计算函数的定义域
- $B$是原始递归函数的值域
- $B$是（部分）可计算函数的值域

> 以上：2017.9.26

## 不可判定问题

**停机问题**

http://blog.csdn.net/pongba/article/details/1336028

**假设**有一个神奇的程序`(isHalt p x)`，它计算谓词$\mathrm {HALT}(p, \mathbf x)$，这个谓词可以针对任何一个程序，回答在某个输入上该程序可否停机。于是图灵构造了这样的一个程序：

```:Scheme
(define wtf
  (lambda (p x)
    (cond ((isHalt p x) (eternity x))
          (else #t))))
```

用`wtf`和任意输入`x`去调`wtf`，也就是执行`(wtf wtf x)`：如果`wtf`可以停机，那么它本身就会陷入`(eternity x)`的循环中无法停机；如果`wtf`不能停机，那么它本身又会立即返回值而停机。这个矛盾意味着，并不存在计算谓词$\mathrm {HALT}$的程序。也就是说：

**定理3.1 停机问题不可计算**

我们不可能在有限的时间内判断一个程序在某个输入上能否停机，**停机问题是不可计算的**。

然而，停机问题并非唯一的不可计算问题。由于自然数集上的函数集的势是大于$\aleph_0$的，所以这种不可计算的问题应该说是非常“多”了，sad。

证明停机问题不可计算的关键就在于构造自我指涉，而自指的技巧，早在康托尔证明实数集不可数的时候，就已经开始使用了。

**对角线证明法**

对角线证明法是康托尔提出的，是用来证明$(0,1)$不可数的一种巧妙的方法。

所谓“可数”，指的是集合中的每个元素都可以与自然数建立一一对应的双射关系。假设$(0,1)$可数，那么存在函数$f(i),i\in \mathbb N$与集合中**每一个数**相一一对应。将$(0,1)$内的每一个数都写成十进制的无限小数（有限小数在末尾添加无穷个0），每个数写一行。并且，表中不允许存在以999...结尾的数字。以小数的序号为行数，小数的位序号（从0开始吧）为列数，列出下表：

| |0|1|2|3|4|5|...|
|-----------------|
|0|?| | | | | |...|
|1| |?| | | | |...|
|2| | |?| | | |...|
|3| | | |?| | |...|
|4| | | | |?| |...|
|5| | | | | |?|...|
|...| | | | | ||...|

设$(0,1)$内的某个数$r$的每一位$i$都与$f(i)$的第$i$位（也就是上表对角线上的问号）不等（例如循环加一），这样$r$仍然是$(0,1)$内的实数，但是与表中每一个$f(i)$都不相等。也就是说，构造出了不在上表中的，然而却真实存在的$(0,1)$内的实数。但根据假设，$f(i)$可以对应所有的实数，这就引起了矛盾。最终得到结论：$f(i)$是不存在的，$(0,1)$不可数。

程序可以通过编码转化为自然数，`wtf`程序的构造实际上也是利用了对角线证明法。停机函数`isHalt`接受程序（代码）和程序的输入，输出表示程序能否在输入上停机的布尔值。假设`isHalt`可计算，那么可以列出这样一张表：以程序代码为行数，以程序输入为列数，表格内容是输出的布尔值，如下：

|      |0|1|2|3|4|5|...|
|----------------------|
|Code:0|?| | | | | |...|
|Code:1| |?| | | | |...|
|Code:2| | |?| | | |...|
|Code:3| | | |?| | |...|
|Code:4| | | | |?| |...|
|Code:5| | | | | |?|...|
|...| | | | | ||...|

表中对角线上的元素代表某程序以自己（的代码）为输入时能否停机。现在不妨构造这样一个程序$P$：对于**任何**程序（代码）$i \in \mathbb N$，将其输入程序$P$的停机情况$\mathrm {isHalt}(P, i)$，都与它以自己为输入的停机情况$\mathrm {isHalt}(i, i)$相反。这样，$P$就不属于表中的任何一行，也就是说，$P$是不可构造的，矛盾。这就意味着停机谓词是不可计算的。

> 总感觉递归是人类思维的一个奇点、一个bug。

> 以上：2017.9.25

## 归约和度

## 丘奇编码

**自然数**

这里采用Church提出的方法，从零开始逐渐构造自然数，直至无穷。首先，定义数0如下：

```:Scheme
(define @0 (lambda (f a) a))
```

可以这样理解这个定义：`@0`作为一个函数，它接收两个参数，第一个参数`f`是一个函数，而第二个参数`a`是提供给`f`的参数。在`@0`的函数体中，并没有使用`a`去调用`f`，而是原封不动地直接返回。因此，我们可以说，`@0`是使用`a`调用`f`**零次**的结果。

基于这种理解，我们可以定义**后继函数**如下：

```:Scheme
(define INC
  (lambda (n)
    (lambda (f a)
      (f (n f a)))))
```

请注意，后继函数返回的是数字，即接收两个参数的函数。在函数体内部，`INC`用原来数字的结果又调用了一次`f`，并构造新数字返回，这就实现了“加一”的目的。

有了`@0`和后继函数，就可以产生出所有的自然数。数字是用函数表示的，因此可以这样理解：表示数字的函数的内部调用`f`几次，这个函数就代表几。例如：

```:Scheme
(define @1 (lambda (f a) (f a)))
(define @2 (lambda (f a) (f (f a))))
(define @3 (lambda (f a) (f (f (f a)))))
……
```

**布尔代数**

布尔代数只有对立的两个值。如果把布尔值看成是一个道岔，那么两个布尔值分别指向不同的方向。因此，可以把布尔值定义成接收两个参数的函数，使其返回两个参数之一，这就构造出了布尔值。

```:Scheme
(define @true  (lambda (x y) x))
(define @false (lambda (x y) y))
```

看到了吗，`@false`的形式和`@0`的形式是完全一致的诶。在C语言等许多语言中，都有类似的以0（或者某个特殊值）指代false，而以其他任何值指代true的特性。

返回布尔值的函数称为“谓词”。现在来构造最简单的谓词`IS_ZERO`，思路是：首先谓词也是一个函数，它接收一个数字`n`作为参数。其次，数字`n`接收两个参数`f`和`a`。注意到在所有的自然数中，只有`@0`会原样返回`a`，因此，在`IS_ZERO`的函数体中，可以将`@true`作为`a`去调用`n`。`n`的参数`f`是一个函数，为了使所有的非`@0`数字调用这个函数都得到`@false`，只需要使`f`恒返回`@false`。至此，`IS_ZERO`就被构造出来了。它的形式是这样的：

```:Scheme
(define IS_ZERO
  (lambda (n)
    (n (lambda (x) @false) @true)))
```

这个过程暗示着，为了满足语义上的正确性，貌似需要对变量的“类型”加以限定。只有在参数中代入类型合适的λ项，才能得出有意义的结果。

判断结构是几乎所有的编程语言都有的结构。现在，有了两个布尔值，还有一个谓词，就可以尝试构造一个判断结构了。最基本的判断结构接受一个条件和两个分支，条件的真值不同，执行的分支也不同。而刚刚构造的两个布尔值，本身就具有分支选择的功能，因此，可以把布尔值封装起来，这就是`IF`判断结构：

```:Scheme
(define IF (lambda (p x y) (p x y)))
```

可见，`IF`就是对布尔值使用η-变换后形成的封装。因为`IF`很好用，看起来甜甜哒，所以称它为布尔值函数的“语法糖”。喜欢吃糖，总有一天要吃苦头的。

布尔代数中，有与或非三个基本运算，这三个运算是完备的，因此我们首先构造这三个基本运算。

取反运算`NOT`很简单，它是一个接收1个布尔值作为参数的函数。

```:Scheme
(define NOT
  (lambda (bool)
    (bool @false @true)))
```

若两个真值之中有一个为`@false`，则得到`@false`，否则得到`@true`。这是`AND`。与运算`AND`的特点是，如果两个布尔值里面有一个是`@false`，那么结果就是`@false`，否则得到`@true`。我们可以充分利用之前得到的经验，即将函数作为参数传入另一个函数，实现某种效果。因为`AND`接收两个布尔值，而布尔值有选择器的效果，我们不妨只关注第一个参数，并把它用作选择器，而另一个参数当作值，就像数字那样。当第一个参数取`@false`的时候，`AND`应当返回`@false`也就是第一个参数自身；当第一个参数取`@true`的时候，结果取决于第二个参数的值。因此，可以这样构造`AND`：

```:Scheme
(define AND
  (lambda (boolx booly)
    (boolx booly boolx)))
```

类似地，可以构造`OR`运算：

```:Scheme
(define OR
  (lambda (boolx booly)
    (boolx boolx booly)))
```

当然，构造方式并不是唯一的，只要能够满足类型约定和语义，就是正确的。

**有序对**

有序对，就是两个元素按照固定的顺序排列，形成的结构。可以按照这样的方式构造一个有序对`PAIR`：有序对是一个函数，它返回一个函数。具体形式是：

```:Scheme
(define PAIR
  (lambda (x y)
    (lambda (f)
      (f x y))))
```

首先，为什么`PAIR`要返回一个函数呢？因为从语义（运行时）的角度来讲，函数不仅仅是简单的字符串，而是一个保存了运行时上下文的数据结构。可以发现，`PAIR`将两个元素传入一个函数`(lambda (f) (f x y))`，并返回这个函数。刚刚传入的两个元素`x`和`y`很明显是这个函数的自由变量，为了在其他的地方使用这个被返回的函数时，不丢失生成它的上下文的信息（也就是`x`和`y`），它自己必须保存`x`和`y`的具体值（可以是立即值，也可以是引用，这与语言实现有关）。像这种，保存了包括自由变量的值在内的上下文环境的“函数”，称为“**闭包**”（closure）。因此，严格地说，**`PAIR`返回的是一个闭包**，一个包含了有序对的元素、及其位置信息的闭包。这个闭包不仅保存了信息，它还有行为——接收另外一个函数，去处理保存在闭包内部的元素。

其次，之所以这样构造`PAIR`，是因为这样可以充分利用两个布尔值的选择器作用。有了`PAIR`，有了布尔值，很容易写出分别提取`PAIR`中左右元素的函数：

```:Scheme
(define LEFT  (lambda (pair) (pair @true)))
(define RIGHT (lambda (pair) (pair @false)))
```

另外，上文有说过，参数的顺序是一种隐含的数据结构。`PAIR`把两个参数**按顺序**放置在参数列表中，经柯里化就可以得到嵌套的两层λ函数。层次信息结合闭包特性，就是`PAIR`这个数据结构的运作原理。说到这一点，可以看一下SICP的习题1.3。简单来说，这个题要求找出三个数中最大的那个。常规思路是使用多个`if`对每种情况做判断，而使用λ函数的特点，可以写出这样的算法：

```:scheme
(define max
  (lambda (x y z)
    (if (and (>= x y) (>= x z))
        x
        (max y z x))))
```

这个算法充分利用了参数列表的“列表”特性，在递归中实现了列表的位移操作，简洁而机智。

有了自然数、布尔值和有序对，就可以继续建构更复杂的结构，描述更复杂的运算了。

**自然数的算术运算**

首先从加法开始。加法，例如m+n，它的意义非常简单，就是给m（n）反复加一，重复n（m）次。因为上一章构造出来的数字有这种“重复n次”的意义，因此可以这样构造：

```:Scheme
(define ADD
  (lambda (m n)
    (m INC n)))
```

为了后文方便，这里先对`ADD`做柯里化：

```:Scheme
(define ADD-c
  (lambda (m)
    (lambda (n)
      (m INC n))))
```

有了加法，就可以构造出乘法，乃至乘方。这里就可以看出柯里化的意义所在了：柯里化的`ADD-c`，在只传入一部分参数（例如“2”）的时候，返回的是闭包，意义是“加2”。有的地方把这种特性称作“[部分调用](https://en.wikipedia.org/wiki/Partial_application)”。

```:Scheme
(define MUL
  (lambda (m n)
    (n (ADD-c m) @0)))

(define MUL-c
  (lambda (m)
    (lambda (n)
      (n (ADD-c m) @0))))

(define POW
  (lambda (m n)
    (n (MUL-c m) @1)))
```

减法要更难一点。因为加法是“重复”，是某种意义上的向前看，而减法则需要“回顾”，需要某种方法去“记忆”。使用纯λ演算构造减法的方法同样不止一种，下面的这种方法是最容易理解的一种。

为了理解构造减法的思路，可以想象一个无穷数列，这个数列以`@0`为界，左侧是无穷多个`@0`，右侧是从`@0`开始的按后继顺序排列的自然数列。有一个宽度为2的滑动窗口，可以在这个数列上滑动，通过窗口，只能看到两个相邻的数字。

首先将滑动窗口初始化在最右侧的两个`@0`上，然后向右滑动n次，此时，窗口右侧的数字是n，而左侧的数字是(n-1)。只需要把窗口左侧的数字取出来，就可以获得(n-1)了，也就是n的前驱数。有了前驱数，就可以构造出减法了。

现在已经有了窗口，也就是`PAIR`，于是问题归结到，如何描述这个“滑动”的过程呢？

仍然是构造一个函数`SLIDE`，它接收一个旧窗口，将旧窗口右边的数放到新窗口的左边，然后将旧窗口右边的值后面的那个数（也就是后继数）放到新窗口的右边，返回新窗口。这样就实现了窗口向右滑动的效果。

```:Scheme
(define SLIDE
  (lambda (pair)
    (PAIR (RIGHT pair) (INC (RIGHT pair)))))
```

也可以理解成，窗口不动，数列向左走一步后，窗口里看到的两个数。这样，就可以构造出前驱函数`DEC`和减法`SUB`了。

```:Scheme
(define DEC
  (lambda (n)
    (LEFT (n SLIDE (PAIR @0 @0)))))

(define SUB
  (lambda (m n)
    (n DEC m)))
```

需要注意的是，刚刚实现的减法并不是普通减法。因为，如果减数`n`比被减数`m`大，则窗口会滑动到左侧的`@0`的区域中，结果是`@0`，而不是负数（毕竟我们现在还没有构造负数）。这种减法叫做“[monus](https://en.wikipedia.org/wiki/Monus)”，符号是减号上面加个点。

> 下文是另一种构造monus的方法，撰写于2018年11月13日。王垠在博文《[GTF - Great Teacher Friedman](http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman)》里提到，他的同学花了一个星期的时间，构造出前驱函数的另一种表示方案，这个表示跟克林尼最初的设计是完全不同的。因λ演算是“无状态”的，构造前驱函数并不是很简单。前文所述方法（可能是克林尼最初构造的那个）是先构造有序对，通过有序对保存两个相邻的数，从而实现前驱函数。这种方法是较容易理解的，也是许多讲丘奇编码的书会讲的方法。而王垠的这位同学所想到的方法则比较难懂。大概的思路是：将丘奇数封装在一个特殊构造Value中，实现相对于丘奇数的移位，然后重新构造类型为(Value→Value)的后继函数。通过公理"某数的后继为自然数0对应的Value"，构造出"-1"的Value表示，从而成功构造出前驱函数。下面将对这一方法做一简要介绍，内容主要是参考了维基百科中对此方法的解释。

> 下文把前驱函数统一记作`PRED`，其接受一个丘奇数作为参数，返回参数的前驱丘奇数。注意`(PRED ZERO)`的值仍然是丘奇数0`ZERO`。`PRED`的框架是

> ```:scheme
(define PRED
  (lambda (number)
    (lambda (f x)
      ...)))
```

> 通过有序对构造前驱函数的方法不再赘述。首先回顾一下丘奇数的构造。丘奇数的构造思路是：用函数嵌套层数来表达自然数。按照这种思路，丘奇数接受两个参数：其一是供反复嵌套调用的函数`f`，其二是传递给这个函数的参数`x`。

> ```:scheme
(define ZERO
  (lambda (f x) x))
(define ONE
  (lambda (f x) (f x)))
(define TWO
  (lambda (f x) (f (f x))))
```

> 后继函数`SUCC`很容易构造出来，也就是在原有丘奇数的基础上，把`f`多嵌套一层，然后返回新的丘奇数即可。

> ```:scheme
(define SUCC
  (lambda (number)
    (lambda (f x)
      (f (number f x)))))
```

> 多嵌套一层很容易，但是去掉一层嵌套比较麻烦。

> 构造`PRED`的关键在于“重新定义”丘奇数和后继函数。通过封装的手段，可以构造一个丘奇数的容器，记作`VALUE`。它接受一个丘奇数（**的返回值，即嵌套调用部分`(f..(f x)..)`，为简洁起见，下同**），返回一个闭包，这个闭包将传入的丘奇数保存在参数的位置，其定义为

> ```:scheme
(define VALUE
  (lambda (number)
    (lambda (package)
      (package number))))
```

> 很容易看出，

> ```:scheme
((VALUE n) f) = (f n)  （性质(*)）
```

> 利用这个性质，可以构造辅助函数`EXTRACT`，用来从封装的VALUE中得到`number`：

> ```:scheme
(define EXTRACT
  (lambda (value)
    (value (lambda (x) x))))
```

> 上面这个性质与后继函数的行为非常接近。基于此性质，可以构造一个新的后继函数`INC`，与丘奇数后继函数不同的是，`INC`以封装的VALUE为输入，以后继的VALUE为输出。

> ```:scheme
;; VALUE -> VALUE
(define INC
  (lambda (value)
    (lambda (package)
      (package (value f)))))
```

> 因`(value f)`得到的是原有丘奇数的后继数（也是丘奇数），所以`INC`需要将它再次封装为VALUE。需要注意的是，`INC`引入了自由变量`f`，而这个`f`已经在`PRED`的框架中出现了（即丘奇数所需的那个`f`），因此实际上是约束的。

> 下面的步骤验证了`INC`的递推性质，并且构造了“-1”所对应的VALUE，将其设为迭代起点。

> 记`V0 = (VALUE x)`，则根据性质(*)和`INC`定义：

> ```:scheme
            V0 = (VALUE x)
      (INC V0) = (VALUE (f x)) = V1
(INC (INC V0)) = (VALUE (f (f x))) = V2
              ...
      (INC Vn) = V[n+1]
```

> 如果将`INC`在`V0`上反复调用`n`次（`n`是丘奇数），则

> ```:scheme
(n INC V0) = Vn
```

> 这里`Vn`可理解为自然数n所对应的VALUE。为了构造前驱函数，只需要再构造出一个“-1”，即`V[-1]`，从`V[-1]`而不是`V0`开始这个迭代过程，就可以实现前驱函数。

> 显然，`V[-1]`应具有性质

> ```:scheme
(INC V[-1]) = (VALUE x) = V0
```

> 展开得到

> ```:scheme
(lambda (package) (package (V[-1] f))) = (lambda (package) (package x))
```

> 由此可得（[合一](https://en.wikipedia.org/wiki/Unification_\(computer_science\))），

> ```:scheme
(V[-1] f) = x
```

> 应用η-变换可得

> ```:scheme
V[-1] = (lambda (u) x)
```

> 观察`V[-1]`和`V0`可以发现，`V[-1]`实际上对应的是丘奇数的0，而`V0`对应的是丘奇数的1。也就是说，**通过`VALUE`的封装，实现了将丘奇数“左移”一位的目的，使之从丘奇数的“-1”开始迭代，并以丘奇数返回结果，从而实现前驱的效果。**即：

> ```:scheme
(n INC V[-1]) = V[n-1]
```

> 使用`EXTRACT`将得到的VALUE对应的丘奇数嵌套形式抽取出来，就得到了`PRED`函数的函数体。需要说明的是，由于`(EXTRACT V[-1]) = x`，因此`(PRED ZERO) = ZERO`是满足的。

> 最后将前面构造的`VALUE`（辅助函数，实际不需要）、`EXTRACT`、`INC`组合起来，即可得`PRED`函数：

> ```:scheme
(define TEN
  (lambda (f x) (f (f (f (f (f (f (f (f (f (f x))))))))))))

(define PRED
  (lambda (number)
    (lambda (f x)
      (define EXTRACT
        (lambda (value)
          (value (lambda (x) x))))
      (define INC
        (lambda (value)
          (lambda (package)
            (package (value f)))))
      (define V-1
        (lambda (u) x))
      (EXTRACT (number INC V-1)))))

((PRED TEN)
 (lambda (x) (+ x 1))
 0)
```

> 化简为：

> ```:scheme
(define PRED
  (lambda (number)
    (lambda (f x)
      ((number
        (lambda (value)
          (lambda (package)
            (package (value f))))
        (lambda (u) x))
       (lambda (x) x)))))
```

> 这就是最终得到的前驱函数。

有了减法，就可以比较大小。两个数`num1`和`num2`相减，若得到`@0`，说明**`num1`不比`num2`大**，或者说，`num1`小于等于`num2`。而`@0`是可以通过`IS_ZERO`判断的，所以就可以构造出谓词`IS_LE`，即“小于等于”。同样地，利用已有的逻辑运算，还可以构造出“大于等于”`IS_GE`、“等于”`IS_EQUAL`、“不等于”`IS_NOT_EQUAL`、“大于”`IS_GT`和“小于”`IS_LT`。

```:Scheme
(define IS_LE
  (lambda (num1 num2)
    (IS_ZERO (SUB num1 num2))))

(define IS_GE
  (lambda (num1 num2)
    (IS_ZERO (SUB num2 num1))))

(define IS_EQUAL
  (lambda (num1 num2)
    (AND (IS_LE num1 num2) (IS_LE num2 num1))))

(define IS_NOT_EQUAL
  (lambda (num1 num2)
    (NOT (IS_EQUAL num1 num2))))

(define IS_GT
  (lambda (num1 num2)
    (NOT (IS_LE num1 num2))))

(define IS_LT
  (lambda (num1 num2)
    (NOT (IS_GE num1 num2))))
```

对于自然数而言，反复做加法可以得到乘法运算；而反复做减法可以得到两种运算——除法和求余。除法是将一个数反复从另一个数上面减去，直到减不了为止，得到的结果是做减法的次数，这个次数称为“商”。而求余运算得到的是除不尽的那部分余数。除法记作`DIV`，求余记作`MOD`。（Scheme的求余函数是`remainder`）

两个数做除法，反复减掉的那个数是“除数”，越减越小的那个数是“被除数”。如果被除数比除数小，那么就没办法从被除数上减，所以减的次数就是0，也即“商”为0。反之，每多做一次减法，商就增加1，最后减到不能再减的时候，之前做过的减法的次数，就是最后得到的商。

根据上面的描述，可以利用前三章构造的基本运算写出`DIV`的定义：

```:Scheme
(define DIV
  (lambda (m n)
    (IF (NOT (IS_LE n m)) ;n>m
        @0
        (INC (DIV (SUB m n) n)))))
```

上面这段代码很好地“描述”了除法的原理，但它现在还不能帮助我们计算除法。为什么呢？

首先，`IF`的后两个参数代表两个分支，逻辑上是必须执行且只能执行一个的。但是，由于我们已经在第一章约定采用应用序求值，因此不论条件为何，两个分支都会被求值，这显然不是我们希望的结果。

为了延迟两个分支的求值，我们可以利用η-转换，将两个分支封装成λ函数，也就是将`(f a)`转换成`(lambda (x) ((f a) x))`。由于λ函数作为参数值的求值结果仍然是原来的形式，因此被封装为λ函数的分支，在求值`IF`的各个参数时，会作为一个整体，通过β-归约被扔进`IF`的函数体。这样，就将条件分支的执行推迟到了`IF`做出决定之后。

η-转换前后的两个λ项，符号形式不同、语法意义不同、抽象层次不同，但拆包后的执行效果是相同的，因此是“[外延等价](https://en.wikipedia.org/wiki/Extensionality)”的。

还有一点需要注意的是，尽管我们讨论的是“无类型”λ演算，但其实已经暗中标好了类型。比如说，接受两个参数的函数和接受一个参数的函数，显然不是同一类函数；返回值的类型不一致的两个函数，也不是同一类函数。例如，数字1`@1:(lambda (f a) (f a))`和逻辑假值`@false:(lambda (x y) y)`就不是同一类函数，因为`@1`返回的是函数调用`(f a)`，而`@false`返回的是变量`y`（指代的值），在形式上是不一致的。这种形式上的不统一，意味着他们不是“[内涵等价](https://en.wikipedia.org/wiki/Intension)”的，也就是说，他们不属于同一“类”（当然可以写出诸如`(@0 (lambda (x) x) 1)`和`(@true 1 2)`的表达式，它们的返回值是同一类型（都是“`1`”），但这反映的是执行结果的等价即“外延等价”，而不是“内涵等价”）。

考虑到这一点之后，η-转换就有了更多需要考虑的细节。例如，对于先前定义的`DIV`函数，分支`(INC (DIV (SUB m n) n))`的返回值类型是一个接受两个参数的丘奇数，因此，在做η-转换的时候，就必须相应地给它传入两个形式参数，才能保证“类型”上的正确性：

```:Scheme
(lambda (x y) (
  (INC (DIV (SUB m n) n)) x
                          y))
```

这样就可以保证η-转换后与转换前的输出都是同一“类型”，也即`DIV`返回的类型——丘奇数。改写后的`DIV`函数如下：

```:Scheme
(define DIV
  (lambda (m n)
    (IF (NOT (IS_LE n m)) ;n>m
        @0
        (lambda (x y) ((INC (DIV (SUB m n) n)) x y)))))
```

有了`DIV`的构造经验，`MOD`就不难了。依样画葫芦，很容易写出`MOD`函数如下：

```:Scheme
(define MOD
  (lambda (m n)
    (IF (OR (IS_ZERO m) (NOT (IS_LE n m))) ;m<=n
        m
        (lambda (x y) ((MOD (SUB m n) n) x y)))))
```

至此，在λ演算的基础上实现了自然数的全部四则运算，并且它们都是封闭于自然数内部的。

**线性列表**

[线性表](https://en.wikipedia.org/wiki/List_\(abstract_data_type\))可以这样递归描述：

- “空表”是线性表；
- 单个的“元素”是一个线性表；
- 在线性表的**前面**增加**一个**元素，得到的结构也是线性表。

如果写成BNF，就是：

```
<List> ::= <NullList>
<List> ::= <Element>
<List> ::= <Element> <List>
```

线性表有一个初始结构和四种基本的操作：

- NULL_LIST：空表
- CONS：在表的开头增加一个元素
- CAR：取表的第一个元素
- CDR：取表的第一个元素之后的子表
- NULLLIST?：判断是否空表

只要构造出这些“行为”，就相当于构造出了线性表。关于CAR和CDR的含义，可以参考[维基百科](https://en.wikipedia.org/wiki/CAR_and_CDR)。

首先，我们可以利用先前定义的有序对和`@true`，定义空表和其他操作。在下面的代码中，之所以使用`@true`定义空表，是因为这样比较方便定义谓词`NULLLIST?`。

```:Scheme
(define NULL_LIST
  (PAIR @true @true))

(define NULLLIST?
  (lambda (list)
    (LEFT list)))
```

以`PAIR`为基础构造，可以实现`CONS`、`CAR`和`CDR`三个基本操作。实现的思路是这样的：每一个`PAIR`，都是线性表中的一个枢纽，它的左侧是布尔值，如果为`@true`，意味着右侧的子表是空表；右侧是一个子`PAIR`，存储一个元素以及后面的表结构。图示如下：

![层层嵌套的二元组](./image/G2/church-list.png)

```:Scheme
(define CONS
  (lambda (e l)
    (PAIR @false (PAIR e l))))

(define CAR
  (lambda (list)
    (LEFT (RIGHT list))))

(define CDR
  (lambda (list)
    (RIGHT (RIGHT list))))
```

> 如果执行`(CAR @1)`或者`(CDR NULL_LIST)`会怎样呢？炸了。因此引入类型是非常自然的。目前暂不考虑。

有了这三个基本操作，就可以构造出一些实用函数了。

```:scheme
;;数组元素计数
(define COUNT
  (lambda (l)
    ((Y (lambda (f)
          (lambda (list)
            (IF (NOT (NULLLIST? list))
                (lambda (x y) ((INC (f (CDR list)))
                               x
                               y))
                @0))))
     l)))

;; 闭区间，注意Currying
(define RANGE
  (lambda (m n)
    (((Y (lambda (f)
          (lambda (a)
            (lambda (b)
            (IF (IS_LE a b)
                (lambda (z) ((CONS a ((f (INC a)) b))
                               z ))
                NULL_LIST
            )))))m)n)))

;; 投影函数：用于取出列表的第index个元素（从@0开始）
(define PROJ
  (lambda (list index)
    ((((Y (lambda (f)
            (lambda (l)
              (lambda (i)
                (lambda (j)
                  (IF (IS_EQUAL i j)
                      (CAR l)
                      (lambda (x y) ((((f (CDR l)) i) (INC j)) x y))
                   ))))))list)index)@0)))
```

利用λ演算的一等函数特性，我们可以将列表遍历操作抽象成高阶函数，而将具体的业务逻辑作为一等函数传入高阶函数。这样，我们就不需要每次都写麻烦的迭代代码了。常见的高阶函数有`MAP`、`FOLD`（`REDUCE`）等。

```:scheme
;高阶函数Fold和Map
(define FOLD
  (lambda (list init func)
    ((((Y (lambda (f)
          (lambda (l)
            (lambda (i)
              (lambda (g)
                (IF (NULLLIST? l)
                    i
                    (lambda (x y) (
                      (g (CAR l) (((f (CDR l)) i) g))
                      x y))
                ))))))list)init)func)))

(define MAP
  (lambda (list func)
    (((Y (lambda (f)
           (lambda (l)
             (lambda (g)
               (IF (NULLLIST? l)
                   NULL_LIST
                   (lambda (x) ((CONS (g (CAR l)) ((f (CDR l)) g)) x))
                )))))list)func)))
```

**二叉树**

树状结构也是一种无处不在的重要结构。鉴于多叉树都可以使用二叉树表示，因此这里我们只构造二叉树。二叉树也是一种可以递归定义的结构：

- 单个元素称为**节点**
- 不包含任何节点的**空树**是二叉树
- 每个节点都有至多两个子二叉树，分别称为左子树和右子树

与列表类似，我们需要构造下面这些基本操作：

- 空树：`NULL_TREE`
- 判断空树的谓词：`NULLTREE?`
- 取节点：`NODEOF`
- 取左子树：`LEFT_SUBTREE`
- 取右子树：`RIGHT_SUBTREE`
- 构造一棵树：`MAKE_TREE`

仍然以`PAIR`为基本单元，通过`PAIR`的嵌套和组合，就可以构造出来：

```:scheme
(define NULL_TREE
  (PAIR @true @true))

(define NULLLIST?
  (lambda (bt)
    (LEFT bt)))

(define NODEOF
  (lambda (bt)
    (LEFT (RIGHT bt))))

(define LEFT_SUBTREE
  (lambda (bt)
    (LEFT (RIGHT (RIGHT bt)))))

(define RIGHT_SUBTREE
  (lambda (bt)
    (RIGHT (RIGHT (RIGHT bt)))))

(define MAKE_TREE
  (lambda (e left right)
    (PAIR @false (PAIR e (PAIR left right)))))
```

这里可以发现，空树和空表的构造是一致的；整个树状结构的构造，跟线性表的构造也有很大的相似性。因此，完全可以说，线性表可以看成是一棵极度不平衡的二叉树。

事实上，我们完全可以采用另一种方式来实现上面几个基本操作。尽管实现方式不同，但是从效果上来说，两种实现是等效的。因此，我们可以说，上面定义的几种操作，构成了对二叉树这一通用结构的接口定义。我们通过约定接口的方式，将二叉树封装进一套功能明确的接口定义中。这样，即便接口的内部实现有变化，只要接口功能不发生变化，外面的用户就不会感觉到变化。将这种思想丰富起来，便产生了对象与类、原型链等花样百出的数据封装手段。

## Y组合子

上文描述的λ演算，除了`lambda`和`define`没有任何其他的“保留字”。然而，λ演算实际上并没有`define`机制，所有的函数都是匿名的。表面上看，这引发一个问题：如果不允许给函数命名，就无法通过名字实现自我引用，也就无法实现递归了。一门无法实现递归的形式语言，它的价值是要大打折扣的。幸运的是，Haskell Brooks Curry 发现了一个神奇的构造，被称为**Y不动点组合子**，其形式如下（请允许我最后一次使用`define`，因为有了Y组合子，我们就再也不需要`define`了）：

```:Scheme
(define Y
  (lambda (S)
    ( (lambda (x) (S (x x)))
      (lambda (x) (S (x x))))))
```

它的神奇之处在于，将任意一个函数`F`传入Y组合子，都有：

```:Scheme
(Y F) => ( (lambda (x) (F (x x)))
           (lambda (x) (F (x x))) )
      => (F ( (lambda (x) (S (x x)))
              (lambda (x) (S (x x))) ))
      即 (F (Y F))
```

可以发现，左边的`(Y F)`和右边的`(Y F)`是同一个`(Y F)`，`(Y F)`的结果是给它自己又调用了一次`F`。这意味着，`(Y F)`就是我们寻找的能够实现自调用的递归函数，也是`F`的不动点。什么是不动点呢？在计算器上随便输入一个数字，反复按“cos”键，得到的结果一定会收敛到某个确定的值（弧度制下是0.739...）。这个值就是$\mathrm{cos}(x)$的不动点，也就是$\mathrm{cos}(x) = x$的根。

![余弦函数的不动点](./image/G2/cos_fixed_point.jpg)

然而，在Scheme的应用序求值策略下，Y组合子实际上是不“收敛”的。由于`(x x)`的存在，代换的过程会无穷无尽地继续下去。为了解决这个问题，我们可以使用以往的经验，即将`(x x)`封装成`(lambda (y) ((x x) y)`，从而延迟对它的求值。注意到这种封装只适用于单参函数，这就是说，不论目标递归函数有几个参数，最好是经过柯里化，转换成单参函数。这在一定程度上牺牲了简洁性，却换来了通用性。这个经η-变换，将自调用部分`(x x)`封装起来的Y组合子，称为**Z组合子**，它是Y组合子在应用序求值策略下的实现。有了Z组合子，我们就可以写出可执行的、纯粹的λ演算版本的阶乘函数了：

```:Scheme
((lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y))))))
 (lambda (f)
     (lambda (n)
       (IF (IS_EQUAL n @0)
           @1
           (lambda (x y) ((MUL n (f (DEC n)))
                          x
                          y))))))
```

Y组合子的存在，意味着λ演算可以实现递归，进而其计算能力与递归函数和图灵机是等价的。这同时意味着对于λ演算而言，函数是否匿名是无关紧要的。因此，为了使用上的方便，各种编程语言都引入了类似`define`的语法。可见，`define`的本质是一块甜甜哒语法糖，既然如此，我们还是继续给函数起名字好了。

> Scheme提供了多种变量定义的机制，如`let`、`let*`和`letrec`。这些机制有非常微妙的区别，但是它们的本质都是将局部作用域的外面包裹了一层，形成了新的“高阶函数”。例如，下面的`let`形式建立了一个局部变量`C`：

> ```:lisp
(lambda (x)
  (let ((C 100))
       (+ x C)))
```

> 它跟下面这种普通的λ表达式的执行效果是相同的：

> ```:lisp
(lambda (x)
  ((lambda (C)
     (+ x C)) 100))
```

> JavaScript是一款Scheme血统非常明显的语言。在JavaScript中，可以用`var`关键字来声明变量。`var`有所谓“变量提升”的特性，也就是，在一个函数作用域中，只要出现了`var`声明，那么被声明的变量在整个作用域内部都是有效的。这种特性的原因显然是继承了Scheme的`let`的特性。

# 第五章：证明的限度

2018-07-10依据内格尔的《哥德尔证明》撰写基本内容。2023-09深入学习数理逻辑教材，大量扩充本章内容。

2023年9月～10月，集中兴趣学习了哥德尔第一不完全性定理的证明过程，这个过程是一切现代数理逻辑问题的集大成者，在游历这个证明的过程中，将完整领略到数理逻辑四大论——集合论、模型论、递归论、证明论——的全部基本概念，因而是一个绝佳的数理逻辑观光目的地。

对于大部分一般通过的群众来说，哥德尔证明最核心的干货就在于那个“我不可证”的自指句，而这个自指句可以溯源到20世纪初的罗素悖论，甚至更早。知道这个就足够了。但是我显然不满足于此。

学习哥德尔证明的过程中，除了证明本身给人极度的审美体验之外，数理逻辑史上的大佬和奇闻逸事，也是非常有趣的。例如我们计算机科学的祖师爷冯·诺依曼，在哥德尔发表他的第一不完全性定理之后不久，就立刻领悟到第二不完全性定理。当时哥德尔还是个刚刚拿到博士学位不久的小沙弥，宣布定理的会上，只有极少数与会者立刻认识到了定理的价值，而诺依曼是其中一个。凡此种种，都相当有趣。

------

2023-09-12

近期深入阅读数理逻辑文献，试图更进一步理解哥德尔第一第二不完备定理的证明思路。几年前读过内格尔的《哥德尔证明》，掌握了证明思路的总体框架，但是对于其中极其精巧的细节，仍然不了解。

例如，哥德尔极为巧妙地证明了原始递归函数在算术语言中的可表示性，同时避开了循环论证的陷阱。在此基础上，借助极为巧妙的哥德尔编码技巧，将算术语言的元语言论述“绕进”算术语言内部，使得算术语言能够谈论自身内部公式的可证性。这意味着算术语言内部能够“能行地”构造出那个极为巧妙的“我不可证”悖论句子。在整个证明过程中，元语言与算术语言运行在不同的层面，不仅避免了循环论证，更提供了“可证性与真理性分离”的真知灼见。简而言之，哥德尔在算术语言中能行地构造出“我不可证”悖论句子，这个句子在语言内部形式不可证，但却是在元语言层面为“真”的算术真命题。这意味着一致的算术理论是不完备的，在希尔伯特发出“我们必须知道，我们必将知道”的豪迈宣言的前夕，宣告了数学形式主义的失败（至少是重大挫折）。

最近以《哥德尔证明》为辅助，深入阅读郝兆宽、杨睿之、杨跃等著作的《数理逻辑：证明及其限度》《递归论：算法与随机性基础》等文献，与余俊伟、汪芳庭等学者的其他数理逻辑教材比较阅读，并进一步阅读王浩的《哥德尔》等文献，试图逐步理解哥德尔证明的全貌、细节、历史背景和哲学意义。

维特根斯坦《逻辑哲学论》中命题6.54说到：登上高处后，必须把梯子扔掉。必须超越这些命题，然后才会正确看待世界。 《哥德尔证明》对我来说就是这部梯子。虽说要“扔掉”梯子，但我理解应当是“扬弃”。《哥德尔证明》能够将这个数理逻辑史上最伟大的证明浓缩在一百来页的小册子里，并且让我这样的票友得以一窥这座思维大厦的全貌，是十分了不起的。

我作为无线电爱好者，一方面关心世界的硬件，即物质世界的运行规律，另一方面也关注世界的软件，即思维和逻辑的结构和意义。人类对于“软件”这部分的信念，至今仍有重大的分歧，而哥德尔的成果，是秉持各种观点的各方都绝不可忽视的思想灯塔。诚如侯世达在《哥德尔证明》中文版序言中所说：学习哥德尔的证明，是驶向数学的核心、数学思想的核心、思想本身的核心、人类心灵的核心。我觉得作为一个有好奇心的人类个体，应该把这颗思维的宝石重新擦拭干净，使之在未来继续绽放“令人感到幸福”的光芒。

------

2023-10-09

我很想知道诸君在近期热点问题（如巴以冲突）上选择立场的依据是什么。就我个人而言是完全没有依据的，也没有立场，我的立场就是作壁上观。

就好比我最近一直在学习哥德尔不完全性定理的完整证明过程，虽然很多教材都给出了证明，但都在不同的地方有或多或少的跳步。为了补全这些跳步，给我自己一个交代，只得同时阅读四五本教材，像拼图一样拼凑出一个完整的、令我自已信服的证明全貌。

现代的数理逻辑教材，对于哥德尔不完全性定理的证明过程，比起1931年哥德尔原版论文中的证明过程，有了很大进步。除了内容实质上更加充实、概念工具更加有力之外，在证明过程的组织形式上，新教材如同软件重构一般，把原版论文中的面条代码梳理成模块化的代码，更容易理解。但是，显然，这并未降低哥德尔定理证明本身的复杂度，无论采用什么讲述方式，必要的前置知识都是不可或缺的。而这正是我绕过基础知识，直接着手学习哥德尔不完全定理的原因所在一一带着问题学，急用先学，这在玩票的意义上更高效。

## 引言：我们必须知道，我们必将知道

Wir müssen wissen, wir werden wissen.

在数学的发展历史中，曾经有过三次大的数学危机，直接动摇了数学的根本。这三次数学危机，都绕不开一个神秘的概念：无穷。

表观来看，数学有两大任务：计算和证明。漫长的数学史，某种意义上就是算术逻辑化和逻辑代数化的发展史。

古希腊人信奉万事万物都是整数和整数的比，毕达哥拉斯（570BC～495BC）学派是他们中的集大成者。然而，毕达哥拉斯的一位弟子发现：等腰三角形的长边长（例如$ \sqrt 2$），并不能表示为整数之比。这与毕达哥拉斯学派的信条不合，为了掩盖这件事，此人不幸被扔进大海。这件事引发了第一次数学危机。人们逐渐领悟到，在几何学中，算术和直觉是不可靠的，只有逻辑才是可靠的。

此后，古希腊的逻辑学开始蓬勃发展。亚里士多德（384BC～322BC）集古希腊思想之大成，提出了公理化方法以及著名的三段论，对后世影响极为深远。后来欧几里得（325BC～265BC）在《几何原本》中提出公理化几何学，成为公理化方法最早的典范。欧几里得的几何学（欧氏几何）以有限的几个公理（公设）出发，通过简单的推理规则，可以推导出古典几何学的整座大厦。牛顿的名著《自然哲学的数学原理》采用《几何原本》的体例，建立了公理化的经典物理学。

尽管欧氏几何的大厦宏伟壮丽、浑然一体，然而，人们注意到，在欧氏几何的公理中，唯独平行公理过于繁琐，不像是显而易见的公理。人们花了两千年的时间，试图在欧氏几何中证明平行公理，直到十九世纪，其作为公理的独立性才被证明。这个问题催生了非欧几何，即不承认平行公理的几何学。同时，也带给人们两个重要的启示：

- 再次确认，几何学中，合乎空间直观并不重要，重要的是逻辑上的无矛盾性。这启发后来者，也许可以抽离掉一切依赖于直观的“解释”，将几何学（乃至一切数学甚至一切学问）建立在纯粹逻辑之上，成为完全公理化的体系。
- “无法证明某个真命题”是可以被证明的。这启发人们，似乎可以站在某个推理系统之外，去研究系统内部的性质。

从亚里士多德开始的数学公理化历程，整体上是一条从“计算”走向“推理”的路。然而，十七世纪的德国学者莱布尼茨（1646~1716），正是出于对亚里士多德哲学的深刻理解，反其道而行之，选择了一条从“推理”走向“计算”的路，试图发明一套“通用符号”系统，将逻辑推理转化成机械严谨的符号计算，从而将一切人类思维建立在机器运算的基础上。他的名言是：“让我们来算算吧！”除此之外，他还意识到了二进制与整数和他理想中的计算机器的关系，这种想法是大大超前于时代的。他不仅想了，而且做了。1673年，莱布尼茨在伦敦展示了一台能够进行加减乘除四则运算的[计算机模型](https://en.wikipedia.org/wiki/Stepped_reckoner)，他借此当选为伦敦皇家学会会员。

![莱布尼茨的 Stepped reckoner](https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Leibnitzrechenmaschine.jpg/340px-Leibnitzrechenmaschine.jpg)

此外，法国数学家笛卡尔（1596～1650）和费马（1601～1665）各自独立发明了解析几何——即采用计算的方法去研究几何问题。解析几何规避了几何证明对于技巧和创造性的极高要求，将几何证明转化为按部就班的机械的计算。这与逻辑推理的机械化可以说是殊途同归。很难说哥德尔在证明不完全性定理时所使用的编码方法，没有受到他们的启发。

然而，这条路比人们想象得要艰险许多。历史表明，这条路之所以如此艰险，是因为在从“推理”走向“计算”的漫长路途中，处处可见神秘而令人绝望的“无穷”。早先的哲学家向来是敬无穷而远之。然而，在通向莱布尼茨之梦的险途中，时常会与无穷狭路相逢。狭路相逢勇者胜：莱布尼茨和牛顿首先利用“无穷小量”概念构建起微积分理论，康托尔勇敢地开辟了直面实无穷的集合论……今天的我们将微积分和集合论视为理所当然，然而大约一百多年前，人们对此却疑窦丛生、争议不休（实际上直至今日，不少人都很难接受高等数学中极限的概念；他们或许能够很熟练地解题，并将其作为一门语言或者一种工具去熟练运用，但是很难说他们真正**认同**那些有关无穷小、无穷大、无限逼近一类的概念）。正是如此，这个时期才会被逻辑史学家称为数理逻辑的黄金时代。

在讲述有关无穷的争议之前，必须要提到布尔和弗雷格两位先驱。英国学者布尔（1815～1864），提出了著名的布尔代数，将逻辑的推理变为代数的演算。如果将布尔代数解释为对命题的演算，就得到了命题逻辑演算。布尔代数第一次将亚里士多德的逻辑推理纳入代数运算之中，形成了“逻辑代数”的概念，向莱布尼茨之梦迈出了重要一步。然而，布尔代数基于亚里士多德以来的逻辑成果，只能处理命题粒度上的演算，而无法处理诸如“所有”、“存在”这样的量词，也无法处理个体的关系和性质（即“谓词”）。1879年，德国哲学家弗雷格（1848～1925）在《概念文字》一书中提出了一阶谓词演算，第一次将量词引入逻辑，第一次将谓词处理为函项，从根本上改变了逻辑的形态。因而蒯因（1908～2000）说“逻辑学……自1879年（《概念文字》出版）后成为一门伟大的学科”。

作为后来人，我们知道，弗雷格的一阶逻辑对于“普通”的数学来说已经完全够用了。弗雷格被视为现代数理逻辑的创始人，他试图从纯粹逻辑的概念出发，定义出全部数学，从而使数学成为逻辑的一个分支。这一纲领被称为逻辑主义。然而，弗雷格构筑了近20年的逻辑主义大厦《算术的基本规律》第二卷付印在即之时，他遭遇了一个足以毁掉他毕生心血的打击。1902年6月，弗雷格收到罗素（1872～1970）寄来的一封信，这封信的内容便是如今被称为“罗素悖论”的著名悖论，它直接摧毁了《算术的基本规律》的逻辑根基。由于即将付梓，弗雷格只能在书末匆匆添加了一个附录，坦诚承认自己的困境。正如弗雷格在附录中所说：“正当工作就要完成之时，发现大厦的基础已经动摇。对于一个科学家来说，没有什么比这更不幸了。伯特兰·罗素的一封信，使我陷入这样的境地。”

1962年，罗素对弗雷格作出了极高的评价：“据我所知，没有人在对真理的执着上比得上弗雷格。他…在发现自己的基本假设出错时，在他的回应中，闻道的愉悦明显盖过了个人的失望。这几乎是超人的。它鲜明地显示出当人们把执着用于创造性的工作和知识，而非虚名和权势时，他们所能达到的境界。”

为了继续弗雷格未竟的事业，消除悖论，将数学建立在严格的逻辑基础上，罗素试图通过给集合乃至一切语言进行“分层”，以破解自指带来的困惑。他多年的努力和心血，凝聚在一部三卷本的巨著中，这本巨著就是著名的《数学原理》（Principia Mathematica）。《数学原理》充满了晦涩难懂的符号推理，真正读完这部书的人寥寥无几。然而，在哲学事业的命运方面，罗素同样遭遇了与弗雷格相似的不幸——其理论大厦都被寥寥无几的读者中的某一位所颠覆——弗雷格遭到罗素悖论的颠覆，而罗素遭到哥德尔（1906～1978）的不完全性定理的颠覆。这不幸的“轮回”基本葬送了逻辑主义——或者说起码葬送了弗雷格和罗素最初设想的逻辑主义。

![是时候展示真正的逻♂辑了<br>引自维基百科](https://upload.wikimedia.org/wikipedia/commons/d/d7/Principia_Mathematica_54-43.png)

算术逻辑化：皮亚诺、康托尔、布劳威尔、希尔伯特

希尔伯特开了一家旅馆，这个旅馆有可数无穷多个房间，换言之，希尔伯特旅馆的房间数，和自然数的数量一样多。这天，希尔伯特旅馆来了一个客人，但是很不巧，旅馆已经客满了。正当客人一筹莫展之际，希尔伯特说，别担心，咱们的旅馆有无穷多个房间，我只需要让每个客人都住到他们各自房间号的下一个房间，然后你住在第一个房间就可以了。客人成功入住。某一天又是客满，此时来了可数无穷多个客人，要求入住。希尔伯特考虑了一下，说，已入住的客人都换到房号乘以2的房间去，这样新来的每个客人就都有房间住了。所有客人成功入住，大家很满意。

对角线证明法是康托尔提出的用来证明$(0,1)$不可数的一种巧妙的方法。所谓“可数”，指的是集合中的每个元素都可以与自然数建立一一对应的双射关系。假设$(0,1)$可数，那么存在函数$f(i),i\in \mathbb N$与集合中**每一个数**相一一对应。将$(0,1)$内的每一个数都写成十进制的无限小数（有限小数在末尾添加无穷个0，不允许以999...结尾的数字），每个数写一行。以小数的序号为行数，小数的位序号（从0开始）为列数，列出下表：

| |0|1|2|3|4|5|...|
|-----------------|
|0|?| | | | | |...|
|1| |?| | | | |...|
|2| | |?| | | |...|
|3| | | |?| | |...|
|4| | | | |?| |...|
|5| | | | | |?|...|
|...| | | | | ||...|

设$(0,1)$内的某个数$r$的每一位$i$都与$f(i)$的第$i$位（也就是上表对角线上的问号）不等（例如加一，9+1=0），这样$r$仍然是$(0,1)$内的实数，但是与表中每一个$f(i)$都不相等。也就是说，构造出了不在上表中的，然而却真实存在的$(0,1)$内的实数。但根据假设，$f(i)$可以对应所有的实数，这就引起了矛盾。最终得到结论：$(0,1)$不可数。

逻辑代数化之路的艰险，暗示着所谓的“逻辑”很有可能从一开始就是靠不住的。这时，前面提到的非欧几何的第二点启示，也就是研究逻辑体系内在性质的问题，给了人们低头看路的超然视角：也许我们可以停下匆匆前进的脚步，认真地思索我们脚下的这条通往终极真理之路——1930年，哥德尔证明，这条路注定不是人们理想中的完美之路。令人惊叹的是，哥德尔的证明，正是利用了逻辑代数化的最前沿创造——哥德尔编码。“推理”和“计算”，在哥德尔的证明中实现了完美的统一。两条互为逆向的通向真理之路，在哥德尔的证明中竟然结成了美妙而令人遗憾的环路。在数学形式主义的希尔伯特纲领被彻底否定之后，人们不再执着于一劳永逸地为数学构建完美的逻辑基础，而是脚踏实地地创造了一个更加精彩、更加可爱的全新时代——信息时代。哥德尔的工作非但没有否定人类利用理性力量理解自身理性的可能性，而是鼓舞着一代又一代人，穷尽一切创造性的手段，去实现莱布尼茨的梦想。最近十年有关信息技术和人工智能的成就，以一种前人始料未及的方式，回应了“我们必须知道，我们必将知道”的宣言。

我们何其幸运，既可以享受信息时代的便利，又可以站在历史长河的下游，尽情回顾这波澜壮阔的一切。

本节参考文献：

- 卢昌海. [弗雷格的算术](https://www.changhai.org/articles/science/misc/bookstories/Frege.php)[OL]. 2016.

![逻辑代数化和算术逻辑化，双轨并行](./image/G2/architecture.png)

哥德尔第一不完全性定理的证明思路是：首先证明所有的递归（可计算）关系都是可表示的；然后证明算术语言语法的算术化是可计算的，进而是可表示的；而后在此基础上证明不动点引理，从而基于可表示的“证明”概念构造出表达“我不可证”的内部公式，导致悖论，最终推出哥德尔第一不完全性定理。

## 证明梗概

哥德尔对不完全性定理的证明，简单通俗地讲，就是通过构造一个不可证但却为真的命题$G$，来否定一致的算术系统的完全性。$G$的内容是：“本命题在算术系统内不可证。”如果$G$可证的话，则与其所说不符，导致悖论；但如果$G$不可证，恰好契合了$G$所表达的意思，从而得到“算术理论中存在不可证的真命题”的结论。

然而，如此这种简明通俗的表述，并未反映出哥德尔证明中最微妙的思想，也即元语言和对象语言之间相互映射的思想。确切地说，哥德尔的证明，用了大量的篇幅，使得读者相信算术语言（对象语言）能够忠实地描述自身的特征（元语言），以避免诸如理查德悖论的佯谬。

因此，在构造$G$之前，首先要做到两件事情：

- **符号形式**的能行转换：将元数学关于“可证性”的陈述，能行地表达为算术语言内部的合式公式。
- **语义解释**的可靠对应：保证算术语言内部的公式可以解释为正确的元数学陈述。

如果能够做到这两点，并在算术语言中构造出$G$，则意味着找到了沟通算术语言与元语言的途径，从而使得算术系统具备了自省的能力。这样，就可以利用算术语言谈论其自身，从而避免犯下理查德悖论那样的错误。

![元数学映射机制](./image/G2/meta-map.png)

简单来说，算术语言自省，是通过**哥德尔编码**和**对应引理**实现的。

哥德尔编码可以将算术语言公式转化为自然数编码。这样，对于这个自然数编码的算术性质的论述，便等同于对算术语言公式的论述，即元数学论述。而算术性质的论述又是可以被表示为算术语言公式的，进而又可以被编码为自然数……这就形成了元语言和算术语言之间的对应。

有了自省机制，即可在算术语言内部构造自指句，来证实不可判定真命题的存在。

首先，在算术系统中构造公式$G$，其元数学意义为“本公式在算术系统内不可证”。

然后证明：若算术系统一致，则$G$不可证（不可判定，即既不可证明，也不可证否）。过程如下：

+ 证明：$G$可证，当且仅当$\neg G$可证。
+ 由一致性：$G$和$\neg G$至少有一个不可证。
+ 因此：如果系统一致，则$G$正反均不可证，也就是“不可判定”。

公式$G$对应的元数学命题“我不可证”，在上一步的元数学论证中被证明为真，因而可以确认，算术语句$G$是真命题。

因此，算术理论中存在①不可证的②真命题。也就是说，算术理论是不完全的。

进一步地，如果将$G$加入公理集合，则总可以构造出类似的$G'$。因此，算术理论是强不完全的。

**第一步：构造自我指涉的PM命题$G$**

构造PM内部公式$G$，对应元数学命题“$G$在PM中不可证”，即“$G$不是PM的定理”。换句话说，“哥德尔数为$g$的公式不是定理”。

首先，构造含有一个自由变元$\sigma$的公式$\gamma(\sigma) := \neg (\exists x)\mathsf{Dem}(x, \mathsf{Sub}(\sigma, 17, \sigma))$，其中$\sigma$可以替换成其他合式PM公式，因而$\gamma$的哥德尔数由$\sigma$决定。

哥德尔证明，存在某个$\sigma_0$，使得$\gamma(\sigma_0)$的哥德尔数的数码，恰好等于$\sigma_0$。那么，如果将$\gamma(\sigma_0)$记为$\Gamma$，则其哥德尔数的数码$\lceil \Gamma \rceil$就是$\sigma_0$，相应地，语句$\Gamma$就是

$$ \Gamma := \neg (\exists x)\mathsf{Dem}(x, \mathsf{Sub}(\lceil \Gamma \rceil, 17, \lceil \Gamma \rceil)) $$

因为$\lceil \Gamma \rceil$是自己所在语句$\Gamma$的哥德尔数的数码，因此可以说，$\Gamma$通过哥德尔数进行了**自我指涉**。

依据对应引理，算术理论内部的公式$\Gamma$的元数学意义是：“哥德尔数为$sub(\sharp \Gamma, 17, \sharp \Gamma)$的PM公式是PM内不可证的。”这个元数学意义，恰好是我们最初打算构造的PM公式$G$，所表达的元数学意义。

也就是说，**PM公式$\Gamma := \neg (\exists x)\mathsf{Dem}(x, \mathsf{Sub}(\lceil \Gamma \rceil, 17, \lceil \Gamma \rceil))$就是我们所需要的$G$。**

PM公式$G$的哥德尔数$g=n$恰好是PM公式$G$对应的数论命题$～(∃x)dem(x, sub(N, 17, N))$的一部分！也就是说，构造了这样的一个对应的元数学诠释：“‘哥德尔数为$g$的公式是不可证的’这个公式是不可证的。”

总之，的确可以构造出PM公式G，它说它自己不是PM的定理。

**第二步：$G$在一致的PM系统中是不可判定的**

- 可以证明：“$G$是可证的，当且仅当$～G$是可证的”。<sup>[注]</sup>
- 如果PM系统内部可以证明两个互相矛盾的命题，说明PM是不一致的。也就是说，若PM是一致的，则$G$和$～G$至少有一个不可证。
- 结合上面两点，$G$和$～G$都不可证。
- 因而，**若PM一致，则必然存在一个公式$G$，使得$G$和$～G$都不可证，即“形式上不可判定”**

> 注：哥德尔证明的是：若$G$可证，则$～G$可证（意味着PM不一致）；而若$～G$可证，则PM是ω-不一致的。

> 所谓的ω-不一致指的是：现有形式系统$C$，若其公式$(\exists x)P(x)$和无穷多个公式$～P(0)$、$～P(s0)$、$～P(ss0)$、……都是可证的，则$C$是ω-不一致的。

**第三步：$G$是元数学层面上的“真理”**

- 哥德尔说明，尽管$G$是PM不可判定的，但$G$在元数学意义/算术意义上是真的。
- 因为$G$的元数学意义是“某个命题自身是PM不可证的”，其算术意义是“并不存在一个数，满足这个数自身对应的某种性质”。
- 而我们刚刚（第二步）就**在元数学层面上**，证明了“$G$是PM不可判定的”**也即$G$本身所言说的**。
- 第二步的对$G$的不可判定性的元数学证明，实际上构成了对$G$的元数学真理性的证明。
- 综上，$G$在元数学层面上是真的。

**第四步：由于$G$的存在，PM是不完全的**

- “不完全”的意思是：存在系统内部不可形式判定的真命题。
- 在一致的前提下，存在PM命题$G$（第一步），它既是不可判定的（第二步），又是“真的”（第三步），所以PM必然是不完全的。

**第五步：给理论打补丁**

- 如果把刚刚找到的$G$作为公理，给PM打补丁呢？
- 然而，即便在PM中添加新的公理，使PM更强，但按照上面的套路，
- 总可以类似地找到另外一个$G'$，它是在“增强PM系统”中不可判定的真命题。
- 无论如何增强这个系统，都无法逃脱这个本质上的限制。

至此，得到了著名的哥德尔第一不完全性定理：PM系统是不完全的。

## 语言、模型、理论

哥德尔不完全性定理的靶子是：算术结构(模型)诠释的算术语言表达的算术理论。而“算术”就是对于直观自然数概念的公理化形式化，这一公理化方式本身也是“算术的”，被称为递归可公理化。因而哥德尔不完全性定理与其说反映了（哪怕是大众对它的常见误解，即）数学并非万能的观点，不如说反映了自然数（而不是“数学”“逻辑”或者其他的什么泛泛而谈的东西）这个“概念”自身的某些并不神秘的性质。这个性质大概可以仿照那个有趣的meme（大脑悖论）表述为：**自然数过于复杂，复杂到它无法理解自己**。但是，这并不妨碍我们人类心智用自然数以外的东西去理解它。

一阶算术语言：

$$ \mathscr{L}_{1} = \{ \mathsf{0}, \mathsf{S}, \mathsf{+}, \mathsf{×} \} $$

- 无衬线字体的符号，表示算术语言内部的符号；而常规的有衬线字体符号，表示元语言符号。

标准算术模型：$\mathfrak{N} = ( \mathbb{N} , 0 , S , + , × )$

作为典型案例的一个非标准算术模型：$\mathfrak{M} = (\mathbb{N} \cup \{\infty\}, 0 , S , + , ×)$，其中S、+、×由$\mathbb{N}$上的S、+、×按如下方式扩展到∞：

- $S(\infty) = \infty$
- 任给$n \in \mathbb{N}$都有 n + ∞ = ∞ + n = ∞ + ∞ = ∞
- 0 × ∞ = ∞ × 0 = 0 且任给$n \not = 0$都有 n × ∞ = ∞ × n = ∞ × ∞ = ∞

Robinson算术理论$\mathsf{Q}$，是由以下7条公理生成的一阶理论：

- (Q1) $\forall x (\mathsf{S} x \not \approx \mathsf{0})$
- (Q2) $\forall x \forall y (\mathsf{S} x \approx \mathsf{S} y \to x \approx y)$
- (Q3) $\forall x (x \not \approx \mathsf{0} \to \exists y (x \approx \mathsf{S} y))$
- (Q4) $\forall x (x + \mathsf{0} \approx x)$
- (Q5) $\forall x \forall y (x + \mathsf{S} y \approx \mathsf{S}(x + y))$
- (Q6) $\forall x (x × \mathsf{0} \approx \mathsf{0})$
- (Q7) $\forall x \forall y (x × \mathsf{S} y \approx x × y + x)$

说明：

- $\mathsf{Q}$中没有归纳法，但是(Q3)是归纳法的一个特例。
- 除了标准算术模型$\mathfrak{N}$，$\mathsf{Q}$还可以有其他模型，例如上文给出的非标准算术模型$\mathfrak{M}$。
- $\mathsf{Q}$是个很弱的理论，因为很多算术事实无法在$\mathsf{Q}$中证明。例如引理9.1.2。
- $\mathsf{Q}$定义在一阶公理系统之上，因此在证明$\mathsf{Q} \vdash \sigma$形式的命题时，可以使用一阶算术公理系统的公理和分离规则。

**引理9.1.2**（余5.3.4）

+ $\mathsf{Q} \not \vdash \forall x \mathsf{S} x \not \approx x$
+ 对每一个标准自然数$n \in \mathbb{N}$，$\mathsf{Q} \vdash \mathsf{S} \mathsf{n} \approx \mathsf{n}$，其中$\mathsf{n} := \mathsf{S}^{n} \mathsf{0}$。

说明：

- $\mathsf{n} := \mathsf{S}^{n} \mathsf{0}$称为自然数$n$的**数码**。数码是沟通自然数（元语言）与对象语言内部的桥梁。
- 考虑非标准算术模型$\mathfrak{M}$，可见断言1是显然的。而断言2可以在自然数上作归纳得到。（参考GEB第293页，所谓“超自然数”）
- 断言2的归纳证明是逐点的，而断言1是一致的（统一的，uniform）。
- 断言2的证明运用了归纳法，这是$\mathsf{Q}$外部的元语言证明。$\mathsf{Q}$中没有归纳法。

**定义9.1.3** 将$x \le y$定义为$\exists z (z + x \approx y)$，并且用$x < y$表示$x \le y \land x \not \approx y$。

**引理9.1.4**（余5.3.7） 内容略。

说明：

- 根据(7)，如果$b \in \mathfrak{N}$，且$a \le ^{\mathfrak{M}} b$，则$a \in \mathfrak{N}$。这意味着非标准模型$\mathfrak{M}$引入的所有新元素，都缀在$\mathfrak{N}$的“后面”，这一现象称为$\mathfrak{M}$是$\mathfrak{N}$的尾节扩张。
- 作为算术理论的模型，算术结构的内在是有特定“结构”的（这里带了引号的“结构”是指它并不是数理逻辑术语，而应作一般的理解），算术结构的论域，即自然数集合及其扩展集合，并不是一锅混乱的“自然数之汤”，而是有着特定内部结构（正如引理9.1.4所述）的“自然数晶体”。这种规则的“结构”是哥德尔定理以及Rosser加强的定理的根本依据。更具体地说，算术内部有序的“结构”及其引发的“尾节扩张”现象，使得Rosser运用有界量词对哥德尔的第一不完全定理作加强的技巧成为可能。

**公式谱系和$\Sigma_1$完全性**

- 称算术语言中的公式为$\Delta_0$的，如果它只包含有界量词。
- 称形如$\exists x_1 ... \exists x_n \theta$的公式是$\Sigma_1$的，其中$\theta$是$\Delta_0$的。

## 可表示性

令$T$是一个包含$\mathsf{Q}$的理论。以下如果不加说明，则隐含地假定理论$T$为$\mathsf{Q}$。

**定义9.1.5 (关系可表示性)** 称自然数上的k元关系$P$为在$T$中**数码逐点可表示的**（numeral-wise representable），简称为**可表示的**，如果存在算术语言公式$\rho(\pmb{x})$（称为关系$P$的一个**表示公式**），使得：

$$
\begin{align}
(n_1, n_2, ... , n_k) \in P &\Rightarrow T \vdash \rho (\mathsf{n}_1 , \mathsf{n}_2 , ... , \mathsf{n}_k) 且 \\\\
(n_1, n_2, ... , n_k) \not \in P &\Rightarrow T \vdash \neg \rho (\mathsf{n}_1 , \mathsf{n}_2 , ... , \mathsf{n}_k)
\end{align}
$$

**引理9.1.7** 可表示性的一些简单性质：

- 如果$P$是可表示的，则$P$是递归的。
- 可表示的关系对布尔运算封闭。
- 如果
- $P$

**定理9.1.8 (可证与真的关系，$\mathsf{Q}$的$\Sigma_1$-完全性)** 对任何$\Sigma_1$-语句$\tau$，有$\mathfrak{N} \models \tau$当且仅当$\mathsf{Q} \vdash \tau$。

**定义9.1.10 (函数可表示性)** 称函数$f : \mathbb{N}^k \mapsto \mathbb{N}$是**可（在算术语言中）表示的**，如果存在算术语言语句$\phi (x_1 , x_2 , ... , x_k, y)$，使得对于所有的$(n_1, ... , n_k) \in \mathbb{N}^k$，都有$T \vdash \sigma$，则称$\phi$作为一个函数（在算术语言中）表示$f$。其中算术语言语句$\sigma := $

$$ \forall y ( \phi (\mathsf{n}_1 , \mathsf{n}_2 , ... , \mathsf{n}_k, y) \leftrightarrow y \approx \mathsf{f}(\mathsf{n}_1 , \mathsf{n}_2 , ... , \mathsf{n}_k) ) $$

以下证明所有的递归函数都是可表示的。

**引理9.1.12 (初始函数可表示)** 算术语言中的项所诱导出的k元函数是可表示的。特别地，后继函数、常数函数、加法、乘法、投影函数都是可表示的。

**定理9.1.13 (复合函数可表示)** 可表示函数类对函数的复合运算封闭。

**定理9.1.16 (极小化可表示)** 可表示函数类对正则极小化算子封闭。

**定理9.1.23 (原始递归可表示)** 可表示函数类对原始递归封闭。该结论的证明过程十分精妙。为了避免使用原始递归的幂、素数算子，导致循环论证，哥德尔“与上帝通话后”，利用中国剩余定理构造出只依赖于加法、乘法、极小化等可表示函数的$\beta$函数，借助它，在元语言（算术）层面上，完成了原始递归可表示性的证明。

## 语法算术化

所谓算术化的语法，指的是将语言$\mathscr{L}_1$的语法表示成元语言上有关自然数的关系、函数、谓词。

自然数$n$的数码 $\mathsf{n} := \mathsf{S}^n \mathsf{0}$

项的哥德尔编码的数码 $\lceil \sigma \rceil := \mathsf{S}^{\sharp \sigma} \mathsf{0}$

算术语言符号（如$\forall$）的哥德尔编码：$\sharp \forall = 1$，详见下表。

|s|$\mathsf{\forall}$|$\mathsf{0}$|$\mathsf{S}$|$\mathsf{+}$|$\mathsf{\cdot}$|$\mathsf{(}$|$\mathsf{)}$|$\mathsf{\neg}$|$\mathsf{\to}$|$\mathsf{\approx}$|$v_0$|$v_1$|...|
|-------|
|#s|1|3|5|7|9|11|13|15|17|19|21|23|...|

算术语言的项或公式$\sigma$的哥德尔编码：$\sharp \sigma = x$；而某一哥德尔编码$x \in \mathbb{N}$所对应的算术语言字符串是$\natural x = \sigma$。注意：

- 约定：用斜体希腊字母来表示算术语言的字符串（项或公式），用斜体拉丁字母$x$、$y$等表示自然数。这些都是元语言的变量符号，而不是算术语言内部的符号。
- 升号$\sharp$代表哥德尔编码，还原号$\natural$代表哥德尔解码。两者是元语言符号，代表元语言上的哥德尔编解码这个一元函数。
- 后面将会说明，算术语言字符串的哥德尔编解码过程，是能行的，也就是可计算的，进而是可（在算术语言内部）表示的。
- 哥德尔编解码过程是互逆的，元语言表述为：$\sharp \sigma = x$，当且仅当$\natural x = \sigma$。
- 并非所有的自然数都属于哥德尔编码的值域。对于不是哥德尔编码的“一般”自然数$x$，其解码结果$\natural x$是未定义的。

将算术语言的语法概念表示为自然数上的关系和谓词。这意味着，某个（某些）算术语言公式的哥德尔编码属于这些关系和谓词，等价于这个（这些）公式具备这些关系和谓词所描述的语法性质。有了这些谓词和关系，就可以将算术语言公式的元语言性质在元语言中表述出来，再根据关系的可表示性定理，就可以将算术语言的元语言性质用算术语言自身的公式来表述出来。这样，算术语言就真正实现了“自己描述自己”，同时明确将元语言（算术关系）和对象语言（纯粹符号序列）区分开来。

在哥德尔的论文中，构造了46个谓词和关系，最终构造出最为关键的“可证”谓词。前45个谓词和关系都是递归的，唯独第46个谓词、也是最重要的“可证”谓词，是递归可枚举的。正因为如此，哥德尔1931年发表的（第一）不完全性定理实际上是以一个较强的条件——ω-一致性——为前提，因而是一个较弱的结论。不过后面会讲到，Rosser证实了哥德尔第一不完全性定理可以被推广为更强的、更一般的不完全性定理。

以下便是哥德尔论文中46个谓词和关系的构造方式和元语言含义。注意：对于关系$R$而言，$(x,y) \in R$在记法上等同于$R(x,y)$。

**(1) 整除关系**

$$ y \vert x \Leftrightarrow (\exists z ≤ x) (x \approx y \times z) $$

**(2) 质数谓词**

**(3) 素因子关系**

**(4) 阶乘关系**

**(42) 公理谓词** $\mathrm{isAxiom}(x)$

**(43) xx序列关系** $\mathrm{immConseq}(x, y, z)$

**(44) 证明序列谓词** $\mathrm{isProofFigure}(x)$

**(45) 证明关系** $\mathrm{bew}(x, y)$

$$
\begin{align}
& \mathrm{bew}_T(n, \sharp \sigma) := \\\\
& \{(n, \sharp \sigma) \in \mathbb{N}^2 : \natural n 是 T 上对公式 \sigma 的一个证明序列 \}
\end{align}
$$

**(46) 可证谓词** $\mathrm{bwb}(x)$

$$ \mathrm{bwb}_T(\sharp \sigma) := \{ \sharp \sigma \in \mathbb{N} : \exists n \mathrm{bew}_T (n, \sharp \sigma) \} $$

由于关系$\mathrm{bew}_T$是递归的，根据引理7.5.2(6)，可证性谓词$\mathrm{bwb}_T$是递归可枚举的。


------

至此，经过大量工作，终于可以将元语言上的“可证性”和“不可证”表述，表示为算术语言内部的公式。

首先将证明关系$\mathrm{bew}_T$表示为算术语言公式。由于$\mathrm{bew}_T$是递归的，因此，根据可表示性定理，以及关系可表示性的定义（定义9.1.5），有：

- 若$(n, \sharp \sigma) \in \mathrm{bew}_T$，则 $T \vdash \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$，同时
- 若$(n, \sharp \sigma) \not \in \mathrm{bew}_T$，则 $T \vdash \neg \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$

其中无衬线字体的符号$\mathsf{bew}$代表含有两个自由变元的算术语言公式，它是递归关系$\mathrm{bew}_T$在算术语言内部的表示公式。公式的具体形式，可以根据上面给出的45个递归关系的定义，递归地构建出来，想必是相当复杂的。但是可以确认的是，$\mathsf{bew}$必定是可以被能行地构造出来的，因而现在并不关心它的具体形式。如果还是觉得所谓的“可表示性”过于抽象，难以令人信服，不妨看看[这里](http://www.von-eitzen.de/math/tntrep.xml)（[来源](https://www.zhihu.com/question/319365552/answer/2311005501)）提供的（不）可证谓词的一个直观样貌。这也直观印证了元语言上有关形式系统的表述竟然能够在对象语言内部表达出来这一令人惊叹的事实。

至于最重要的第46个谓词$\mathrm{bwb}_T$，由于它并非递归集，因此不满足可表示性定理。但是，这并不意味着它完全不可表示。事实上，后面会证明，$\mathrm{bwb}_T$是“部分可表示”的。在证明这一点之前，首先定义

$$ \mathsf{bwb}(x) := \exists y \mathsf{bew}(y, x) $$

[[#f00:注意：不能说$\mathsf{bwb}$能够**表示**$\mathrm{bwb}_T$关系。#]]根据推论9.1.26，$\mathsf{bew}$是$\Delta_1$的，因此$\mathsf{bwb}$是$\Sigma_1$的，因而$\mathsf{bwb}$符合$\Sigma_1$-完全性（定理9.1.8）。

为了将元语言上的“可证性”与算术语言内部的表示联系起来，事先证明4个重要引理。这些引理距离证明目标仅一步之遥。之所以将这些引理单独列举出来，是因为这样可以大大简化第一不完全性定理的最终证明过程，使其简明易读。

**引理9.2.1(1) (可证性的表示)** 若$T \vdash \sigma$，则 存在$n \in \mathbb{N}$，使得$T \vdash \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。

证明1：由于$T \vdash \sigma$，存在标准自然数$n \in \mathbb{N}$，使得$(n, \sharp \sigma) \in \mathrm{bew}_T$，因而根据递归关系$\mathrm{bew}_T$的可表示性，有$T \vdash \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。因此，引理9.2.1(1)得证。∎

证明2：根据$T \vdash \sigma$在标准算术模型$\mathfrak{N}$中的元语言语义，存在标准自然数$n \in \mathbb{N}$，使得$\mathfrak{N} \models \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。由于$\mathsf{bew}$是$\Delta_1$的因而也是$\Sigma_1$的，根据定理9.1.8，$\mathfrak{N} \models \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$等价于$T \vdash \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。因此，引理9.2.1(1)得证。∎

**引理9.2.1(2) (不可证的表示)** 若$T \not \vdash \sigma$，则 所有$n \in \mathbb{N}$，都使得$T \vdash \neg \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。

证明：与引理9.2.1(1)类似，也有两种证法。此处仅用一种。由于$T \not \vdash \sigma$，对于所有的标准自然数$n \in \mathbb{N}$，都有$(n, \sharp \sigma) \not \in \mathrm{bew}_T(n, \sharp \sigma)$，因而根据递归关系$\mathrm{bew}_T$的可表示性，有$T \vdash \neg \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。因此，引理9.2.1(2)得证。∎

注意：①可以看到，在这里，“可证性”的表示并不是纯粹语法的，而是保留了有关自然数的元语言表述，最突出的表现是表示公式中出现了自然数的数码$\mathsf{n}$；②这里之所以能够把元语言层面的**不**可证“翻进”对象语言，使得元语言中的否定含义可以在对象语言中表示（定义9.1.5），是因为递归关系可以同时确认正反两个方面的信息。随后立刻可以看到，对于递归可枚举的关系来说，否定符号是不能随随便便“翻进”对象语言的。

[[#00f:现在考虑元语言中表述的可证性谓词$\mathrm{bwb}_T$。#]]由于关系$\mathrm{bwb}_T$是递归可枚举的，因此无法保证能够在有限的时间内判断某个$\sharp \sigma \in \mathbb{N}$是否**不**属于$\mathrm{bwb}_T$（即$T \not \vdash \sigma$，注意不是“证否”，即$T \vdash \neg \sigma$），更不能保证$T \not \vdash \mathsf{bwb}(\lceil \sigma \rceil)$或者$T \vdash \neg \mathsf{bwb}(\lceil \sigma \rceil)$。因此，从反面的角度出发，理论$T$并不能在其内部表达“不可证”谓词。然而，如果从正面的角度（$T \vdash \sigma$）出发，则可以得到以下引理：

**引理9.2.1(3)** 若$T \vdash \sigma$，则$T \vdash \mathsf{bwb}(\lceil \sigma \rceil)$。

证明：由于$T \vdash \sigma$，根据引理9.2.1(1)，存在标准自然数$n \in \mathbb{N}$，使得$T \vdash \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。由于对于任意一阶语言公式$\phi$都有$T \vdash \phi \rightarrow \exists x \phi$（一阶语言有效式，其中$x$是变元），根据分离规则，有$T \vdash \exists x \mathsf{bew}(x, \lceil \sigma \rceil)$，即$T \vdash \mathsf{bwb}(\lceil \sigma \rceil)$。∎

引理9.2.1(3)表明：①$\mathsf{bwb}$只能从正面去描述“可证性”概念，而不具备反面断言的能力，因此它并不具备完全描述可证性（可证+不可证）的能力，但却能够“部分地”表示可证性。因此，当我们想要讨论“不可证”时，只能回到引理9.2.1(2)。②这一现象暗示着$T$这个理论本身确实很有可能是不可判定的，对不完全性定理的论证产生了重大的影响。一方面，哥德尔特地为此定义了比简单一致性更强的ω-一致性；另一方面，这启发了罗瑟通过引入有界量词来处理这种部分递归性质，从而得到与算术语义无关的、纯粹语法的哥德尔-罗瑟不完全性定理（1936年）。③引理9.2.1(2)是涉及自然数的，它的元语言表述中引入了“对于所有自然数”这样的算术概念，因而不是纯粹语法的。而引理9.2.1(3)是纯粹语法的。

引理9.2.1(3)的逆命题，在一般情况下并不成立，除非知道$\mathfrak{N}$是$T$的模型，或者知道$T$是ω-一致的。因此有以下引理（对应《数理逻辑入门》P222问题13）：

**引理9.2.1(4)** 若$T \vdash \mathsf{bwb}(\lceil \sigma \rceil)$且$T$是ω-一致的，则$T \vdash \sigma$。

证明：用反证法。假设$T \not \vdash \sigma$，根据引理9.1.2(2)，可知对于所有$n \in \mathbb{N}$，都使得$T \vdash \neg \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。然而，前提$T \vdash \mathsf{bwb}(\lceil \sigma \rceil)$也就是$T \vdash \exists y \mathsf{bew}(y, \lceil \sigma \rceil)$，与“$T$是ω-一致的”矛盾，因此，假设不成立，从而引理9.2.1(4)得证。∎

有了以上引理的准备，就可以深入第一不完全性定理证明过程的核心了。

## 一致性、完全性和可判定性

**ω-一致性和简单一致性**

关于ω-不一致的一种理解，来自Smullyan的《数理逻辑入门》P218：有这样一张支票，上面写着“在某家银行可以兑现”，然而跑遍了无穷多家银行，都说不能兑现。从眼下的状况来说，称这种情况是“ω-不一致”的。

**完全性**（余 评注5.4.95）

- 语义完全性
- 语法完全性
- 相对于标准自然数模型的语义完全性

**不可判定性**

## 不动点和自指句

**引理9.3.1 (不动点引理)** 对于任意只含一个自由变元的公式$\psi(v_1)$，都可以能行地找到一个语句$\sigma$，使得

$$ \mathsf{Q} \vdash \sigma \leftrightarrow \psi(\lceil \sigma \rceil) $$

参考资料【S C Kleene. [**Origins of Recursive Function Theory**](https://courses.fit.cvut.cz/MI-VYC/kleene-origins.pdf). Annals of the History of Computing, 1981,3(1). 已备份.】（被参考资料【刘晓力. **从丘奇-图灵论题到多奇原理**. 自然辩证法研究, 2022,18(增刊):23-27. 已备份.】所引用）指出，克林尼在了解到丘奇论题之后，试图运用对角线论证法推翻这个论题，然而：

> When Church proposed this thesis, I sat down to disprove it by diagonalizing out of the class of the λ-definable functions. But, quickly realizing that the diagonalization cannot be done effectively, I became overnight a supporter of the thesis.

参考资料《递归论：算法与随机性基础》书中分享了一个神秘的小故事：

> A教授是著名数理逻辑专家，得到克林尼的真传，递归定理用得出神入化。有一次他和B教授聊天时，他说：“递归定理真是太神奇了，我用了无数次，但从不明白它说的是什么。”“尊嘟假嘟？”B教授说，“我跟你讲，递归定理其实是这么一回事……”。“从那时起，我终于明白了递归定理究竟说的是什么”，A教授后来回忆说，“但我再也不知道怎么用它了！”

考虑到这个故事跟递归定理一样神秘，我就懒得看哥德尔的不动点引理的构造性证明过程了。

诸如此类的不动点，比如Y组合子、罗素悖论、理查德悖论等等，都是非常神秘地构造出来的。既然是神来之笔的构造，那么所谓的证明过程只是对这个构造的技术封装罢了。对角线也好、自调用组合子也罢，都是表象，而实质是这样的自指自复制结构是**能够**构造的。进而运用这个自指核心去证明或否证一些问题。

几年前了解到Y组合子，至今也想不通它是如何构造的。或许，既然是构造的，那其实本没有什么依据：它本身就是个依据。所以，接受并记住这个神秘的构造吧，并承认它的存在。[有人把Y组合子文在胳膊上](https://matt.might.net/articles/compiling-up-to-lambda-calculus/)，看来我应该把它文在脑子里。这就足够了。

说到通过“构造”去证明某些命题，历史上有个有趣的案例。1903年，美国数学家[科尔](https://en.wikipedia.org/wiki/Frank_Nelson_Cole)在某次会议上做了一场著名的演讲。整场演讲，他一言未发，只是在黑板上写下了第67个梅森数（$M_{67} = 2^{67}-1$）的素因子分解结果。这就无声但雄辩地证明了梅森数并非全都是素数，尽管这一事实早已得到证明。

书目悖论和对角线论证

## 第一不完全性定理

**定理9.4.2 (Gödel第一不完全性定理)** 设$T \supseteq \mathsf{Q}$为一个递归可公理化的理论。如果$T$是ω-一致的（因而也是简单一致的），则$T$是不完全的，即存在$\Pi_1$-语句$\sigma$，使得$T \not \vdash \sigma$且$T \not \vdash \neg \sigma$。

证明：根据不动点引理，令语句$\sigma$是一元公式$\neg \mathsf{bwb}$的不动点，有$T \vdash \sigma \leftrightarrow \neg \mathsf{bwb}(\lceil \sigma \rceil)$。根据推论9.1.26，$\mathsf{bew} \in \Delta_1$，因而$\mathsf{bwb} \in \Sigma_1$，据此观察不动点引理的构造性证明过程（上文省略了，请读者相信这一点），可知$\sigma \in \Pi_1$。$\sigma$可以理解为表达了“我不可证”的含义。

现在证明语句$\sigma$是不可判定的算术真命题。

一、证明$\sigma$不可判定，即$T \not \vdash \sigma$且$T \not \vdash \neg \sigma$。用反证法：

1° 假设$T \vdash \sigma$：

- 一方面，根据引理9.2.1(3)，$T \vdash \mathsf{bwb}(\lceil \sigma \rceil)$。
- 另一方面，根据不动点引理，$T \vdash \neg \mathsf{bwb}(\lceil \sigma \rceil)$。

这与$T$的简单一致性矛盾。因此$T \not \vdash \sigma$。

2° 假设$T \vdash \neg \sigma$：

- 一方面，根据简单一致性，$T \not \vdash \sigma$，进而根据引理9.2.1(2)，对于任何$n \in \mathbb{N}$，$T \vdash \neg \mathsf{bew}(\mathsf{n}, \lceil \sigma \rceil)$。
- 另一方面，根据不动点引理，$T \vdash \mathsf{bwb}(\lceil \sigma \rceil)$，即$T \vdash \exists y \mathsf{bew}(y, \lceil \sigma \rceil)$。

这与$T$的ω-一致性矛盾。因此$T \not \vdash \neg \sigma$。注意，上面由$T \not \vdash \sigma$并不能推出$T \vdash \neg \mathsf{bwb}(\lceil \sigma \rceil)$，详见前文引理9.2.1(3)的说明。

二、证明$\sigma$是标准算术模型$\mathfrak{N}$上的真命题。由于$\sigma \in \Pi_1$，所以$\neg \sigma \in \Sigma_1$。因为前面已经证出$T \not \vdash \neg \sigma$，根据定理9.1.8（$\Sigma_1$-完全性），可知$\mathfrak{N} \not \models \neg \sigma$，因此$\mathfrak{N} \models \sigma$（塔斯基语义的定义，余定义3.3.13和评注3.3.44，郝定义5.1.3和推论5.1.6），即$\sigma$是算术真命题。更直白地讲，前面在元语言层次上证明$T \not \vdash \sigma$和$T \not \vdash \neg \sigma$的过程，本身就证明了$\sigma$（“我不可证”）的算术真。

综上所述，**算术理论$T$存在着形式无法判定的真命题，也就是说，算术理论无法证明所有的算术真命题**。因此，算术理论是不完全的。∎

说明：

- 引理9.2.1便是《哥德尔证明》中称为“对应引理”的关键引理。这个引理表明，诸如“某句话是可证的”这样的元语言论述，可以被表示为对象语言内部的语句，同时还能在对象语言中维持其在元语言中的含义。这意味着，对象语言能够忠实地谈论自身。因此，像“我不可证”这样的自指句，就有了“打破第四面墙——引号”的能力。
- 不动点引理表明，像“我不可证”这样的自指句，是可以被“能行地”构造出来的。
- 所谓“ω-一致性”是比简单一致性更强的条件。

<details>

<summary>自然语言描述</summary>

首先，在语法层面，可以能行地构造出“我不可证”这样一个自指句，这句话是所谓$\Pi_1$的。接下来将用反证法来证明，这句话果然如其所说，是不可证的。

1° 假设“我不可证”这句话可证。

- 一方面，根据引理9.2.1(3)，系统可以证明“‘我不可证’这句话是可证的”。
- 另一方面，根据不动点引理（系统可以证明“我不可证”等价于“‘我不可证’这句话不可证”），运用系统内部的分离规则可知，系统能够证明“‘我不可证’这句话不可证”。

系统能够同时证明“我不可证”这句话的可证性和不可证性，意味着系统是不一致的，这与前提矛盾，因此“我不可证”这句话是不可证的。

2° 假设“我不可证”这句话可否证，即，“我并非不可证”这句话可证。

- 一方面，由于系统是一致的，“我不可证”这句话应当是不可证的，进而根据引理9.2.1(2)，系统能够证明“任何哥德尔数都无法证明‘我不可证’这句话”。
- 另一方面，根据不动点引理（系统可以证明“我并非不可证”等价于“‘我不可证’这句话可证”），运用系统内部的分离规则可知，系统能够证明“‘我不可证’这句话可证”，也就是“存在某个哥德尔数能够证明‘我不可证’这句话”。

系统能够同时证明“存在某个哥德尔数能够证明”和“任何哥德尔数都无法证明”，意味着系统是ω-不一致的，这与前提矛盾，因此“我不可证”这句话是不可否证的。

综合以上两种情况，可知系统对于“我不可证”这句真话既不可证明，也不可否证，这等价于系统对于“我不可证”这句话是形式上不可证的。

其次，在语义层面，“我不可证”这句话是真命题。

由于“我不可证”这句话是$\Pi_1$语句，因此“我可证”是$\Sigma_1$语句。由于前面的论证表明，“我可证”这句话是不可证的，根据系统的$\Sigma_1$完全性（如果系统证不出某句话，那么这句话是假的）可知，“我可证”这句话是假的，因而“我不可证”这句话是真的。

综上所述，存在着系统无法证明的真命题，也就是说，系统无法证明所有的真命题。因此，系统是不完全的。

</details>

**定理9.4.3 (Gödel-Rosser第一不完全性定理)**

设$T \supseteq \mathsf{Q}$为一个递归可公理化的理论。如果$T$是简单一致的，则$T$是不完全的，即存在$\Pi_1$-语句$\sigma$，使得$T \not \vdash \sigma$且$T \not \vdash \neg \sigma$。

证明：首先引入一个原始递归函数$\mathrm{not}(x) := \sharp(\neg \natural x)$，即$\sharp \sigma \mapsto \sharp (\neg \sigma)$，其中$x$是自然数，$\sigma$是$\mathscr{L}_1$公式。可见，这个函数的作用是将某个公式的哥德尔数映射为它的否定公式的哥德尔数，它在元语言和算术语言之间横跳了两次。由于它是原始递归的，因而可以被表示为算术语言内部的公式，记为$\mathsf{not}(x)$，含有1个自由变量。在算术语言中，如果$x \approx \lceil \sigma \rceil$，则$\mathsf{not}(x) \approx \lceil \neg \sigma \rceil$。

在哥德尔的原初证明中，公式$\mathsf{bwb}$只能表示可证性，而不能表示“不可证性”，因此只能得到在ω-一致的前提下导出的较弱的不完全性的结论。Rosser为了将前提减弱为简单一致性，从而得到更强的不完全性，他在$\mathsf{bew}$的基础上重新构造了一个改进版的表述“可证性”的公式$\mathsf{prov}$，这个定义的直观含义是：语句$\sigma$存在证明序列$y$，同时，所有比$y$“小”的公式序列，都不能证明其否定$\neg \sigma$。$\mathsf{prov}$的定义如下：

$$ \begin{align}
& \mathsf{prov}(x) := \\\\
& \exists y (\mathsf{bew}(y, x) \wedge ((\forall z \lt y) \neg \mathsf{bew}(z, \mathsf{not}(x))))
\end{align} $$

首先证明两个断言：

**断言1**：对任意语句$\sigma$，如果$T \vdash \sigma$，则$T \vdash \mathsf{prov}(\lceil \sigma \rceil)$。

断言1的证明：

**断言2**：对任意语句$\sigma$，如果$T \vdash \neg \sigma$，则$T \vdash \neg \mathsf{prov}(\lceil \sigma \rceil)$。

断言2的证明：

------

哥德尔1930年证明的第一不完全性定理，是基于所谓的标准自然数模型的。这个模型某种意义上是潜无穷的，并不存在一个完成了的无穷“∞”，这符合人们的直观，所以它的前提实际上是所谓的“ω-一致性”。这个性质三言两语很难讲清楚，简单来说，首先，它是一个比简单一致性更强的条件，其次，它把元语言和对象语言搅和到一起去了。因此，哥德尔1930年的第一不完全性定理，实际上并没有完全解决算术系统的纯粹形式完全性的问题。

而Rosser在1936年将不完全性定理的前提推广到简单一致性。在简单一致性的情况下，可以讨论所谓的“非标准自然数模型”。这个非标准模型是承认实无穷存在的，并且其内部并不是混乱无序的，而是有微妙的序结构。这是一个比较直观的现象：所有的“∞”一定是“大于”所有的“标准自然数”的。因此，只要能够从正面找到一个自然数，那么就可以讨论所有在它“之前”的自然数，而不会失去有关算术理论的一般性。

正是因为算术理论有这种内在的序结构，使得算术系统不完全性定理的条件可以从比较严格的“ω-一致性”放松到简单一致性而依然正确。

以上文字并没有讲清楚从Gödel的不完全性定理向Gödel-Rosser不完全性定理推广的奥义，事实上这个推广过程本身也是依赖很多前置知识的，因此对它的描述不可能同时做到完备和通俗。



**塔斯基定理**

## 第二不完全性定理

![ ](./image/G1/Haruhi-8-22-34.jpg)

**一致性不可自证**

PM足够强大到证明自身的一致性吗？很遗憾，不可能。请看证明：

- 构造PM公式$A→G$，其中$A$表达的元数学命题是“PM是一致的”，
- 并证明$A→G$在PM中可证。
- 假设$A$在PM中可证（也就是PM自身可以证明自身的一致性），
- 则根据分离规则，$G$也应该是可证的。
- 然而刚才已经证明，如果$G$可证，则$～G$可证，意味着PM不一致，矛盾。
- 因此，**如果PM一致，则PM不可能证明自身的一致性。**

这就是哥德尔第二不完全性定理。该定理并未排除在PM系统外证明PM一致性的可能性！

**不完全性的推论**

- 存在不一致的理论，它能证明自己一致，也能证明自己不一致。
- 存在一致的理论，它不能证明自己一致，也不能证明自己不一致。
- 存在一致的理论，它不能证明自己一致，但是能证明自己不一致。
- 存在一致的理论，它能证明自己一致，但是不能证明自己不一致。

**自然的不可判定的真命题**

古德斯坦定理

## 向创造思维致敬

**Gödel's Disjunction 哥德尔的选言命题**

> So the following disjunctive conclusion is inevitable: Either mathematics is incompletable in this sense, that its evident axioms can never be comprised in a finite rule, that is to say, **the human mind (even within the realm of pure mathematics) infinitely surpasses the powers of any finite machine, or else there exist absolutely unsolvable diophantine problems.**

[参考资料](https://www.zhihu.com/question/549218308/answer/2711623909)

> 演算机械的固有局限性并不意味着不能用物理学或者化学的方法来解释生命和理性。哥德尔定理既没有排除、也没有肯定这种可能性。哥德尔定理的确表明，**人类思想的结构和力量，要远比任何机器都要复杂和微妙。**哥德尔证明本身，便是这种**复杂**和微妙的显著例证。**我们完全不必为此失望，而应把握住这个对创造性理性再次赞赏的机会。**

> ——《哥德尔证明》第八章：结论性的反思

哥德尔证明→编码与计算→计算的极限→在微妙的复杂中超越计算极限

**一些题外话**

哥德尔晚年研究现象学，我也对现象学颇感兴趣。作为水平低下的业余爱好者，我对每个学科领域的具体知识和技能掌握甚少，只是满足于方向和品味层面的一瞥，所谓“观其大略”。因而我对于人的研究品味的一脉相承的结构性非常好奇：为什么总是会殊途同归呢？

哥德尔最后是怎么去世的，是因为怀疑别人给自己投毒，绝食而死。我小时候大概一年级的时候也有过一次类似的经历：看到学后班的汤上面浮着一层薄薄的油膜，呈现出彩色的牛顿环，我坚持视其为汽油，拒绝吃饭。

![“愚者”千反田酱，象征着无限的可能](./image/G2/chitanda.jpg)

# 第六章：心智的潜力

判定问题、函数问题（搜索问题）、优化问题

图灵度、算法信息论

理解复杂系统

![ ](./image/G2/conway-game-of-life-turing-machine.png)

GEB第326页：旨在破坏逻辑头脑的禅宗公案

# 第七章：无穷的无穷

[超计算模型](https://www.zhihu.com/question/21579465/answer/106995708)

[大数的探寻](https://www.jianshu.com/p/35052a45e20f)（如[忙碌海狸数](https://zh.wikipedia.org/wiki/%E5%BF%99%E7%A2%8C%E7%9A%84%E6%B5%B7%E7%8B%B8)）

- [会做数学证明的“忙碌海狸”，以及比TREE(3)还大的“不可计算数”](https://www.zhihu.com/tardis/zm/art/145975481)：文中提到，从传播效果看，“忙碌海狸”函数这样的名字的传播效果远比“Sigma函数”好。
- [忙碌海狸函数BB(1)到BB(5)的值是怎么计算的](https://www.zhihu.com/tardis/zm/art/337546518)

> 高峰要高到无穷，红旗要红过九重！
——中国科学技术大学校歌《永恒的东风》

------

> 列宁有一次发表演讲：“共产主义已经出现在地平线上。”台下有个工人问身边的教授：“什么是地平线？” 教授说：“地平线是一条假想的线，天和地在那里相接，但是当你走近它时，你就会发现它会离开你，然后又出现在远方。——苏联笑话

# 尾声

一等函数是许多高级语言都具备的特性，也是函数式编程的核心思想之一。一等函数思想和函数式编程的源头是丘奇发明的λ演算。通过本文介绍的Y组合子，看起来很简陋的λ演算，也可以实现递归函数，乃至具备和图灵机一样强大的计算能力。

不动点组合子的存在，意味着λ演算的确是足够强大的，但这并不意味着我们一定要使用它去书写递归程序。既然匿名函数可以通过不动点组合子实现递归，那么我们何必拘泥于“匿名”这一限制呢？直接赋予λ项以“名字”，岂不是更方便？于是，我们**终于可以安心地在编程语言中使用`(define ..)`这样的机制，给函数和各种各样的对象起名字，并且引用它们了**。不动点组合子，就是我们用来认识“名字”的深层意义的阶梯。

![你的名字？](./image/G2/omaedare.jpg)

事实上，λ演算并非最简洁的图灵完备系统。[SKI组合子](https://en.wikipedia.org/wiki/SKI_combinator_calculus)系统、标签系统、元胞自动机、甚至PPT，都具备和λ演算一样强大的能力，都可以实现递归，互相模拟彼此的行为。不动点组合子和这些同等强大的计算模型，能够帮助我们看清“名字”的本质。但是，自我指涉和互相模拟，似乎构成了一个无穷无尽的循环，似乎不能带领我们更进一步，不能带领我们突破计算的“极限”。

> 在登上高处后，就必须把梯子扔掉。必须超越这些命题，然后才会正确看待世界。
——维特根斯坦《逻辑哲学论》，命题6.54

在我们熟悉的代码的背后，有着深邃而奇妙的数理逻辑背景。Y组合子就像是镶嵌在数理逻辑天空中的一颗闪闪发光的星星，我们可以无视它，甚至不需要知道它的存在。但正是这一颗一颗闪烁着智慧之光的星星，共同点亮了计算机科学璀璨的星空，点亮了我们探索无穷的路。

为什么要仰望星空呢？因为星星就在那里呀。

# 附录1：The Little Schemer 学习笔记

2017-09-02开始，2017-11-15完成。

## 前言

原子是Scheme的基本元素之一。首先定义了过程`atom?`，用来判断一个S-表达式是不是原子：

```:Scheme
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
```

这个“pair”实际上就是list，见[http://blog.csdn.net/xiao_wanpeng/article/details/8466745]()。

但是需要注意，pair和list是两码事。pair在表达上是诸如`'(1 . 2)`这样用点分隔开的二元组。

## 第一章

**S-表达式**包括①原子atom；②列表list。

**car**取非空列表的第一个**S-表达式**。

**cdr**取非空列表list的 除`(car list)`的剩余所有元素 组成的 **列表**。

**cons**将某个S-表达式 添加到 某个列表的开头。

**null?** 判断S-表达式是否是空列表。

**eq?** 判断两个S-表达式是否相同。

list的默认解析方式是：以car为函数名，以cdr为参数列表对函数进行调用，整个list的evaluated的结果就是函数的返回值。某些“关键字”作为car时，求值规则会发生变化，这个要具体问题具体分析。这个问题可以参考SICP的练习1.6。（“关键字”很少，并不复杂）

**quote** 或者 **'** 用来抑制对S-表达式的求值。由于S-表达式是递归结构，因此被抑制求值的S-表达式的各个子表达式都不会被求值。被quote的部分是作为“数据”的代码。quoted原子的结果是它本身，类似于C系语言的enum；quoted数字原子的结果仍然是数字；quoted list的结果就是不求值的列表，类似于链表这样的结构。

## 第二章

本章从`lat?`函数的实现出发，探讨递归处理lat的基本思想和方法。

定义过程`lat?`，用来判断表的子表达式是否都是原子，即判断list是不是lat（list of atoms）。第五章之前，涉及到的列表基本上都是lat。

```:Scheme
(define lat?
  (lambda (list)
    (cond ((null? list) #t)
          ((atom? (car list)) (lat? (cdr list)))
          (else #f)))
```
特殊形式`cond`是惰性的，也就是说，如果某个子句的谓词为真，则不再检查下面的子句。

定义过程`member?`，用来判断某个原子是否为某个lat的成员。这个函数很重要，尤其是对于实现集合的第七章。

```:Scheme
(define member?
  (lambda (x lat)
    (cond ((null? lat) #f) ;找遍列表也没找到
          ((eq? x (car lat)) #t)
          (else (member? x (cdr lat))))))
```

> 一般而言，函数应首先检查传入参数。保证递归得以收敛。

## 第三章

本章主要讲述如何使用`cons`特殊函数和一般性递归实现对lat的操作。

首先实现函数`rember`，它接受原子`a`和`lat`，返回删除了第一个`a`的`lat`。

```:Scheme
(define rember
  (lambda (a lat)
    (cond ((null? lat) lat)
          ((eq? a (car lat)) (cdr lat))
          (else (cons (car lat) (rember a (cdr lat)))))))

(define delete
  (lambda (a lat)
    (cond ((null? lat) lat)
          ((member? a lat) (delete a (rember a lat)))
          (else lat))))
```
顺便写了个`delete`，可以迭代地删除表中所有匹配原子。

P.43要求实现`firsts`函数，其功能为输出一个表的各子表的car组成的表。

```:Scheme
(define firsts
  (lambda (list)
    (cond ((null? list) '())
          ((pair? (car list)) (cons (car (car list)) (firsts (cdr list))))
          (else (cons (car list) (firsts (cdr list)))))))
```

P.47要求实现`(insertR new old list)`函数，该函数查找`old`在`list`的第一次出现位置，并在其后插入`new`。函数返回新列表。

```:Scheme
(define insertR
  (lambda (new old list)
    (cond ((null? list) list)
          ((eq? old (car list)) (cons (car list) (cons new (cdr list))))
          (else (cons (car list) (insertR new old (cdr list)))))))
```
也可以仿照上面的`delete`函数写一个在所有`old`后面插入`new`的函数。

类似地可以写出`insertL`，其与`insertR`的区别在于前者是在左侧插入新表达式。

```:Scheme
(define insertL
  (lambda (new old list)
    (cond ((null? list) list)
          ((eq? old (car list)) (cons new list))
          (else (cons (car list) (insertL new old (cdr list)))))))
```

P.51还要求实现`(subst new old list)`函数，该函数用`new`替换`old`在`list`的首个出现。

```:Scheme
(define subst
  (lambda (new old list)
    (cond ((null? list) list)
          ((eq? old (car list)) (cons new (cdr list)))
          (else (cons (car list) (subst new old (cdr list)))))))
```

都是一样的套路，改变的都是递归回溯条件。

基于此，P.52要求实现`(subst2 new o1 o2 list)`函数，该函数用`new`替换`o1`或者`o2`在`list`的首个出现。

```:Scheme
(define subst2
  (lambda (new o1 o2 list)
    (cond ((null? list) list)
          ((or (eq? o1 (car list)) (eq? o2 (car list))) (cons new (cdr list)))
          (else (cons (car list) (subst2 new o1 o2 (cdr list)))))))
```

到这里，套路已经很熟悉了。换个套路：

P.52要求修改`rember`函数为`multirember`，实现对所有匹配子表达式的删除。

```:Scheme
(define multirember
  (lambda (x list)
    (cond ((null? list) list)
          ((eq? x (car list)) (multirember x (cdr list)))
          (else (cons (car list) (multirember x (cdr list)))))))
```

`multirember`跟`delete`的效果是等价的。但`delete`是对`rember`的封装，复用了既有函数，有工程上的优点。复杂度方面，`multirember`更好一点。`multirember`只遍历一次list，而封装后的`delete`每次都要从头开始执行`rember`，并且`member?`也是额外的开销。在复杂度的问题上，鱼与熊掌是不可兼得的，还是要具体问题具体分析。

其余multi函数也是类似的套路，就不写了。

套路总结：

+ 可以看出，list实际上就是二叉树
+ 函数必须有可达的递归出口条件
+ 递归调用时必须向出口条件方向改变参数，保证新参数是原有问题的子问题（例如list的cdr、数值的减一或折半，等等）

Racket好像没有`list-set`，写一个：

```:Scheme
(define list '(1 2 3 4))

(define list-set
  (lambda (list pos new-value iter)
    (define list-set!-iter
      (lambda (list pos new-value iter)
        (cond ((= iter pos) (cons new-value (cdr list)))
              (else (cons (car list) (list-set!-iter (cdr list) pos new-value (+ iter 1)))))))
    (list-set!-iter list pos new-value 0)))

(list-set list 0 10 0)
(list-set list 1 20 0)
(list-set list 2 30 0)
(list-set list 3 40 0)
```

## 第四章

本章讲述了基本数值运算和谓词的实现。

这里暂时只考虑自然数，即非负整数。首先定义两个魔法函数：“+1”函数和“-1”函数。

```:Scheme
;加一函数
(define add1
  (lambda (n)
    (+ n 1)))
;减一函数
(define sub1
  (lambda (n)
    (- n 1)))
```

之所以叫魔法函数，是因为从这两个函数出发，可以得到**无穷**。但是减一函数有点特殊，它如果一直重复下去的话，一下子就……会违反我们的基本法——0是不能“-1”的。

所以为了避免我们违反基本法，我们也要有自己的判断：引入`zero?`函数来判断一个数是不是0。`zero?`是R5RS钦定的特殊形式。

现在实现加法运算`(add a b)`如下：

```:Scheme
(define add
  (lambda (a b)
    (if (zero? b)
        a
        (add (add1 a) (sub1 b)))))
```

以上是迭代式实现。那么如何递归地实现它呢？

```:Scheme
(define add-r
  (lambda (a b)
    (if (zero? b)
        a
        (add1 (add a (sub1 b))))))
```

二者是不同的。`add`将自己的参数作为迭代器，回溯的时候没有额外动作。而`add-r`到达递归终止条件时，会执行掉栈中剩余的`add1`函数，加法是在回溯的过程中发生的。这个问题，SICP讲得很清楚，因为读过这一段了，所以在这里多说一句。

`add1`之于数字，正如`cons`之于列表——皮亚诺的+1魔法。

至于减法，也是一样的套路。但这里有一个疑问：The Little Schemer并没有严格在非负整数基本法的框架内搭建这个减法。不管了不管了，因为法律就是用来践踏的嘛。

在这些函数的基础上，编写关于“元组”tuple的运算。所谓的元组，实际上就是逻辑上的数组。

首先实现元组的累积：

```:Scheme
;元组累积
(define addtup
  (lambda (list)
    (cond ((null? list) 0)
          (else (add (car list) (addtup (cdr list)))))))

(addtup '(10 20 30 40 50 60 70 80 90 100))
```

实现一个乘法运算：

```:Scheme
;乘法
(define multiply
  (lambda (a b)
    (cond ((eq? b 0) 0)
          (else (add a (multiply a (sub1 b)))))))

(multiply 15 20)
```

然后实现一个向量加法

```:Scheme
;向量加法
(define tup+
  (lambda (list1 list2)
    (cond ((or (null? list1) (null? list2)) '())
          (else (cons (add (car list1) (car list2)) (tup+ (cdr list1) (cdr list2)))))))

(tup+ '(10 2 9 10 11) '(2))
```

继续实现小于/大于号函数：

```:Scheme
(define lt
  (lambda (a b)
    (cond ((zero? b) #f)
          ((zero? a) #t)
          (else (lt (sub1 a) (sub1 b))))))

(define le
  (lambda (a b)
    (cond ((zero? a) #t)
          ((zero? b) #f)
          (else (le (sub1 a) (sub1 b))))))

(define gt
  (lambda (a b)
    (cond ((zero? a) #f)
          ((zero? b) #t)
          (else (gt (sub1 a) (sub1 b))))))

(define ge
  (lambda (a b)
    (cond ((zero? b) #t)
          ((zero? a) #f)
          (else (ge (sub1 a) (sub1 b))))))
```

有了这些关系运算谓词，就可以写出判断数字相等的`eqn?`谓词：

```:Scheme
(define eqn?
  (lambda (a b)
    (cond ((lt a b) #f)
          ((gt a b) #f)
          (else #t))))
```

编写计算幂的`pow`函数：

```:Scheme
(define pow
  (lambda (a b)
    (cond ((zero? b) 1)
          (else (multiply a (pow a (sub1 b)))))))
```

除法，实际上是整除（类似于C语言的/）：

```:Scheme
(define div
  (lambda (a b)
    (cond ((< a b) 0)
          (else (add1 (div (- a b) b))))))
```

求lat长度：

```:Scheme
(define len
  (lambda (lat)
    (cond ((null? lat) 0)
          (else (add1 (len (cdr lat)))))))
```

编写函数`pick`和`rampick`：

```:Scheme
(define pick
  (lambda (n lat)
    (cond ((eqn? n 1) (car lat))
          (else (pick (sub1 n) (cdr lat))))))

(define rempick
  (lambda (n lat)
    (cond ((eqn? n 1) (cdr lat))
          (else (cons (car lat) (rempick (sub1 n) (cdr lat)))))))
```

特殊形式`number?`，这是内建函数，是原语函数。

移除（保留）lat中所有的number：

```:Scheme
(define no-nums
  (lambda (lat)
    (cond ((null? lat) '())
          ((number? (car lat)) (no-nums (cdr lat)))
          (else (cons (car lat) (no-nums (cdr lat)))))))

(define all-nums
  (lambda (lat)
    (cond ((null? lat) '())
          ((number? (car lat)) (cons (car lat) (all-nums (cdr lat))))
          (else (all-nums (cdr lat))))))
```

下面这个函数`eqan?`用来判断两个原子是否相同。如果两个原子都是数字原子，则用`eqn?`来判断；若都不是，则用`eq?`判断。

```:Scheme
(define eqan?
  (lambda (a b)
    (cond ((and (number? a) (number? b)) (eqn? a b))
          ((or  (number? a) (number? b)) #f) ;走到这一步说明a或b至少有一个不是数字了
          (else (eq? a b)))))
```

本章最后一个函数：统计某原子在lat中出现的次数。

```:Scheme
(define occur
  (lambda (a lat)
    (cond ((null? lat) 0)
          ((eq? a (car lat)) (add1 (occur a (cdr lat))))
          (else (occur a (cdr lat))))))
```

## 第五章

这一章相比前面各四章对于表的处理方式，有了质的变化。本章开始处理带有嵌套子表的真·表，而不是“list of atoms”了。这就意味着，现在需要递归地对`(car list)`即表BT的左支进行处理，不像以前都只处理右支。

重写`rember*`函数如下：

```:Scheme
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

(define rember*
  (lambda (a list)
    (cond ((null? list) '())
          ((atom? (car list))
           (cond ((eq? a (car list)) (rember* a (cdr list)))
                 (else (cons (car list) (rember* a (cdr list))))))
          (else (cons (rember* a (car list)) (rember* a (cdr list)))))))

(rember* 1 '(((1 2) 3 1) 1 ((((1) 2 3) (1))) 1 1 (1)))
```

重写`insertR*`函数如下：

```:Scheme
(define insertR*
  (lambda (new old list)
    (cond ((null? list) '())
          ((atom? (car list))
           (cond ((eq? old (car list)) (cons (car list) (cons  new (insertR* new old (cdr list)))))
                 (else (cons (car list) (insertR* new old (cdr list))))))
          (else (cons (insertR* new old (car list)) (insertR* new old (cdr list)))))))

(insertR* 0 1 '(((1 2) 3 1) 1 ((((1) 2 3) (1))) 1 1 (1)))
```

可以看出，以前对lat进行处理的时候，每次递归都需要判断传入的`list`是否为空表。这实际上是对表BT的右支进行检测，如果右支存在，则继续递归。而现在涉及表BT的左支，递归执行树的形状就真的是一棵左右都有分杈的树，因此每一步都需要判断当前表的左支是否是一棵树，如果是树，则递归，如果不是树（即原子），则进行出口处理。

类似地写出对真·表进行某元素计数的`occur*`函数：

```:Scheme
(define occur*
  (lambda (a list)
    (cond ((null? list) 0)
          ((atom? (car list))
           (cond ((eq? a (car list)) (add1 (occur* a (cdr list))))
                 (else (occur* a (cdr list)))))
          (else (add (occur* a (car list)) (occur* a (cdr list)))))))
```

按照同样的套路，也可以重写`insertL*`和`subst*`，但这里不写了。

下面是一个重要的函数：`member*`。

```:Scheme
(define member*
  (lambda (a list)
    (cond ((null? list) #f)
          ((atom? (car list))
           (cond ((eq? a (car list)) #t)
                 (else (member* a (cdr list)))))
          (else (or (member* a (car list)) (member* a (cdr list)))))))
```

下面这个函数只对左支进行递归：

```:Scheme
(define leftmost
  (lambda (list)
    (cond ((null? list) '())
          ((atom? (car list)) (car list))
          (else (leftmost (car list))))))
```

谓词`and`和`or`采用短路策略进行求值，这种特性意味着它可以采用同样具有这种特性的`cond`来实现：

```:Scheme
;(and a b)
(cond (a b)
      (else #f))
;(or a b)
(cond (a #t)
      (else b))
```

这说明，`cond`是比`and`和`or`更“基本”的特殊形式。

下面实现谓词函数`eqlist?`，该函数判断两个list是不是“完全”相同。所谓的完全相同，指的是结构和内容都完全相同。

本文前言中有说过，list实际上是特殊的pair，其car是左元素，cdr是右元素。list的结构有5种形式：

+ (null , null) 空表'()
+ (atom , null) 单原子表'(a)
+ (atom , list) 形如'(1 2 3)
+ (list , null) 形如'((1 2))
+ (list , list) 形如'((1 2) 3)

这里需要注意的是，list的cdr不是atom，如果是的话，那就是pair了。

为了判断两个list是否相同，只需要递归地判断`list1`和`list2`的左支和右支是否分别对应相同即可。

首先考虑递归出口：若两表均为null，则返回#t；若有且只有一个表是null，那肯定是#f。然后考虑左支：若两表左支均为相同atom，则递归判断右支，此种情况下，结果取决于右支是否相同；如果有且只有一个表的左支是atom，则一定是#f。其余情况下，将递归判断左支和右支，只有左右支均对应相同，两表才相同。

```:Scheme
(define eqlist?
  (lambda (list1 list2)
    (cond ((and (null? list1) (null? list2)) #t)
          ((or  (null? list1) (null? list2)) #f)
          ((and (atom? (car list1)) (atom? (car list2)))
             (and (eq? (car list1) (car list2)) (eqlist? (cdr list1) (cdr list2))))
          ((or  (atom? (car list1)) (atom? (car list2))) #f)
          (else (and (eqlist? (car list1) (car list2))
                     (eqlist? (cdr list1) (cdr list2)))))))
```

基于`eqlist?`和以往实现的`eqan?`，可以写出判断两个S-表达式是否相同的`equal?`函数：

```:Scheme
(define equal?
  (lambda (exp1 exp2)
    (cond ((and (atom? exp1) (atom? exp2)) (eqan? exp1 exp2))
          ((or  (atom? exp1) (atom? exp2)) #f)
          (else (eqlist? exp1 exp2)))))
```

## 第六章

这章对我来说非常有趣。本章以Scheme的方式解决了（中缀）表达式的求值问题，并且通过过程抽象，使得同一求值程序可以解决不同类型的表达式。甚至在章末探讨了对数字进行抽象的可能性。

首先描述了伪·中缀表达式的结构，并且构造`numbered?`函数用来判断一个表达式是不是“良构”的。之所以是伪·中缀式，是因为在书中的描述性定义中，并不允许平行的运算符（例如'(1 + 2 + 3)），换句话说就是没有所谓的优先级和结合性。

```:Scheme
(define numbered?
  (lambda (aexp)
    (cond ((atom? aexp) (number? aexp))
          ((atom? (car (cdr aexp))) (and (numbered? (car aexp)) (numbered? (car (cdr (cdr aexp))))))
          (else #f))))
```

书P.101给出的简化版本过分简化了，针对形如`'(1 (1 + 2) 3)`这样的式子会给出假正结果。但是我写的这个也不是很好，遇到形如`'(1)`这样的式子，直接cdr是不可以的。暂时不管了。

现在可以编写对伪·中缀表达式进行求值的`value`函数了。

```:Scheme
(define value
  (lambda (aexp)
    (cond ((atom? aexp) aexp)
          ((eq? (car (cdr aexp)) '+)
           (+ (value (car aexp)) (value (car (cdr (cdr aexp))))))
          ((eq? (car (cdr aexp)) '-)
           (- (value (car aexp)) (value (car (cdr (cdr aexp))))))
          ((eq? (car (cdr aexp)) '*)
           (* (value (car aexp)) (value (car (cdr (cdr aexp))))))
          ((eq? (car (cdr aexp)) '/)
           (/ (value (car aexp)) (value (car (cdr (cdr aexp))))))
          (else (display "Unexpected operator")))))

(value '((1 / 3) - (1 / 4)))
```

DrRacket是一款非常棒的IDE。上面计算$\dfrac{1}{3}-\dfrac{1}{4}$甚至可以直接在输出窗口中给出$\dfrac{1}{12}$的答案，并且是像LaTex渲染出来的这种自然显示的形式。

读到这里，我是非常感动的。当年用C语言写中缀式解析器的时候，耗费了那么多的精力，如今使用LISP只需要短短的几行就可以搞定。当然，这是两种语言的内在属性决定的。过程式的C系语言适合处理线性结构，比如数组这种；而函数式的L系语言由于代码数据合一，所以更适合递归地处理树状结构。数学表达式正是典型的树状结构，让L系语言来处理自然是再适合不过了。

下面介绍了如何使`value`函数处理前缀式、后缀式、甚至其他的什么式的方法。或者应该叫“方法论”了，因为这正是SICP在第一章中就强调的“过程抽象”。在工程上广泛使用的OO方法，实际上就是这种关于“抽象”的方法论。

根据前面的描述性定义，不管是何种顺序的表达式，每一个表达式都只有一个操作符和两个操作数，只是他们的位置不同。因此，可将`value`函数中“取操作符”和“取操作数”的步骤抽象为`operator`、`sub-exp-1`和`sub-exp-2`，以后缀式为例：

```:Scheme
(define operator
  (lambda (aexp)
    (car (cdr (cdr aexp)))))

(define sub-exp-1
  (lambda (aexp)
    (car aexp)))

(define sub-exp-2
  (lambda (aexp)
    (car (cdr aexp))))
```

然后就可以写出“通用”的`value`函数：

```:Scheme
(define value
  (lambda (aexp)
    (cond ((atom? aexp) aexp)
          ((eq? (operator aexp) '+)
           (+ (value (sub-exp-1 aexp)) (value (sub-exp-2 aexp))))
          ((eq? (operator aexp) '-)
           (- (value (sub-exp-1 aexp)) (value (sub-exp-2 aexp))))
          ((eq? (operator aexp) '*)
           (* (value (sub-exp-1 aexp)) (value (sub-exp-2 aexp))))
          ((eq? (operator aexp) '/)
           (/ (value (sub-exp-1 aexp)) (value (sub-exp-2 aexp))))
          (else (display "Unexpected operator")))))

(value '((1 3 /) (1 4 /) -))
```

当然，`value`函数的各部分甚至可以进一步抽象，例如运算符及其行为定义等。第八章将介绍这件事情。

本章的最后，介绍了一种使用Scheme列表对数字进行编码的方法，并且基于此重新定义了常用的运算。其实，丘奇也曾经在lambda演算的框架内做过同样的工作，即著名的[丘奇编码](https://en.wikipedia.org/wiki/Church_encoding)。

另外，P.109所说的“小心阴影”，我的理解是，在构建抽象的过程中，要时刻注意体系的“一致性”。例如书中给的例子：使用list来表示数字的时候，`lat?`函数立刻就不可用了。在《计算的本质》中，更是采取某些措施将proc表达的丘奇编码同原生的Ruby代码联系起来，以维护丘奇编码同Ruby的“一致性”。技术上来说，就涉及到很多设计模式方面的问题。设计模式我不懂，大概就是这个意思。这里的“阴影”，现在看来应当是隐藏在无类型λ演算背后的“类型”问题。

## 第七章

本章实现集合——整个现代数学的基石。

集合在本章称为set。之所以不直接称为“集合”，是因为collection这个词也具有类似的意义。一般来说，collection比set具有更广泛的意义，例如Java的collection容器就包含set。set多指真正意义上的元素不可重复的“集合”，因此下文统一使用“集合”一词指代元素不可重复的集合。

为了突出本质问题，避免讨论细枝末节，一般使用lat表示集合，不考虑list的嵌套。首先实现谓词`set?`，用来判断一个列表是不是集合：

```:Scheme
(define set?
  (lambda (set)
    (cond ((null? set) #t) ;空集是集合
          ((member? (car set) (cdr set)) #f) ;定义在第二章
          (else (set? (cdr set))))))
```

随后定义`makeset`函数，用来将一个包含重复元素的lat转换为集合：

```:Scheme
(define makeset
  (lambda (lat)
    (cond ((null? lat) '())
          ((member? (car lat) (cdr lat)) (makeset (cdr lat)))
          (else (cons (car lat) (makeset (cdr lat)))))))
```

当然，也可以用前面实现过的`multirember`函数来构造这个函数。

下面实现集合的三种基本运算——交、并、补，以及一些判断集合之间关系的谓词。首先写判断集合之间包含关系的谓词`subset?`：

```:Scheme
(define subset?
  (lambda (set1 set2)
    (cond ((null? set1) #t) ;空集是任何集合的子集
          ((member? (car set1) set2) (subset? (cdr set1) set2))
          (else #f))))
```

利用`subset?`即可写出判断两个集合是否相同的`eqset?`：

```:Scheme
(define eqset?
  (lambda (set1 set2)
    (and (subset? set1 set2) (subset? set2 set1))))
```

判断两个集合是否有相交的元素：

```:Scheme
(define intersect?
  (lambda (set1 set2)
    (cond ((null? set1) #f)
          ((member? (car set1) set2) #t)
          (else (intersect? (cdr set1) set2)))))
```

交集、并集、相对差集：

```:Scheme
(define intersect
  (lambda (set1 set2)
    (cond ((null? set1) '())
          ((member? (car set1) set2) (cons (car set1) (intersect (cdr set1) set2)))
          (else (intersect (cdr set1) set2)))))

(define union
  (lambda (set1 set2)
    (cond ((null? set1) set2)
          ((not (member? (car set1) set2)) (cons (car set1) (union (cdr set1) set2)))
          (else (union (cdr set1) set2)))))

(define rel-complement
  (lambda (set1 set2)
    (cond ((null? set1) '())
          ((member? (car set1) set2) (rel-complement (cdr set1) set2))
          (else (cons (car set1) (rel-complement (cdr set1) set2))))))
```

下面这个函数有一种“reduce”的感觉。实现函数`intersectall`，该函数接收由集合组成的列表作为参数，返回各集合的交集：

```:Scheme
(define intersectall
  (lambda (lset)
    (cond ((null? (cdr lset)) (car lset)) ;列表只剩一个集合
          (else (intersect (car lset) (intersectall (cdr lset)))))))
```

在这之后，定义了“pair”和“rel”，实际上就是有序对和二元关系，并在此基础上定义了**函数**。引入函数概念之后，最为精彩的第八、九、十章就要开始了。“智商不够用了吧~”

## 第八章

尾递归就是Continuation Passing Style。因为尾递归可以避免回溯，但代价是每次递归调用，都会将运行时信息通过参数进行传递，造成代码可读性降低。为了加深理解，现在从最简单的阶乘出发，看一看一般递归、尾递归和CPS的代码的运行轨迹。

```:Scheme
(define fac-r
  (lambda (n)
    (cond ((zero? n) 1)
          (else (* n (fac-r (- n 1)))))))

(define fac-tr
  (lambda (n product)
    (cond ((zero? n) product)
          (else (fac-tr (- n 1) (* n product))))))

(define fac-cps
  (lambda (n cont)
    (cond ((zero? n) (cont 1))
          (else (fac-cps (- n 1)
                         (lambda (res)
                           (cont (* n res))))))))
```

与`fac-r`相比就会发现，`fac-tr`参数的迭代都遵循一个减少一个累加的规律，不同的是，`fac-tr`通过尾递归返回值的累乘获得结果，而`fac-cps`是通过Continuation的“累积”，获得完整的计算步骤，最终一次性得到计算结果。这种将Continuation作为参数的编程风格，就是CPS。

CPS的好处是通过前述变换可以将一般递归化为（比较容易实现的）尾递归，但并不会减少算法的时空复杂度。CPS只不过是将调用栈上的过程积累转嫁到参数的堆上面了。并且CPS的思路*c*比正常的递归思路*r*要抽象得多，CPS的代码往往难以阅读。但由于形如`fac-tr`的迭代式尾递归有时候难以实现，尤其是Scheme的`call/cc`可以自动执行CPS变换过程，由此带来的便利性以及CPS本身的尾递归性质，给了可读性差的CPS以用武之地。

CPS可以传递不止一条控制流。维基百科中给出一个乘法的例子，利用两个Continuation参数实现了错误处理。CPS与异常处理、异步编程等技术的关系非常密切，callback函数实际上就是一种Continuation。

以下是书中的例子。

```:Scheme
(define multirember&co
  (lambda (a lat col)
    (cond ((null? lat)
            (col '() '()))
          ((eq? (car lat) a)
            (multirember&co a
                            (cdr lat)
                            (lambda (newlat seen)
                              (col newlat
                                   (cons (car lat) seen)))))
          (else
            (multirember&co a
                            (cdr lat)
                            (lambda (newlat seen)
                              (col (cons (car lat) newlat)
                                   seen)))))))

(define a-friend
  (lambda (x y)
    (cons x (cons y '()))))

(define new-friend
  (lambda (newlat seen)
    (col newlat
         (cons (car lat) seen))))

(multirember&co 'a '(a b c d a b) a-friend)

(define collector
  (lambda (L R L&R Ln Rn)
    (cons L (cons R (cons L&R (cons Ln (cons Rn '())))))))

(define multiinsertLR
  (lambda (new oldL oldR lat col)
    (cond ((null? lat) (col '() '() '() 0 0))
          ((eq? (car lat) oldL)
             (multiinsertLR new
                            oldL
                            oldR
                            (cdr lat)
                            (lambda (L R L&R Ln Rn)
                              (col (cons new (cons oldL L))
                                   (cons oldL R)
                                   (cons new (cons oldL L&R))
                                   (+ Ln 1)
                                   Rn))))
          ((eq? (car lat) oldR)
             (multiinsertLR new
                            oldL
                            oldR
                            (cdr lat)
                            (lambda (L R L&R Ln Rn)
                              (col (cons oldR L)
                                   (cons oldR (cons new R))
                                   (cons oldR (cons new L&R))
                                   Ln
                                   (+ Rn 1)))))
          (else
             (multiinsertLR new
                            oldL
                            oldR
                            (cdr lat)
                            (lambda (L R L&R Ln Rn)
                              (col (cons (car lat) L)
                                   (cons (car lat) R)
                                   (cons (car lat) L&R)
                                   Ln
                                   Rn)))))))


(multiinsertLR '0 'l 'r '(l r l r l) collector)

(define reduce
  (lambda (list func)
    (cond ((null? list) (func 0 0))
          (else (func (car list)
                      (reduce (cdr list) func))))))

(reduce '(1 2 3) +)

(define evens-only*&co
  (lambda (list col)
    (cond ((null? list) (col 1 0 '()))
          ((atom? (car list))
            (cond ((even? (car list))
                   (evens-only*&co (cdr list)
                                   (lambda (PE SO EList)
                                     (col (* (car list) PE)
                                          SO
                                          (cons (car list) EList)))))
                  (else
                    (evens-only*&co (cdr list)
                                    (lambda (PE SO Elist)
                                      (col PE
                                           (+ (car list) SO)
                                           EList))))))
          (else (evens-only*&co (car list)
                                (lambda (PE SO EList)
                                   (evens-only*&co (cdr list)
                                                   (lambda (dPE dSO dEList)
                                                     (col (* PE dPE)
                                                          (+ SO dSO)
                                                          (cons EList dEList))))))))))
(define coll
  (lambda (L R L&R)
    (cons L (cons R (cons L&R '())))))

(evens-only*&co '((1 2 3) (4 5 6)) coll)

;一个简单的例子
(define sum
  (lambda (n col)
    (cond ((zero? n) (col 0))
          (else (sum (- n 1)
                     (lambda (s)
                       (col (+ n s))))))))

(sum 100 (lambda (x) x))

(define fib
  (lambda (n cont)
    (cond ((= n 0) (cont 1))
          ((= n 1) (cont 1))
          (else (fib (- n 1)
                     (lambda (res1)
                       (fib (- n 2)
                            (lambda (res2)
                              (cont (+ res1 res2))))))))))

(fib 6 (lambda (x) x))
```

## 第九章

本章一开始给出了一个与以往都不同的函数。这个函数并不会像以往的函数那样，每次都是固定地取输入参数的“一部分”进行递归，最终到达递归终止条件；而是在递归过程中不仅不缩小参数的规模，甚至连执行路径都受到输入参数的控制。这个函数是这样的：

```:Scheme
(define looking
  (lambda (a lat)
    (keep-looking a (pick 1 lat) lat)))

(define keep-looking
  (lambda (a sorn lat)
    (cond ((number? sorn) (keep-looking a (pick sorn lat) lat))
          (else (eq? sorn a)))))
```

我第一次读到这里的时候，并没有什么特别的想法，甚至有点蒙：构造这个函数究竟是想说明什么？读到后面的停机问题才反应过来：这个`keep-looking`不就是一台**图灵机**吗！甚至可以给这个问题改写成（伪）MIPS汇编：

```
.data 0x0000
    lat .lat  (6,2,4,c,5,7,3)
    a   .atom c

.text 0x0000
start:
    xor $t1,$t1,$t1    #偏移量计数清零
    la  $a0,a(0)       #读参数a到参数寄存器
keep_looking:
    la  $t0,lat($t1)   #读第$t1个原子到$t0
    bat $t0,atom_comp  #如果是原子，则跳转到atom_comp标签
    add $t1,$t0,0      #如果是数字，则将$t1修改为刚刚读到的$t0
    j   keep_looking   #重新开始keep_looking
atom_comp:
    bae $a0,$t0,true   #若是与参数a一致的原子，则跳转到true标签
    ret #f             #如果不一致，则“返回”#f
true:
    ret #t             #返回#t
```

当然，这都是瞎编的，只是想说明`keep-looking`表现出的行为明显是一台图灵机的样子。之所以将`keep-looking`这个过程称之为“函数”，是因为可以将它看做是一个系统，这个系统对于特定的输入，可以给出特定的输出。

对于某些输入，比如只要把列表`(2,1,a)`传入`keep-looking`，这个函数就会反复检查第一和第二个元素，根本停不下来，无法输出任何结果。这也就是说，诸如此类的函数会选择性地只对某些输入产生输出，它不能解决所有“合乎语法”的问题（也就是侯世达在GEB中提到的良构串和定理的关系）。如果把所有合乎语法的输入视为集合$X$，那么诸如此类的函数只在$X$的真子集$X'$上能产生有效输出，这样的函数就叫**部分函数**。前面讨论的函数对于任何良构的输入都可以在有限的时间内给出结论，这就叫**全函数**。[维基百科](https://en.wikipedia.org/wiki/Partial_function)中给出了定义在整数上的平方根函数的例子，用来说明平方根函数在整数集上的“部分性”。

> 设$f$是$S$到$T$的二元关系。若对$\forall x\in S$，$f(a)=\emptyset$或者$\{b\}$，则称$f$是$S$到$T$的**部分函数**，或者称$S$上的部分函数。部分函数可简称**函数**。若$\mathrm{dom} f=S$，那么$f$是$S$上的**全函数**。[1]

最极端的部分函数是对于一切输入都不能给出结果的`eternity`函数，是这样定义的：

```:Scheme
(define eternity
  (lambda (x)
    (eternity x)))
```

运行的话会很快爆栈的。

但是，像`eternity`这样的无限循环，其实是很有用的。比如说，操作系统实际上就是一个无限循环。另外，如果一门语言可以实现无限循环，意味着这门语言是图灵完备的。事实上，图灵机可计算的函数就是部分递归函数，而不是全函数。

## 第十章

这一章实现了有限的Scheme解释器。关于解释器的实现细节，书中讲得很清楚，也没有什么难点，所以只记下书中的代码。这章的重点是展示了Scheme作为元语言的潜力——我们可以、并且很容易使用Scheme设计自己的语言。Racket的设计目标之一就是“to serve as a platform for language creation, design, and implementation”。[[*]](http://docs.racket-lang.org/guide/languages.html)

```:Scheme
#lang racket

(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

(define build
  (lambda (s1 s2)
    (cons s1 (cons s2 '()))))

(define first
  (lambda (list-pair)
    (car list-pair)))

(define second
  (lambda (list-pair)
    (car (cdr list-pair))))

(define third
  (lambda (list-pair)
    (car (cdr (cdr list-pair)))))

(define new-entry build)

(define lookup-in-entry-help
  (lambda (name names values entry-f)
    (cond ((null? names) (entry-f name))
          ((eq? (car names) name) (car values))
          (else (lookup-in-entry-help name (cdr names) (cdr values) entry-f)))))

(define lookup-in-entry
  (lambda (name entry entry-f)
    (lookup-in-entry-help name (first entry) (second entry) entry-f)))

(define extend-table cons)

(define lookup-in-table
  (lambda (name table table-f)
    (cond ((null? table) (table-f name))
          (else (lookup-in-entry name
                                 (car table)
                                 (lambda (n)
                                   (lookup-in-table n
                                                    (cdr table)
                                                    table-f)))))))

(define expression-to-action
  (lambda (e)
    (cond ((atom? e) (atom-to-action e))
          (else (list-to-action e)))))

(define atom-to-action
  (lambda (e)
    (cond ((number? e) *const)
          ((eq? e #t) *const)
          ((eq? e #f) *const)
          ((eq? e 'cons) *const)
          ((eq? e 'car) *const)
          ((eq? e 'cdr) *const)
          ((eq? e 'null?) *const)
          ((eq? e 'eq?) *const)
          ((eq? e 'atom?) *const)
          ((eq? e 'zero?) *const)
          ((eq? e 'add1) *const)
          ((eq? e 'sub1) *const)
          ((eq? e 'number?) *const)
          (else *identifier))))

(define list-to-action
  (lambda (e)
    (cond ((atom? (car e))
           (cond ((eq? (car e) 'quote)  *quote)
                 ((eq? (car e) 'lambda) *lambda)
                 ((eq? (car e) 'cond)   *cond)
                 (else *application)))
          (else *application))))

(define meaning
  (lambda (e table)
    ((expression-to-action e) e table)))

(define value
  (lambda (e)
    (meaning e '())))

(define *const
  (lambda (e table)
    (cond ((number? e) e)
          ((eq? e #t) #t)
          ((eq? e #f) #f)
          (else (build 'primitive e)))))

(define text-of second)

(define *quote
  (lambda (e table)
    (text-of e)))

(define initial-table (lambda (name) (car '())))

(define *identifier
  (lambda (e table)
    (lookup-in-table e table initial-table)))

(define *lambda
  (lambda (e table)
    (build 'non-primitive (cons table (cdr e)))))

(define table-of first)
(define formals-of second)
(define body-of third)

(define else?
  (lambda (x)
    (cond ((atom? x) (eq? x 'else))
          (else #f))))

(define question-of first)
(define answer-of second)

(define evcon
  (lambda (lines table)
    (cond ((else? (question-of (car lines))) (meaning (answer-of (car lines)) table))
          ((meaning (question-of (car lines)) table) (meaning (answer-of (car lines)) table))
          (else (evcon (cdr lines) table)))))

(define cond-lines-of cdr)

(define *cond
  (lambda (e table)
    (evcon (cond-lines-of e) table)))

(define evlis
  (lambda (args table)
    (cond ((null? args) '())
          (else (cons (meaning (car args) table)
                      (evlis (cdr args) table))))))

(define function-of car)
(define arguments-of cdr)

(define *application
  (lambda (e table)
    (apply (meaning (function-of e) table)
           (evlis (arguments-of e) table))))

(define primitive?
  (lambda (l)
    (eq? (first l) 'primitive)))

(define non-primitive?
  (lambda (l)
    (eq? (first l) 'non-primitive)))

(define apply
  (lambda (fun vals)
    (cond ((primitive? fun)
           (apply-primitive (second fun) vals))
          ((non-primitive? fun)
           (apply-closure (second fun) vals))
          (else (display "Error occured in 'apply'!")))))

(define :atom?
  (lambda (x)
    (cond ((atom? x) #t)
          ((null? x) #f)
          ((eq? (car x) 'primitive) #t)
          ((eq? (car x) 'non-primitive) #t)
          (else #f))))

(define apply-primitive
  (lambda (name vals)
    (cond ((eq? name 'cons)  (cons (first vals) (second vals)))
          ((eq? name 'car)   (car (first vals)))
          ((eq? name 'cdr)   (cdr (first vals)))
          ((eq? name 'null?) (null? (first vals)))
          ((eq? name 'eq?)   (eq? (first vals) (second vals)))
          ((eq? name 'atom?) (:atom? (first vals)))
          ((eq? name 'zero?) (zero? (first vals)))
          ((eq? name 'add1)  (+ 1 (first vals)))
          ((eq? name 'sub1)  (- (first vals) 1))
          ((eq? name 'number?) (number? (first vals)))
          (else (display "Unknown primitive function.")))))

(define apply-closure
  (lambda (closure vals)
    (meaning (body-of closure)
             (extend-table (new-entry (formals-of closure) vals)
                           (table-of closure)))))

(value '((lambda (x) (add1 x)) 2))

```

## 总结

其实没什么好说的了。因为在读完TLS之后（其实是还没读完的时候就开始了）阅读了《可计算性与计算复杂性导论》这本教材，对于Scheme背后的理论知识有了一定的理解。因此，值得记录的一些收获和想法都分散在这些读书笔记和专题文章里面了。文章的前面两章实际上已经起到总结的作用了，所以这里多说无益，不如继续填其他文章的坑。喵。

# 附录2：SICP阅读笔记（2017-08-21）

> 读一点想一点写一点
[http://www.math.pku.edu.cn/teachers/qiuzy/progtech/]()
[http://sicp.readthedocs.io/en/latest/]()

## 第一章：构造过程抽象

### 程序设计的基本元素

任何程序设计语言都必须能够表达**数据**和**过程**。

- **表达式**是Scheme的基本元素，解释器可对其直接求值
- 括号括起来的组合式称为**表**，表示过程调用
- 表的最左元素是运算符，其余元素为其参数
- “组合式”与“表”是同义词，每个表都可通过求值得到返回值
- `define`是最简单的抽象手段，它建立名字到对象的映射

由于存在名字到实际对象的映射关系，解释器必须维护**环境**。

对组合式求值的步骤是递归的，有两种顺序：

- 正则序：先进行子表代换，最后进行求值。可以视为一种“深度优先”的求值策略。
- 应用序：先对子表求值，然后调用过程。可以视为一种“广度优先”的求值策略。

应用序可以避免重复求值。

求值顺序会影响某些表达式的结果。

返回布尔值的过程称为**谓词**。`and`、`or`和`not`三个谓词组成完备集，其中`and`和`or`支持多于两个参数，并采用惰性求值策略。这意味着`and`和`or`是Scheme的固有语法，而`not`是普通过程。`cond`和`if`是另外两个固有过程，均采用惰性求值。

### 实例：牛顿迭代法

牛顿迭代法是方程数值解法的一种。利用自顶向下的方法，写出牛顿法求平方根的算法如下：

```:Scheme
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.0001))

(define (square x) (* x x))

(sqrt-iter 1.0 2.0)
```

这个例子展示了①通过递归可实现循环迭代；②过程作为“黑箱”的性质——用户不需要关心其内部实现，只要两个黑箱在相同的输入下有相同的输出，即认为黑箱是（外特性）等效的。借由过程封装，可实现程序结构的层次化。

### Ex1.3 求最大和

现在需要定义一个过程`(max-sum x y z)`，该过程接受3个参数，并返回最大的两个数之和。

传统的方法很无聊，所以深入思考一下：三个数只有三个和，这就是说，只需要找到最小的那个数就好了。

如果假定**最左边**的参数`x`是最小的，那么`max-sum`过程就是这样的：

```:Scheme
(define (max-sum x y z)
  (if (and (<= x y) (<= x z))
      (+ y z)
      (...)))
```

如果y或者z是最小的呢？完全可以再套两层if。但上面加粗的“**最左边**”三个字暗示着：这个最小值只与它在参数列表的位置有关。所以可以将整个参数列表**左移**，以观察下一个数是不是最小的。继续这个左移过程，总会遇到一个数是最小的。因此，省略号的位置就可以写成

```:Scheme
(max-sum y z x)
```

这是一个递归调用。这个例子暗示（或者明示？）着选择结构、循环和递归的**同构**关系。在Scheme中，递归形式显然更优雅。（补充：虽然形式上是递归形式，但本质上是迭代的。参见Ex1.11。）

除此之外，这个例子也暗示着参数名称是无关紧要的这一规则。

这个方法非常机智，但并不是自己想出来的，而是受到启发才学到的（原始链接找不到了……以后补上），特此记录。还有，据说中文书中翻译有误，题目要求的是最大平方和而不是中文书的最大和，但这不重要，懒得改了。

### Ex1.4 作为数据的运算符

```:Scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

这体现了“程序即数据”的思想。

### Ex1.5 检测求值顺序

为检测解释器的求值顺序，执行以下代码：

```:Scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))
```

如果采用正则序求值（即先代换展开，最后求值归约），或者应用序求值（每一步代换后都立即求值可求值部分），则执行效果如何？

首先可注意到`p`是一个很奇怪的存在：它被定义为它自身。这会导致每次归约`p`都会得到`p`本身。

如果采用正则序，则求值步骤如下：

```:Scheme
;原表达式
(test 0 (p))
;代换
(if (= 0 0) 0 (p))
;直接可得到第一分支
0
```

但如果采用应用序：

```:Scheme
;原表达式
(test 0 (p))
;对可归约的(p)进行归约
(test 0 (p))
;又回来了
```

陷入了无尽的代换。实际执行就会发现，真的卡住了，说明Scheme是采用应用序求值。

### Ex1.6 if作为固定语法的必要性

```:Scheme
(define (new-if p a b)
  (cond (p a)
        (else b)))
        
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
          
(sqrt-iter 1.0 2.0)
```

对`(sqrt-iter 1.0 2.0)`进行求值，采用默认的应用序，则求值过程为：

```:Scheme
1. (sqrt-iter 1 2)
2. (new-if (good-enough? 1 2)
           1
           (sqrt-iter (improve 1 2) 2))
3. (new-if #x
           1
           (sqrt-iter 1.5 2))
4. (new-if #x
           1
           (new-if (good-enough? 1.5 2)
                   1.5
                   (sqrt-iter (improve 1.5 2) 2)))
5. (new-if #x
           1
           (new-if #x
                   1.5
                   (sqrt-iter 1.4167 2)))
6. ...
```

可见，由于应用序求值总是倾向于归约所有可求值子表，因此每轮求值都会**不顾**谓词的取值而强行展开所有子句。如果使用正则序，则结果更加显然：每轮求值都是**不顾**谓词的取值而代换掉`new-if`，而`new-if`展开式中重复出现`sqrt-iter`，导致这个过程无穷无尽。

问题的根源在于`if`的求值顺序依赖于谓词子句的取值，Scheme将其作为固定语法，不受默认求值顺序的束缚。这些不按套路出牌的特殊形式，可以说是一门语言的基石，在众生平等的函数式编程世界，也需要有一些特殊的规则。

%%The Little Schemer%%里面引用了乔治·奥威尔的一句话：

> All animals are equal, but some animals are more equal than others.

就是这个道理。

### Ex1.9 迭代与递归

现有两种实现加法函数的方式：

```:Scheme
;递归的
(define (plus-r a b)
  (if (= a 0)
      b
      (inc (plus-r (dec a) b))))

;迭代的
(define (plus-i a b)
  (if (= a 0)
      b
      (plus-i (dec a) (inc b))))
```

展开可以发现两者的特性：`plus-r`延缓了`inc`的求值，`plus-i`则每次递归调用时都会修改`a`和`b`两个参数。

根据以往对Church encoding的了解，所谓的加法，其实可以理解为“+1”的多次迭代，这与对乘法和乘方等“高阶”运算的理解是类似的。“+1”实际上就是皮亚诺公理的“后继”操作。

### Ex1.10 Ackermann函数

这个东西蛮无聊的，最后总结起来就是乘2、2的幂，以及超幂，等等。

### 树形递归

最典型的就是斐波那契数列：

```:Scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

容易改写成迭代方式。

但是有一类问题，它们的子问题与问题本身遵循相同的求解规则，这类问题就适合采用递归的方式去解决。问题：现有足够多的1、5、10、25、50五种面值的硬币，为了将100换成零钱，有多少种可能的组合方案？

按照生活习惯，一般都是从最大面值的零钱开始换起，这也是为达到零钱数最少的局部最优结果而采取的贪心策略。实际上，100元换零钱的方式中，可以分为“有x元”的方案和“没有x元”的方案，并且容易知道，总的方式数等于**不用x元的方案总数**加上**用全部种类的硬币换剩余( 100 - x )元的方案总数**。如果换0元钱，视为有1种方案；如果硬币种类数为0，视为有0种方案。

记：

- 现金总数为`a`（amount）
- 使用的硬币种类数为`k`（kinds-of-coins）
- `k`种硬币最大的硬币面值`(max k)`，事实上可以不是最大面值，为理解方便，定为最大面值
- 使用`k`种硬币组合成`amount`元现金的方案数为`(N k a)`

则可以记约定如下：

- `(N 0 a) = 0`，即用0种硬币的找零方案为0种；
- `(N k 0) = 1`，即0元的兑换方案为1种；
- `(N k <负数>) = 0`
- `(N 1 a) = 1`，即只用1元换任何数额的零钱都只有一种方案。

并且知道：

```:Scheme
;用不规范的写法
(N k a) = (N (k-1) a) + (N k (a-(max k)))
```

至此立刻可以用Scheme写出`N`的定义：

```:Scheme
(define (N k a)
  (cond ((= a 0) 1)
      ((or (< a 0) (= k 0)) 0)
      (else (+ (N (- k 1) a)
             (N k (- a (max k)))))))

(define (max k)
  (cond ((= k 1) 1)
      ((= k 2) 5)
      ((= k 3) 10)
      ((= k 4) 25)
      ((= k 5) 50)))

(N 5 100)
```

实际运行结果是292，此为正确答案。

但是希望采用迭代的方式解决此问题，为此，考察`(N k a)`的求值规律。不妨以方便的形式将`N`记为N(k,a)，尝试根据上面的递推式求几个值：

|k=1 {1}|k=2 {1,5}|k=3 {1,5,10}|
|-----|
|N(1,1)=1|**N(2,1)**=N(1,1)+N(2,(1-5))=1+0=1||
|N(1,2)=1|N(2,2)=N(1,2)+N(2,(2-5))=1+0=1||
|N(1,3)=1|N(2,3)=N(1,3)+N(2,(3-5))=1+0=1||
|N(1,4)=1|N(2,4)=N(1,4)+N(2,(4-5))=1+0=1||
|N(1,5)=1|**N(2,5)**=N(1,5)+N(2,(5-5))=1+1=2|**N(3,5)**=N(2,5)+**N(3,(5-10))**=2+0=2|
|**N(1,6)**=1|N(2,6)=**N(1,6)**+**N(2,(6-5))**=1+1=2||
|N(1,10)=1|N(2,10)=N(1,10)+**N(2,(10-5))**=1+2=3|N(3,10)=N(2,10)+**N(3,(10-10))**=3+1=4|

写了这些，大概就可以看出后面结果对前面结果的依赖。这反映了“子问题”与原始问题的同构性质，适合采取动态规划的算法迭代地解决。

### Ex1.11 递归风格与迭代风格的转换

受书中Fib递归写法的启发，解决了这道题。Scheme代码如下：

```:Scheme
;递归
(define (f-r n)
  (cond ((< n 3) n)
        (else (+ (f-r (- n 1)) (* 2 (f-r (- n 2))) (* 3 (f-r (- n 3)))))))

;迭代
(define (f-i n s1 s2 s3)
  (cond ((= n 0) s1)
        (else (f-i (- n 1) s2 s3 (+ (* 3 s1) (* 2 s2) s3)))))

;逐个打印
(define (show n)
  (display (f-r n))
  (display "  ")
  (display (f-i n 0 1 2))
  (newline)
  (if (= n 0)
      (display "Done!")
      (show (- n 1))))

(display "recur")
(display "  ")
(display "iter")
(newline)
(show 15)
```

输出结果：

```:Scheme
recur iter
142717  142717
60104 60104
25315 25315
10661 10661
4489  4489
1892  1892
796 796
335 335
142 142
59  59
25  25
11  11
4 4
2 2
1 1
0 0
Done!
```

套路总结：这类问题总是能隐约嗅到“卷积”“时域平移”的味道。系统每一时刻的状态都由以前的状态决定。这类系统好像有个名字来着，忘记了。反正就是，在操作上，有非常明显的“平移”特征。如果以寄存器的思维方式来思考这个问题，由于系统的状态与之前三个时点的状态有关，所以需要三个寄存器来存储这三个过去状态。计算下一个时点的状态时，只需要利用这个三寄存器的窗口就足够了。画个表格来说明这个问题：

|n|0|1|2|3|4|5|...|
|----------------|
|s1|0|1|2|4|11|25|...|
|s2|1|2|4|11|25|59|...|
|s3|2|4|11|25|59|142|...|

其中s3是从n=1开始依据上一窗口计算出来的最新状态。观察序列可知，s1即为f(n)。

更加概括地说，系统每一时点的状态都依赖于前三个时点的状态，因此①任一时点必须存储3个时点宽度的过往状态；②每一时点的状态实际上是由之前所有状态决定的。因此，需要迭代地计算从f(0)到f(n-1)的所有值。在Scheme中，迭代体现为递归形式。

### Ex1.12 杨辉三角

该题要求读者“计算”出杨辉三角，并没有显式地要求以某种格式输出之。

杨辉三角可以说是常识了。关键问题不在杨辉三角，而在于如何将杨辉三角美观地打印在命令行窗口中。

```:Scheme
(define (yanghui row col)
  (cond ((= col 0) 1)
        ((> col row) 0)
        ((<= col row) (+ (yanghui (- row 1) (- col 1)) (yanghui (- row 1) col)))))

(define (triangle r c)
  (display (yanghui r c))
  (display "  ")
  (cond ((< r c) (display "illegal arg"))
        ((= r 0) (newline))
        ((= c 0) (newline)(triangle (- r 1) (- r 1)) )
        (else (triangle r (- c 1)))))

(triangle 10 10)
```

执行后输出

```
1 10  45  120 210 252 210 120 45  10  1 
1 9 36  84  126 126 84  36  9 1 
1 8 28  56  70  56  28  8 1 
1 7 21  35  35  21  7 1 
1 6 15  20  15  6 1 
1 5 10  10  5 1 
1 4 6 4 1 
1 3 3 1 
1 2 1 
1 1 
1
```

这个递归形式表达的双层循环着实让我想了一会儿。多说一句：杨辉三角的每一项都是二项式系数，即组合数。组合数可以通过阶乘函数计算得到。据此可以迭代地求解出杨辉三角每一个元素，避免递归的低效。懒得做了。

### Ex1.13 斐波那契与黄金分割

这个证明题利用数学归纳法很容易证明。题中gamma等于

$$\gamma = \frac{1-\sqrt{5}}{2}$$

### Ex1.14 换零钱的递归树

可见[http://sicp.readthedocs.io/en/latest/chp1/14.html]()。

### Ex1.16 乘方的快速迭代实现

基于
n为偶数：
$$b^n=(b^{n/2})^2=(b^2)^{n/2}$$
n为奇数：
$$b^n=b(b^{n-1})$$
设计快速迭代求幂算法如下：

```:Scheme
(define (expf b n a)
  (if (= n 0)
      a
      (if (even? n)
          (expf (* b b) (/ n 2) a)
          (expf b (- n 1) (* b a)))))
```

`(expf b n a)`的第一个参数用来保存底数（n为偶数时则平方），第二个参数用来保存迭代计数（即n），第三个参数作为乘积计数器，记录最终结果，其初始值为1。

从以上两式可见，只有当n为奇数时，才会向第三个参数累积之前计算的第一个参数。

> 最近过于纠结习题。明天开始，尽量以主干内容为主，习题可以稍微放一放。

> 并且，应该读一读%%The Little Schemer%%。

### 最大公约数GCD

经典的GCD欧几里得算法：

```:Scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
```

# 附录3：计算续体（Continuation）简介（2017-11-22）

> 本节翻译自[https://www.scheme.com/tspl4/further.html#./further:h3]()

在S-表达式求值过程中，解释器需要持续关注两件事情：

+ 要求值什么
+ 对求得的值做何种处理

我们来思考一下，下列S-表达式中`(null? x)`的求值过程是怎样的：

```:Scheme
(if (null? x) (quote ()) (cdr x))
```

解释器先求值`(null? x)`，然后根据得到的值去求解接下来的`(quote ())`或者是`(cdr x)`。在这个例子中，“要求值的东西”当然是`(null? x)`，对求得的值做的“处理”就是决定求值两个分支中的哪一个，并且求值被选中的分支。我们把“对求得的值所做的后续处理”称为计算过程的“%%continuation%%”。

因此，在任意S-表达式求值过程的任何一个时刻，都有一个待完成的continuation。继续刚才的例子。我们不妨假设`x`的值是`(a b c)`，可以提取出上述表达式的6个continuation，这6个continuation分别需要：

- `(if (null? x) (quote ()) (cdr x))`的值；
- `(null? x)`的值；
- `null?`的值；
- `x`的值；
- `cdr`的值，以及；
- 再次需要`x`的值；

`(cdr x)`的continuation没有写在上面，因为它的continuation就是整个表达式的continuation。

> 因为这整个式子就（可能）是在计算`(cdr x)`

在Scheme中，我们可以使用`call/cc`过程来捕获任一S-表达式的continuation。`call/cc`接受一个单参的函数`p`作为参数，并构造当前continuation作为实际参数传递给`p`的唯一参数。Continuation本身一般以过程`k`表示，每当`k`作用于一个值时，即将该值传递给`call/cc`调用点的continuation，供其调用，并返回此调用的返回值。本质上讲，这个返回值就是`call/cc`调用的返回值。

如果`p`没有调用`k`即返回，那么过程返回的值就是`call/cc`调用返回的值。

考虑下面的几个简单例子：

```:Scheme
(call/cc
  (lambda (k)
    (* 5 4))) → 20 

(call/cc
  (lambda (k)
    (* 5 (k 4)))) → 4 

(+ 2
   (call/cc
     (lambda (k)
       (* 5 (k 4))))) → 6
```

第一个例子中，`call/cc`捕获continuation并将其绑定到`k`，但是`k`没有被调用，所以过程的返回值就是20。第二个例子中，continuation`k`在乘法过程之前被调用，因此整个过程的返回值就是传给`k`的值，也就是4。第三个例子中，continuation包括“+2”的操作，因此整个过程的返回值是`(+ 2 4)`的值，也即6。

下面的例子演示了递归过程的“非本地退出”，没有前面的例子那么简单了。

```:Scheme
(define product
  (lambda (ls)
    (call/cc
      (lambda (break)
        (let f ([ls ls])
          (cond
            [(null? ls) 1]
            [(= (car ls) 0) (break 0)]
            [else (* (car ls) (f (cdr ls)))]))))))

(product '(1 2 3 4 5)) → 120
(product '(7 3 8 0 1 9 5)) → 0
```

所谓的“非本地退出”可以使`product`遇到0时立即返回，不必完成尚未执行的后续步骤。上面的所有continuation调用都返回到各自的continuation位置，而控制流仍然留在被传入`call/cc`的过程`p`中。下面的例子将在过程`p`返回后再使用continuation。

```:Scheme
(let ([x (call/cc (lambda (k) k))])
  (x (lambda (ignore) "hi"))) → "hi"
```

该例中，由`call/cc`捕获的continuation可以这样描述：“将`call/cc`返回值绑定到`x`，然后将`x`的值作用于`(lambda (ignore) "hi")`的值上面”。由于`(lambda (k) k)`原样返回其参数，因此`x`被绑定到continuation上（`x`自己就是continuation）。随后，这段continuation又作用于`(lambda (ignore) "hi")`的值上，结果就是再次对`x`进行绑定，也就是将`(lambda (ignore) "hi")`的值绑定于`x`，并且将其作用于`(lambda (ignore) "hi")`自身。由于`ignore`参数如其名，因此最终返回的就是"hi"。

> 注：这段稍微有点绕，自己再解释一下。对于调用`call/cc`的时刻来说，其后续过程就是函数体中的`(x (lambda (ignore) "hi"))`这段application。然而在let块中，通过`(call/cc (lambda (x) x))`这个原样返回continuation的操作，恰恰将其绑定到continuation里面的`x`上面，这就导致在continuation里面有对自己这个continuation的引用，也即

> ```:Scheme
x := (x (lambda (ignore) "hi"))
```

> 所以执行函数体的时候，求值过程是这样的：

> ```:Scheme
(x (lambda (ignore) "hi"))
;; next
((lambda (□)
   (□ (lambda (ignore) "hi"))) ;这个就是x所代表的那个continuation，这里写成了CPS的形式方便理解。实际上这里是“一等continuation”，并不是单纯的函数。
 (lambda (ignore) "hi"))
;; next
((lambda (ignore) "hi")
 (lambda (ignore) "hi"))
;; next
"hi"
```

下面的这段代码是前一个例子的变形版本，相当难懂。可能很容易就看出来返回的是什么，但要想清楚为什么会返回"HEY!"，就需要好好琢磨琢磨了。

```:Scheme
(((call/cc (lambda (k) k))
  (lambda (x) x))
 "HEY!")
→ "HEY!"
```

在上面的代码中，`call/cc`的返回值是它自己的continuation，此返回值作用在后面的恒等函数上，因而`call/cc`再次返回同样的返回值（也即含有恒等函数的continuation）。随后，恒等函数作用于自身，得到的仍然是恒等函数。最终，恒等函数作用于"HEY!"，得到"HEY!"。

Continuations的使用并不都是这样难以理解。请看下面的`factorial`函数，此函数在返回出口值“1”之前捕获到后续的continuation，并将其赋值到顶层变量`retry`上。代码如下：

```:Scheme
(define retry #f) 

(define factorial
  (lambda (x)
    (if (= x 0)
        (call/cc (lambda (k) (set! retry k) 1))
        (* x (factorial (- x 1))))))
```

根据此定义，`factorial`可以正常计算阶乘，但同时有赋值`retry`的副作用。

```:Scheme
(factorial 4) → 24
(retry 1) → 24
(retry 2) → 48
```

可以这样描述绑定于`retry`的continuation：“将所需的值乘以1，然后继续对结果乘以2、3、4”（也就是`(lambda (res) (* 4 (* 3 (* 2 (* 1 res)))))`）。假如我们为这个continuation提供一个不同于1的值，这样就相当于改变了阶乘的递归出口值并导致不同的计算结果，比如：

```:Scheme
(retry 2) → 48
(retry 5) → 120
```

利用`call/cc`的这种机制，可以基于它实现一个断点工具包。每当遇到断点，都会保存断点处的continuation，这样即可实现从断点处恢复计算的功能。（如果需要的话，可以设置不止一个断点。）

利用continuation，还可以实现各种形式的多任务系统。下面的代码定义了一个简单的“轻量级进程”系统，该系统允许多个进程进入系统运行。由于系统是**非抢占式**的，因此每个进程必须时不时地自觉“暂停”自己，以允许其他进程运行。实现如下：

```:Scheme
(define lwp-list '())
;'
(define lwp
  (lambda (thunk)
    (set! lwp-list (append lwp-list (list thunk))))) 

(define start
  (lambda ()
    (let ([p (car lwp-list)])
      (set! lwp-list (cdr lwp-list))
      (p))))

(define pause
  (lambda ()
    (call/cc
      (lambda (k)
        (lwp (lambda () (k #f)))
        (start)))))
```

下面的几个轻量级进程按顺序执行、无限循环，打印出无限长度的"hey!\n"字符串。

```:Scheme
(lwp (lambda () (let f () (pause) (display "h") (f))))
(lwp (lambda () (let f () (pause) (display "e") (f))))
(lwp (lambda () (let f () (pause) (display "y") (f))))
(lwp (lambda () (let f () (pause) (display "!") (f))))
(lwp (lambda () (let f () (pause) (newline) (f))))
(start) → hey!
          hey!
          hey!
          hey!
          ...
```

> 关于thunk，参见[http://www.ruanyifeng.com/blog/2015/05/thunk.html]()

在[12.11](https://www.scheme.com/tspl4/examples.html#g208)节中，我们使用`call/cc`实现了一个支持抢占式调度的多任务系统“Engine”。

**习题3.3.1** ：请仅使用`call/cc`编写一个无限循环的程序，按顺序打印从0开始的所有自然数。不要使用递归和赋值。

**译者提供的参考实现**

```:Scheme
(define invoke-self
  (lambda (f)
    ((lambda (x)
       ((x f) 0))
     (call/cc (lambda (k) k)))
  ))

(invoke-self (lambda (f)
               (lambda (n)
                 (display n)(newline)
                 ((f f) (+ n 1)))))
```

译者注：这个函数受到前文中输出“hi”的那个函数的启发。另外，作为`invoke-self`函数参数的那个函数，实际上是构造Y组合子的一个“前体”。这里构造无限循环的思路，正是受到Y组合子的启发。

**习题3.3.2**：不使用`call/cc`，重写`product`函数，保留原有函数功能，即若参数表中有0，则不执行乘法。

**译者提供的参考实现**

```:Scheme
(define product
  (lambda (list)
    (display (car list))(newline)
    (if (null? list)
        1
        (if (= 0 (car list))
            0
            (* (car list) (product (cdr list)))))))
```

**习题3.3.3**：假设由`lwp`创建的轻量级进程运行完毕终止，也就是不调用`(pause)`即退出，会发生什么现象？请定义`quit`函数，使得进程在不影响lwp系统的情况下正常终止。注意处理系统中只有一个进程的情况。

**修改后的一个版本（3.3.5也有做）**

```:Scheme
#lang racket
(define lwp-list '())
;'
(define lwp
  (lambda (pid thunk)
    ;(printf "[New Process ~a Interleaved]\n" pid)
    (set! lwp-list (append lwp-list (list thunk)))))

(define start-next
  (lambda ()
    ;(printf "[Start next]\n")
    (let ([p (car lwp-list)])
      (set! lwp-list (cdr lwp-list))
      (p))))

(define wait-this-and-start-next
  (lambda (pid)
    ;(printf "[Process ~a Waiting]\n [Going to interleave Continuation of ~a]\n" pid pid)
    (call/cc
      (lambda (k)
        (lwp pid (lambda () (k #t)))
        (start-next)))))

(define quit
  (lambda (return v)
    (printf "\n[Process ~a Terminated]\n" (car v))
    (if (null? lwp-list)
        (return (car (cdr v)))
        (start-next))))

(printf "\nLWP:Returned to ENV with ~a"
(call/cc (lambda (return) (

(lwp 200
     (lambda ()
       (let this ((x 0) (pid 200))
            (wait-this-and-start-next pid)
            (printf "Process[~a] Running\n" pid)
            (printf "运行计数~a\n" x)
            (if (= x 20)
                (quit return (list pid x))
                #f)
            (this (+ x 1) pid))))

(lwp 300
     (lambda ()
       (let this ((x 0) (pid 300))
            (wait-this-and-start-next pid)
            (printf "Process[~a] Running\n" pid)
            (printf "运行计数~a\n" x)
            (cond ((= x 10) (printf "加入新进程404\n")
                            (lwp 404
                                 (lambda ()
                                   (let f ((y 0) (pid 404))
                                        (wait-this-and-start-next pid)
                                        (printf "Forked Process: ~a\n" y)
                                        (if (= y 2)
                                            (quit return (list 404 888))
                                            #f)
                                        (f (+ 1 y) pid))))
                            (quit return (list pid x)))
                  (else #f))
            (this (+ x 1) pid))))

(start-next)
))))
```

**习题3.3.4**：在lwp系统中，每次调用`lwp`创建新进程，都会复制一遍进程表`lwp-list`，因为在先前的实现中使用了`append`函数将新进程添加到进程表。请用[2.9](https://www.scheme.com/tspl4/start.html#g40)节实现的队列结构，修改原有的lwp代码，以避免这个问题。

**习题3.3.5**：lwp系统支持动态创建新进程。正文中没有给出例子，所以请你设计一个进程动态创建的实际应用，并且使用lwp系统将其实现出来。

# 附录4：阴阳问题分析（2018-02-11）

阴阳问题（Yin-yang Puzzle）是法国人David Madore设计的一段小程序，用来展示程序语言中“Continuation”的概念。这位大佬在自己设计的基于组合子的语言“Unlambda”的主页上写道：

> Your Functional Programming Language Nightmares Come True

emmm...阴阳问题的确比较令人费解，难倒了不少初学者，当然也包括我。查阅了一些资料，结合自己使用脑内虚拟机仔细模拟之后，终于稍稍理解了一点。因此写下这篇文章，用来记录自己对此问题的解析和理解。

**什么是阴阳问题**

阴阳问题是一段短小的、无限循环的程序。其Scheme代码如下：

```:Scheme
(let* ((yin
         ((lambda (cc) (display #\@) cc) (call/cc (lambda (c) c))))
       (yang
         ((lambda (cc) (display #\\*) cc) (call/cc (lambda (c) c)))))
    (yin yang))
```

运行此程序，理论上会输出无穷长的“@\*..”序列。实际输出的序列长度，与实现阴阳问题的语言和运行环境（例如栈空间）有关。

```
@*@**@***@****@*****@******@...
```

尽管阴阳问题的代码十分短小，但却使用了两次`call/cc`，这就使程序的执行面貌变得难以理解。`call/cc`是Scheme的特色，它可以显式地捕获程序在某一位置的上下文环境，即continuation，并保存为一等continuation，供程序员随时调用。有了对一等continuation的支持，Scheme就可以随心所欲地控制程序的执行顺序，实现多重循环跳出、协程、异常处理等普通的递归程序难以实现的功能。从面向问题的角度看。continuation和`call/cc`是很容易理解的，因为它将程序控制流封装起来，是高度抽象的。但是从面向执行的角度看，程序的执行面貌，就变得复杂了许多。

下文从理解`call/cc`开始，逐步解析阴阳问题的执行细节。

**理解call/cc**

call/cc，全称call-with-current-continuation，可以捕获程序运行到call/cc时候的continuation。在Racket或者Scheme中，`call/cc`接受一个单参函数作为它的参数，也就是`(call/cc (lambda (k) body))`的形式。之所以选用字母k，是因为`call/cc`会把取得的continuation传给`k`，然后在`body`中使用它。一旦`body`中**有调用**`k`，则整个call/cc返回的结果就是continuation的执行结果，而与`body`中的其他计算无关（因此这一特性可以用来打断点）；如果`body`中**没有调用**`k`，那么call/cc返回的结果就是`body`的值。

在[*Scheme and the art of programming*](http://www.doc88.com/p-7029536419237.html)一书中，以一整个章节讲了continuation和call/cc，据说是讲continuation讲得最透彻的一本书。此书将continuation的行为描述为一个“escaper”，相当贴切的一个词。根据各位逻辑学大佬的想法，在经典lambda演算中，是没有办法实现跳出动作的，所以说它很特殊。

我们可以利用call/cc和恒等函数，构造一个常用形式（如下），用来获取调用时刻的continuation：

```:Scheme
(call/cc (lambda (k) k))
```

有了这个常用形式之后，我们考虑下面这个例子，用来热身（[例子出处](https://www.scheme.com/tspl4/further.html)）：

```:Scheme
(((call/cc (lambda (x) x))
  (lambda (x) x)) "Hey")
```

其输出是“Hey”。这段代码中，用到了上面所说的特殊形式，于是整个程序的功能就是：用恒等函数去调整个程序的continuation，然后用结果去调“Hey”，其实也就是用整个程序的continuation去调“Hey”。当调用`call/cc`的时候，`call/cc`创造了一个新的环境，是这样的：

```:Scheme
((□
  (lambda (x) x)) "Hey")
```

把恒等函数塞进这个continuation挖的坑里面，就是

```:Scheme
(((lambda (x) x)
  (lambda (x) x)) "Hey")
```

到这里，就很容易知道结果是“Hey”了。后文中的分析，其实也是同样的方法，只是创造出来的平行世界多了一点而已。

维基百科还给了一个例子，我贴在这里：

```:Scheme
;; [LISTOF X] -> ( -> X u 'you-fell-off-the-end)
(define (generate-one-element-at-a-time lst)

  ;; Hand the next item from a-list to "return" or an end-of-list marker
  (define (control-state return)
    (for-each 
     (lambda (element)
               (set! return (call/cc
                              (lambda (resume-here)
                                ;; Grab the current continuation
                               (set! control-state resume-here)
                               (return element)))))
     lst)
    (return 'you-fell-off-the-end))
  
  ;; (-> X u 'you-fell-off-the-end)
  ;; This is the actual generator, producing one item from a-list at a time
  (define (generator)
    (call/cc control-state))

  ;; Return the generator 
  generator)

(define generate-digit
  (generate-one-element-at-a-time '(0 1 2)))

(generate-digit) ;; 0
(generate-digit) ;; 1
(generate-digit) ;; 2
(generate-digit) ;; you-fell-off-the-end
```

要理解这段程序的行为，首先要知道，顶级符号`generate-one-element-at-a-time`是一个闭包，里面维护着`lst`这个在作用域内有效的变量。还要知道，`for-each`函数可以遍历列表的每一个element，那么抽象地说，每次迭代的continuation都包含“尚未看到的”那部分列表。因此，可以使用call/cc获取每次遍历的continuation，动态地控制程序的流向。

当我们调用`generate-one-element-at-a-time`的时候，我们实际上是调用其内部的`generator`也就是`(call/cc control-state)`。我们知道，call/cc的返回值取决于`control-state`内部有没有调用它的参数`return`，我们发现，它确实调用了，并且返回的是当前看到的element。这个`return`的作用，就像命令式语言中的break或者continue（干脆就说return吧）。程序只要运行到`(return element)`，一下子就会跳出call/cc，所以会直接返回element。不考虑其他情况，如果遍历中遇到`(return element)`，那么遍历过程实际上并不能往前移动，因为第一次就会跳出循环。

在这个基础上，为了实现每次得到的值都不一样，既然每次都只能取得列表的第一个值，那么就可以在跳出遍历之前保存当前的continuation。这样，第二次调用`(call/cc control-state)`，实际上就是调用未来的、即将执行的、后续下一步的`control-state`。结合`generate-one-element-at-a-time`的闭包特性，就实现了每次调用都输出下一个值的功能。

---

还有一个例子。考虑比较容易理解的阶乘函数：

```:Scheme
(define retry #f)

(define factorial
  (lambda (x)
    (if (= x 0)
        (call/cc (lambda (k) (set! retry k) 1))
        (* x (factorial (- x 1))))))

(factorial 5) ;返回120，但是有副作用：将continuation保存在retry中
(retry 5)     ;返回600
```

程序运行的时候，从`(factorial 5)`开始，每一步递归都需要计算参数上的`(factorial n-1)`才能求值，于是调用栈上就有了一串`(factorial x)`。当程序运行到`(factorial 0)`的时候，call/cc被触发，当前的计算环境被保存在`retry`中。那么这个环境具体是怎样的呢？看下表

|Stack|Code waiting for<br>value of argument|
|----------|
|(factorial 0)|□|
|(factorial 1)|(* 1 ?)|
|(factorial 2)|(* 2 ?)|
|(factorial 3)|(* 3 ?)|
|(factorial 4)|(* 4 ?)|
|(factorial 5)|(* 5 ?)|

上表实际上就是执行到`(factorial 0)`（但尚未执行完）时由执行环境维护的调用栈，它在调call/cc的时候作为continuation的一部分被保存到`retry`了。表中的问号代表本步骤等待的值，□代表调call/cc时留下的传送门。如果没有call/cc，按照阶乘的算法，这里应该填入数字1；但是既然call/cc为我们留下了传送门，我们就可以自由地选择往这个坑里填什么东西。如果填5，意味着阶乘的初值就是5，执行此continuation也就是展开调用栈之后，得到的结果自然是600。

**解析运行过程**

原来的代码

```:Scheme
(let* ((yin  ((lambda (cc) (display #\@) cc) (call/cc (lambda (c) c))))
       (yang ((lambda (cc) (display #\\*) cc) (call/cc (lambda (c) c)))))
  (yin yang))
```

可以写成

```:Scheme
(let* ((yin  (identity@  (capture/cc1)))
       (yang (identity*  (capture/cc2))))
  (yin yang))
```

> 现在是我们熟悉的-1层世界

从第一对`let*`开始执行：

```:Scheme
;第0个CC：[C0]，是(capture/cc1)的返回值：
(let* ((yin  (identity@  □)) ; 挖掉call/cc后的剩余部分
       (yang (identity*  (capture/cc2))))
  (yin yang))

;(identity@  [C0])输出@，并得到[C0]
;此时的程序（0）
(let* ((yin  [C0])
       (yang (identity*  (capture/cc2))))
  (yin yang))

```

此时，yin已经被绑定为`[C0]`。

```:Scheme
;第1个CC：[C1]，是(capture/cc2)的返回值：
(let* ((yin  [C0])
       (yang (identity*  □))) ; 挖掉call/cc后的剩余部分
  (yin yang))
;注意，[C1]里面包含着[C0]

;(identity*  [C1])输出*，并得到[C1]
;此时的程序（1）
(let* ((yin  [C0])
       (yang [C1]))
  (yin yang))
```

接下来执行`(yin yang)`，也就是`([C0] [C1])`。

> 此时，我们通过`([C0] [C1])`传送门，来到了[C0]的世界

在[C0]的环境里，`yin`和`yang`还没有求值，需要重新求值。

```:Scheme
;[C0]如下，使用[C1]填补其中的坑
(let* ((yin  (identity@  [C1])) ; 填坑
       (yang (identity*  (capture/cc2))))
  (yin yang))

;执行(identity@  [C1])输出@，并得到[C1]
;此时的程序（2）
(let* ((yin  [C1])
       (yang (identity*  (capture/cc2))))
  (yin yang))
```

我们现在已经输出`@*@`了。

继续执行（2），会遇到[C0]里面的`(capture/cc2)`，它捕捉到另外一个新世界`[C2]`：

```:Scheme
;第2个CC：[C2]，是(capture/cc2)的返回值：
(let* ((yin  [C1])
       (yang (identity*  □))) ; 挖坑
  (yin yang))

;但我们仍然在[C0]的世界里，
;继续执行(identity*  [C2])，会输出一个*，并返回[C2]
;我们得到了程序（3）：
(let* ((yin  [C1])
       (yang [C2]))
  (yin yang))
```

我们现在已经输出`@*@*`了。

好了，现在`[C0]`的`yin`和`yang`都齐备了，分别是`[C1]`和`[C2]`。

因此接下来执行`(yin yang)`，也就是`([C1] [C2])`。

> 此时，我们通过`([C1] [C2])`传送门，来到了[C1]的世界

在[C1]的环境里，`yin`和`yang`还没有求值，需要重新求值。

```:Scheme
;[C1]如下，使用[C2]填补其中的坑
(let* ((yin  [C0])
       (yang (identity*  [C2]))) ; 填坑
  (yin yang))

;yin在原来的世界中生成[C1]的时候已经被绑定好了
;所以执行(identity*  [C2])输出*，并得到[C2]
;此时的程序（3）
(let* ((yin  [C0])
       (yang [C2]))
  (yin yang))
```

我们现在已经输出`@*@**`了。

现在，在`[C1]`中，`(yin yang)`就是`([C0] [C2])`。

按照同样的道理，接下来执行的是`([C2] [C3])`……至此，现象层面的道理已经解释清楚。

---

在Scheme语言中，`let\*`实际上是顺序执行的define的语法糖，它可以按顺序将多个变量（`yin`和`yang`）分别绑定到已经evaluated的值上面，或者反过来说。已经知道，对于application`(f x)`，应用序求值是先求`f`，再求`x`，从左向右求值，直到列表中所有表达式求值完毕，才进行application。因此，对于`(yin yang)`，也是先求值`yin`再求值`yang`，恰好和let\*的顺序一致。因此，可以将程序改写为更清楚（？）的形式：

```:Scheme
((identity@ (capture/cc1)) (identity* (capture/cc2)))

; 如果不考虑副作用，实际上就是
((capture/cc1) (capture/cc2))
```

思考一下调用的过程，大致可以画出这样的示意图：

```:Scheme
((CC1) (CC2))

[ CC1 | CC2 ]
  1|@   2|*
   |     |
[ C-0   C-1 ]
  □ X  C0 □
 3|@  \
  |   4\\*
[ C-1   C-2 ]
 C0 □  C1 □
  |   \
  |    5\\*
[ C-0   C-2 ]
  □ X  C1 □
  ...   ...
```

我的妈太抽象了……估计过不了几天连自己也看不懂了……

手写版：

![不要看左边的Cx……下图中，每一行代表一个configuration，左边是`yin`，右边是`yang`，Cx下面的两个东西代表Continuation里面的`yin`和`yang`两个变量的configuration，方框代表参数占位符（也就是在那个位置调用的`call/cc`），圈叉代表另一个`call/cc`。在阴阳问题中，只有C0带有`call/cc`，这个圈叉就是无限循环的万恶之源。](./image/G2/yin-yang-puzzle.png)

简单总结一下：在程序运行中出现过的无数个Cx中，**只有C0可以产生新continuation**，并输出一个@。其余的虽然都包含C0，但是在application的时候，都只是通过`yang`转手，并且输出一颗星星。

例如，执行第一步`(C0 C1)`之后，C1被填充到C0的`yin`中，新生成的C2（其中`yin`是C1，`yang`是□，即包含C1）则被绑定到`yang`，于是第二步就是`(C1 C2)`，到这一步，没有C0的参与，C2被传送到C1的`yang`中，于是第三步就是`(C0 C2)`，又会生成一个C3，下一步application就是`(C2 C3)`…\*…`(C1 C3)`…\*…`(C0 C3)`…@…`(C3 C4)`…\*…`(C2 C4)`…\*…`(C1 C4)`…\*…`(C0 C4)`…@…`(C4 C5)`…\*…`(C3 C5)`…\*…`(C2 C5)`…\*…`(C1 C5)`…\*…`(C0 C5)`…@…`(C5 C6)`…\*…

这也就是说，每输出一个@，意味着一个新的continuation诞生了；每输出一颗星星，意味着已存在的continuation又转手了一次；每转手一次，`yin`指向的continuation就被脱掉一层。因为输出@的时候都会给`yang`指向的continuation包裹上一层，所以下一轮转手的次数就会多一次。

好像还是很复杂呀\~但愿过几个月后我还能看懂\~

**等价的代码**

参考资料[[5]](#参考资料)只使用函数而不是continuation来实现同样的功能，但是依然难以理解。我自己采用CPS风格写了一个等价的程序，以帮助理解。代码如下：

```:Scheme
(define (yinyang cont)
  (display "@")
  (cont)
  (yinyang (lambda () (cont) (display "*"))))

(yinyang (lambda () (display "*")))
```

这段代码还是比较容易理解的。实现此功能的方法有很多，这只是其中之一。

到这里，我觉得我已经可以说服我自己了。你觉得呢？

**参考资料**

- [[1] How-Does-the-Yin-Yang-Puzzle-Work](https://stackoverflow.com/questions/2694679/how-does-the-yin-yang-puzzle-work)
- [[2] Madore 的 call/cc](http://www.madore.org/~david/computers/callcc.html)
- [3] Springer G, Friedman D P. Scheme and the Art of Programming[M]. McGraw-Hill, Inc. 1989.
- [[4] Call-with-current-continuation](https://en.wikipedia.org/wiki/Call-with-current-continuation)
- [[5] Understanding the Yin-Yang Puzzle](https://www.cnblogs.com/cbscan/p/3746861.html)
- [[6] call/cc总结](http://www.sczyh30.com/posts/Functional-Programming/call-with-current-continuation/)
- [[7] Scheme语言深入](https://www.ibm.com/developerworks/cn/linux/l-schm/part3/)
- [[8] Scheme 程序语言介绍之一](https://www.ibm.com/developerworks/cn/linux/l-scheme/part2/index.html)

# 附录5：Brainfuck解释器（2017-11-14）

> 2017年11月14日编写，2022年11月22日整理到博客。

Brainfuck的行为几乎完全模仿图灵机，是图灵完备的。这段代码本来是λ演算的学习笔记，后来为了演示λ演算的图灵完备性，干脆从丘奇编码出发，实现了一个Brainfuck解释器。实际上只需要实现μ-递归函数，就可以证明λ演算的图灵完备性。这一点，在《可计算性与计算复杂性导论》的笔记中，已经写过了。

最初的brainfuck.rkt使用了丘奇编码，因此运行时环境在执行步骤间的传递实际上是以闭包形式传递，运行效率极低；并且存在大量重复求值，很难处理具有副作用的指令（即.和,两个指令）。因此使用原生Racket重写了解释器部分（但Y组合子没有移除），运行效率提高。没有实现,指令，因为觉得用处不大，不能说明问题本质。

建议使用DrRacket运行。

<details>
<summary>Church Encoding</summary>

```
#lang racket

; A simple Brainfuck interpreter
; 简单的Brainfuck解释器
; 2017.11.14
; 说明：使用了丘奇编码(https://en.wikipedia.org/wiki/Church_encoding)，从无到有构造解释器。

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 布尔值
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define SHOWBOOL
  (lambda (b)
    (b #t #f)))

(define @true  (lambda (x y) x))
(define @false (lambda (x y) y))

(define NOT
  (lambda (bool)
    (bool @false @true)))

(define AND
  (lambda (boolx booly)
    (boolx booly boolx)))

(define OR
  (lambda (boolx booly)
    (boolx boolx booly)))

(define IS_ZERO
  (lambda (n)
    (n (lambda (x) @false) @true)))

(define IF
  (lambda (p x y)
    (p x y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 自然数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define SHOWNUM
  (lambda (n)
    (n (lambda (x) (+ x 1)) 0)))

(define NUM_TO_LAMBDA
  (lambda (number)
    (cond ((= number 0) @0)
          (else (INC (NUM_TO_LAMBDA (- number 1)))))))

(define @0 (lambda (f a) a))

(define @1 (lambda (f a) (f a)))

(define INC
  (lambda (n)
    (lambda (f a)
      (f (n f a)))))

(define ADD
  (lambda (m n)
    (m INC n)))

;Curried-ADD - for function MUL
(define ADD-c
  (lambda (m)
    (lambda (n)
      (m INC n))))

(define MUL
  (lambda (m n)
    (n (ADD-c m) @0)))

;Curried-MUL - for function POW
(define MUL-c
  (lambda (m)
    (lambda (n)
      (n (ADD-c m) @0))))

(define POW
  (lambda (m n)
    (n (MUL-c m) @1)))

;some paticular numbers
(define @2 (lambda (f a) (f (f a))))
(define @3 (lambda (f a) (f (f (f a)))))
(define @4 (lambda (f a) (f (f (f (f a))))))
(define @5 (lambda (f a) (f (f (f (f (f a)))))))
(define @6 (lambda (f a) (f (f (f (f (f (f a))))))))
(define @7 (lambda (f a) (f (f (f (f (f (f (f a)))))))))
(define @8 (lambda (f a) (f (f (f (f (f (f (f (f a))))))))))
(define @9 (lambda (f a) (f (f (f (f (f (f (f (f (f a)))))))))))
(define @10 (lambda (f a) (f (f (f (f (f (f (f (f (f (f a))))))))))))
(define @11 (lambda (f a) (f (f (f (f (f (f (f (f (f (f (f a)))))))))))))
(define @12 (lambda (f a) (f (f (f (f (f (f (f (f (f (f (f (f a))))))))))))))
(define @13 (lambda (f a) (f (f (f (f (f (f (f (f (f (f (f (f (f a)))))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 有序对和减法
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define PAIR
  (lambda (x y)
    (lambda (f)
      (f x y))))

(define LEFT
  (lambda (pair)
    (pair @true)))

(define RIGHT
  (lambda (pair)
    (pair @false)))

;substraction
(define SLIDE
  (lambda (pair)
    (PAIR (RIGHT pair) (INC (RIGHT pair)))))

(define DEC
  (lambda (n)
    (LEFT (n SLIDE (PAIR @0 @0)))))

(define SUB
  (lambda (m n)
    (n DEC m)))

;comparation
(define IS_LE
  (lambda (num1 num2)
    (IS_ZERO (SUB num1 num2))))

(define IS_EQUAL
  (lambda (num1 num2)
    (AND (IS_LE num1 num2) (IS_LE num2 num1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Z组合子（Y组合子的应用序求值版本）
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Y-Combinator
;注意：目标函数应使用单参形式
(define Y
  (lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 整数（暂时没有用）
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define INT
  (lambda (neg pos)
    (PAIR neg pos)))

(define *ZERO
  (PAIR @0 @0))

(define IS*ZERO
  (lambda (int)
    (AND (IS_ZERO (LEFT  int))
         (IS_ZERO (RIGHT int)))))

;整数标准化，也就是简化成至少一边为0的形式，这样就可以实现绝对值函数和符号函数了
(define *NORMALIZE
  (lambda (int)
    (IF (IS_LE (LEFT int) (RIGHT int))
        (INT @0 (SUB (RIGHT int) (LEFT int)))
        (INT (SUB (LEFT int) (RIGHT int)) @0))))

(define *ABS
  (lambda (int)
    (IF (IS_ZERO (LEFT (*NORMALIZE int)))
        (RIGHT (*NORMALIZE int))
        (LEFT  (*NORMALIZE int)))))

;@true +; @false -
(define *SGN
  (lambda (int)
    (IS_ZERO (LEFT (*NORMALIZE int)))))

(define SHOWINT
  (lambda (int)
    (cond ((SHOWBOOL (*SGN int)) (display "+") (SHOWNUM (*ABS int)))
          (else                  (display "-") (SHOWNUM (*ABS int))))))

(define *ADD
  (lambda (i j)
    (INT (ADD (LEFT  i) (LEFT  j))
         (ADD (RIGHT i) (RIGHT j)))))

(define *MUL
  (lambda (i j)
    (INT (ADD (MUL (LEFT i) (LEFT j)) (MUL (RIGHT i) (RIGHT j)))
         (ADD (MUL (LEFT i) (RIGHT j)) (MUL (RIGHT i) (LEFT j))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 阶乘函数（组合子测试）
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(display "7!=")
;(SHOWNUM 
;((Y (lambda (f)
;     (lambda (n)
;       (IF (IS_EQUAL n @0)
;           @1
;           (lambda (x y) ((MUL n (f (DEC n)))
;                          x
;                          y))
;       ))))
; @7)
;)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 列表（二叉树）
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define NULL_LIST
  (PAIR @true @true))

(define IS_NULLLIST
  (lambda (list)
    (LEFT list)))

(define CONS
  (lambda (e l)
    (PAIR @false (PAIR e l))))

(define CAR
  (lambda (list)
    (LEFT (RIGHT list))))

(define CDR
  (lambda (list)
    (RIGHT (RIGHT list))))

(define COUNT
  (lambda (l)
    ((Y (lambda (f)
          (lambda (list)
            (IF (NOT (IS_NULLLIST list))
                (lambda (x y) ((INC (f (CDR list)))
                               x
                               y))
                @0))))
     l)))

;(display "Count(1,2,3,3,3)=")
;(SHOWNUM (COUNT (CONS @1 (CONS @2 (CONS @3 (CONS @3 (CONS @3 NULL_LIST)))))))

(define SHOWLIST
  (lambda (list)
    (cond ((SHOWBOOL (IS_NULLLIST list)) (display "N)"))
          (else (display (SHOWNUM (CAR list)))
                (display ",")
                (SHOWLIST (CDR list))))))

;(display "List=(")
;(SHOWLIST (CONS @1 (CONS @2 (CONS @3 (CONS @4 (CONS @5 NULL_LIST))))))
;(newline)

;闭区间
;注意Currying
(define RANGE
  (lambda (m n)
    (((Y (lambda (f)
          (lambda (a)
            (lambda (b)
            (IF (IS_LE a b)
                (lambda (z) ((CONS a ((f (INC a)) b))
                               z ))
                NULL_LIST
            )))))m)n)))

;(COUNT (RANGE @2 @4))
;(display "Range(2,7)=(")
;(SHOWLIST (RANGE @2 @7))
;(newline)


;高阶函数Fold和Map
(define FOLD
  (lambda (list init func)
    ((((Y (lambda (f)
          (lambda (l)
            (lambda (i)
              (lambda (g)
                (IF (IS_NULLLIST l)
                    i
                    (lambda (x y) (
                      (g (CAR l) (((f (CDR l)) i) g))
                      x y))
                ))))))list)init)func)))

(define MAP
  (lambda (list func)
    (((Y (lambda (f)
           (lambda (l)
             (lambda (g)
               (IF (IS_NULLLIST l)
                   NULL_LIST
                   (lambda (x) ((CONS (g (CAR l)) ((f (CDR l)) g)) x))
                )))))list)func)))

; 投影函数（常用）
(define PROJ
  (lambda (list index)
    ((((Y (lambda (f)
            (lambda (l)
              (lambda (i)
                (lambda (j)
                  (IF (IS_EQUAL i j)
                      (CAR l)
                      (lambda (x y) ((((f (CDR l)) i) (INC j)) x y))
                   ))))))list)index)@0)))

;(display "Fold(1:10,0,ADD)=")
;(SHOWNUM (FOLD (RANGE @1 @10) @0 ADD))

;(display "MAP(1:9,0,INC)=(")
;(SHOWLIST (MAP (RANGE @1 @9) INC))
;(newline)

;(display "Proj(2:10,5)=")
;(SHOWNUM (PROJ (MAP (RANGE @1 @9) INC) @5))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 字符和字符串
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;ASCII('A')=65dec

(define $A (MUL @13 @5))
(define Alphabet (RANGE $A (ADD (ADD (ADD $A @10) @10) @5)))
(define $B (PROJ Alphabet @1))
(define $C (PROJ Alphabet @2))
(define $D (PROJ Alphabet @3))
(define $P (PROJ Alphabet @3))
(define $V (PROJ Alphabet (INC (MUL @10 @2)))) ;Variable Flag


;ASCII('a')=97dec
(define $a (ADD (MUL @10 @9) @7))
(define $b (INC $a))

(define SHOWCHAR
  (lambda (num)
    (integer->char (SHOWNUM num))))

(define CHAR_TO_LAMBDA
  (lambda (char)
    (NUM_TO_LAMBDA (char->integer char))))

(define SHOWSTR
  (lambda (cstr)
    (cond ((SHOWBOOL (IS_NULLLIST cstr)) (newline))
          (else (display (SHOWCHAR (CAR cstr))) (SHOWSTR (CDR cstr))))))

(define STR_TO_LAMBDA_ITER
  (lambda (str)
    (lambda (i)
      (cond ((= (+ i 1) (string-length str)) (CONS (CHAR_TO_LAMBDA (string-ref str i)) NULL_LIST))
            (else (CONS (CHAR_TO_LAMBDA (string-ref str i)) ((STR_TO_LAMBDA_ITER str) (+ i 1))))))))

(define STR_TO_LAMBDA
  (lambda (str)
    ((STR_TO_LAMBDA_ITER str) 0)))

;(display "SCharToCNum('a')=")
;(SHOWNUM (CHAR_TO_LAMBDA #\a))

;(display "CNumToSChar($A+@10)=")
;(SHOWCHAR (ADD $A @10))

;(display "ShowString=")
;(SHOWSTR (CONS $A (CONS $B (CONS $C (CONS $D (CONS $D (CONS $D NULL_LIST)))))))

;(display "StringToLambda=")
;(SHOWSTR (STR_TO_LAMBDA "Hello, λ-Calculus!"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; λ演算的语法结构
;  暂时没有用到
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define Variable
  (lambda (char)
    (PAIR $V char)))

(define Parameter
  (lambda (char)
    (PAIR $P char)))

(define Defination
  (lambda (parameter body)
    (PAIR $D (PAIR (Parameter parameter) (PAIR $B body)))))

(define Application
  (lambda (left right)
    (PAIR $A (PAIR left right))))

(define Type
  (lambda (x)
    (LEFT x)))

(define GetChar
  (lambda varpara
    (RIGHT varpara)))

(define GetVarInDef
  (lambda (defination)
    (LEFT (RIGHT defination))))

(define GetBodyInDef
  (lambda (defination)
    (RIGHT (RIGHT defination))))

(define GetLeft
  (lambda (app)
    (LEFT (RIGHT app))))

(define GetRight
  (lambda (app)
    (RIGHT (RIGHT app))))

;SAMPLE=λa.λb.ab
(define Sample
  (Defination (Variable $a) (Defination (Variable $b) (Application (Variable $a) (Variable $b)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 树形递归举例-斐波那契数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define Fib
  (lambda (num)
    ((Y (lambda (f)
          (lambda (n)
            (IF (OR (IS_EQUAL n @0) (IS_EQUAL n @1))
                @1
                (lambda (x y) ((ADD (f (SUB n @1)) (f (SUB n @2))) x y))
            )))) num)))

;(SHOWNUM (Fib @6))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Brainfuck解释器
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define @48 (MUL @12 @4))

; Brainfuck运行时环境示例
; 以字符0初始化
; 0位是数据指针DP，1位是程序指针CP，2位（地址0）开始是数据段，52位（地址50）开始是代码段
; BF逻辑地址称为offset，列表物理位置称为index
(define BF_ENV
  (CONS @0 (CONS @48 (STR_TO_LAMBDA "00000000000000000000000"))))

; 调试输出
(define BF_DEBUG
  (lambda (env)
    (newline)
    (display "== BrainFUCK DEBUG ===================================================")(newline)
    (display " DP = ")(display (SHOWNUM (CAR env)))(newline)
    (display " CP = ")(display (SHOWNUM (CAR (CDR env))))(newline)
    (display " LA : 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF")(newline)
    (display "MEM = ")
    (SHOWSTR (CDR (CDR env)))
    (display "======================================================================")(newline)
    (newline)
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 工具函数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 左子列表 [0:index)
(define sub_L
  (lambda (index env)
    (((Y (lambda (f)
           (lambda (e)
             (lambda (iter)
               (IF (IS_EQUAL index iter)
                   NULL_LIST
                   (lambda (x) ((CONS (PROJ e iter) ((f e) (INC iter)))
                                x))
               ))))) env) @0)))

;(display "SUBL(")
;(SHOWLIST (sub_L @0 (STR_TO_LAMBDA "0123456789")))

; 右子列表 (index:N]
(define sub_R
  (lambda (index env)
    (((Y (lambda (f)
           (lambda (e)
             (lambda (iter)
               (IF (IS_ZERO iter)
                   e
                   (lambda (x) (((f (CDR e)) (DEC iter))
                                x))
                ))))) env) (INC index))))

;(display "SUBR(")
;(SHOWSTR (sub_R @0 (STR_TO_LAMBDA "0123456789")))

; 列表连接
(define list_catenate
  (lambda (_pre _post)
    (((Y (lambda (f)
           (lambda (pre)
             (lambda (post)
               (IF (IS_NULLLIST pre)
                   post
                   (lambda (x) ((CONS (CAR pre) ((f (CDR pre)) post))
                                x))
               ))))) _pre) _post)))

;(display "(")
;(SHOWSTR (list_catenate (STR_TO_LAMBDA "0123") (STR_TO_LAMBDA "456789")))


; 计算数据指针的物理地址index
(define data_index
  (lambda (env)
    (ADD @2 (CAR env))))

; 读取当前指针指向的cell值
(define read_data
  (lambda (env)
    (PROJ env (data_index env))))

;(display "read_data=")
;(SHOWNUM (read_data (CONS @1 (CONS @2 (STR_TO_LAMBDA "000000000")))))

; 修改当前指针指向的cell值
; 注意：传入单参函数
(define modify_data
  (lambda (func env)
    (list_catenate (sub_L (data_index env) env)
                   (CONS (func (read_data env))
                         (sub_R (data_index env) env)))))

;(display "modify_data=")
;(BF_DEBUG (modify_data (ADD-c @5) (CONS @5 (CONS @2 (STR_TO_LAMBDA "000000000")))))

; 计算程序指针的物理地址index
(define code_index
  (lambda (env)
    (ADD @2 (CAR (CDR env)))))

; 取CP指向的指令码
(define read_code
  (lambda (env)
    (PROJ env (code_index env))))

;(display "read_code=")
;(SHOWCHAR (read_code (CONS @1 (CONS @3 (STR_TO_LAMBDA "000C00000")))))

; 计算当前指令逻辑地址（offset）左侧的**匹配**的“[”指令的所在物理地址（index）
; 这里计算的是（当前所在内层）循环的入口地址
(define ret_index
  (lambda (env)
    ((((Y (lambda (f)
            (lambda (e)
              (lambda (cindex)
                (lambda (flag)
                  (IF (IS_EQUAL (PROJ env cindex) (CHAR_TO_LAMBDA #\]))
                      (lambda (x y) ((((f env) (DEC cindex)) (INC flag)) x y))
                      (lambda (x y) (
                         (IF (IS_EQUAL (PROJ env cindex) (CHAR_TO_LAMBDA #\[))
                             (lambda (x y) (
                                (IF (IS_ZERO flag)
                                    cindex
                                    (lambda (x y) ((((f env) (DEC cindex)) (DEC flag)) x y))
                                ) x y))
                             (lambda (x y) (
                                (((f env) (DEC cindex)) flag) x y))
                          ) x y))
                  )))))) env) (DEC (code_index env))) @0)))


;(display "ret[_index=")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0123456789ABCD(index)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0123456789AB(offset)
;(SHOWNUM (ret_index (CONS @0 (CONS @7 (STR_TO_LAMBDA "[[[[[][]A]]]]1234")))))

; 计算当前指令逻辑地址（offset）右侧的**匹配**的“]”指令的所在物理地址（index）的后一位
; 这里计算的是（当前所在内层）循环的跳出地址
(define pass_index
  (lambda (env)
    ((((Y (lambda (f)
            (lambda (e)
              (lambda (cindex)
                (lambda (flag)
                  (IF (IS_EQUAL (PROJ env cindex) (CHAR_TO_LAMBDA #\[))
                      (lambda (x y) ((((f env) (INC cindex)) (INC flag)) x y))
                      (lambda (x y) (
                         (IF (IS_EQUAL (PROJ env cindex) (CHAR_TO_LAMBDA #\]))
                             (lambda (x y) (
                                (IF (IS_ZERO flag)
                                    (INC cindex)
                                    (lambda (x y) ((((f env) (INC cindex)) (DEC flag)) x y))
                                ) x y))
                             (lambda (x y) (
                                (((f env) (INC cindex)) flag) x y))
                          ) x y))
                  )))))) env) (INC (code_index env))) @0)))

;(display "pass]_index=")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0123456789ABCDEF(index)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0123456789ABCDEF(offset)
;(SHOWNUM (pass_index (CONS @0 (CONS @3 (STR_TO_LAMBDA "0[A[A]A[A]A]]]]1234")))))

; 修改指令指针（下条指令逻辑地址）
(define modify_code_offset_0
  (lambda (coffset env)
    (list_catenate (sub_L @1 env)
                   (CONS coffset
                         (sub_R @1 env)))))

; 修改指令指针（简化版）
(define modify_code_offset
  (lambda (coffset env)
    (CONS (CAR env) (CONS coffset (sub_R @1 env)))))

;(display "modify_code_offset+2!!!=")
;(SHOWNUM (code_index (modify_code_offset @10 
;                                         (CONS @0 (CONS @7 (STR_TO_LAMBDA "[[[[[][]A]]]]1234")))
;                                         )))

; 获取下一条指令的逻辑地址
(define next
  (lambda (env)
    (INC (CAR (CDR env)))))

; CP加一
(define cp++
  (lambda (env)
    (modify_code_offset (INC (CAR (CDR env))) env)))

;(BF_DEBUG (cp++ (CONS @0 (CONS @5 (STR_TO_LAMBDA "12000[->+<]  ")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 指令语义
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             
; Note: Every lambda function representing a Brainfuck instruction
;       receives an OLD ENV and returns a NEW ENV.
(define >
  (lambda (env)
    (cp++ (CONS (INC (CAR env)) (CDR env)))))

(define <
  (lambda (env)
    (cp++ (CONS (DEC (CAR env)) (CDR env)))))

(define ++
  (lambda (env)
    (cp++ (modify_data INC env))))

(define --
  (lambda (env)
    (cp++ (modify_data DEC env))))

; .
(define o
  (lambda (env)
    (cp++ (SHOWCHAR (PROJ env (INC (CAR env)))))))

; ,暂不实现

;(BF_DEBUG (> (CONS @0 (CONS @5 (STR_TO_LAMBDA "12000[->+<]  ")))))

; [
(define loopl
  (lambda (env)
    (IF (IS_EQUAL (CHAR_TO_LAMBDA #\0) (read_data env))
        (lambda (x) ((modify_code_offset (SUB (pass_index env) @2) env) x)) ;直接跳出
        (lambda (x) ((cp++ env) x)) ;下条指令
    )))

;(display "loopl=")
;(SHOWLIST (loopl (CONS @0 (CONS @3 (STR_TO_LAMBDA "1[A[A]A[A]A]]]]1234")))))

; ]
(define loopr
  (lambda (env)
    (modify_code_offset (SUB (ret_index env) @2) env)))

;(display "loopr=")
;(SHOWLIST (loopr (CONS @0 (CONS @5 (STR_TO_LAMBDA "1[A[A]A[A]A]]]]1234")))))


; 单步执行：执行当前CP指向的指令
; 执行的结果当然是保存在新的env里面啦
(define step
  (lambda (env)
    (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\+))
        (lambda (x) ((++ env) x))
        (lambda (x) (
           (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\-))
               (lambda (x) ((-- env) x))
               (lambda (x) (
                  (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\>))
                      (lambda (x) ((> env) x))
                      (lambda (x) (
                         (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\<))
                             (lambda (x) ((< env) x))
                             (lambda (x) (
                                (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\o))
                                    (lambda (x) ((o env) x))
                                    (lambda (x) (
                                       (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\i))
                                           (lambda (x) ((o env) x)) ;暂未实现
                                           (lambda (x) (
                                              (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\[))
                                                  (lambda (x) ((loopl env) x))
                                                  (lambda (x) (
                                                     (IF (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\]))
                                                         (lambda (x) ((loopr env) x))
                                                         env ; 未知指令，不执行任何动作
                                                     ) x))
                                              ) x))
                                       ) x))
                                ) x))
                         ) x))
                  ) x))
           ) x))
     )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 执行加速
;   避免对过长的表达式求值
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define to_string
  (lambda (env)
    (cond ((SHOWBOOL (IS_NULLLIST env)) "")
          (else (string-append (make-string 1 (SHOWCHAR (CAR env))) (to_string (CDR env)))))))

(define STEPx
  (lambda (prev_env)
    (step (CONS (CAR prev_env) (CONS (CAR (CDR prev_env)) (STR_TO_LAMBDA (to_string (CDR (CDR prev_env)))))))))

(define ENVx
  (lambda (stepx)
    (CONS (CAR stepx) (CONS (CAR (CDR stepx)) (STR_TO_LAMBDA (to_string (CDR (CDR stepx))))))))

(define ITER
  (lambda (env)
    (ENVx (STEPx env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 解释器主体
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Brainfuck初始环境，含数据初值和代码
; 程序意义：计算逻辑地址0和1位置两个数字的和，并将结果保存在1位置。
;                 DP       CP                 MEMORY(TAPE)
(define env (CONS @0 (CONS @2 (STR_TO_LAMBDA "23[->+<]$"))))

; 解释器
;   读取到$字符时停止，并输出调试信息
(define bf_interpreter
  (lambda (env)
    (cond ((SHOWBOOL (IS_EQUAL (read_code env) (CHAR_TO_LAMBDA #\$))) (BF_DEBUG env))
          (else (bf_interpreter (ITER env))))))

; 开始解释执行
(bf_interpreter env)
```

</details>

<details>
<summary>Raw Racket</summary>

```
#lang racket

; A simple Brainfuck interpreter
; 简单的Brainfuck解释器
; 2017.11.14

; 应用序的Y不动点组合子（可以不需要）
(define Y
  (lambda (S)
    ( (lambda (x) (S (lambda (y) ((x x) y))))
      (lambda (x) (S (lambda (y) ((x x) y)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Brainfuck运行时环境初始化
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Brainfuck运行时环境说明
;   BF运行时环境为Scheme列表
;   列表首元素为0位，地址称为index，相当于物理地址
;   index为0、1的两个元素分别是数据指针（DP）和代码指针（CP）
;   index从2开始的部分是数据区和代码区，相对于index=2的元素的偏移量为offset，相当于逻辑地址
;   DP和CP保存的都是offset，即index-2
;   DP是BF的<>两个指令控制的指针，其初始值为0
;   数据区从offset=0开始
;   CP是待执行指令的指针，相当于程序计数器，其初始值由用户指定
;   代码区从offset=初始CP开始
;   数据区默认值为0，代码区存储指令的ASCII码
;   代码以空格结束，解释器通过空格判断程序结束
;
;   例如
;   [ index] 0123456789ABCDEF
;   [offset] --0123456789ABCD
;   [memory] 0223[->+<]_
;
;   上面这段程序将逻辑地址0上面的数字加到逻辑地址1上。下划线代表空格。

; 环境构建
(define env_constructer
  (lambda (dp_init cp_init code_str)
    (lambda (iter)
        (if (= iter 0)
            (cons dp_init ((env_constructer dp_init cp_init code_str) (+ iter 1)))
            (if (= iter 1)
                (cons cp_init ((env_constructer dp_init cp_init code_str) (+ iter 1)))
                (if (<= iter (+ 1 cp_init))
                    (cons 0 ((env_constructer dp_init cp_init code_str) (+ iter 1)))
                    (if (> iter (+ (+ cp_init (string-length code_str)) 1))
                        '()
                        (cons (char->integer (string-ref code_str (- iter (+ 2 cp_init))))
                              ((env_constructer dp_init cp_init code_str) (+ iter 1))))))))))

; 环境初始化
(define ENV_INIT (lambda (dp_init cp_init code_str) ((env_constructer dp_init cp_init code_str) 0)))

; 手动设置数据区
(define MEM_SET (lambda (env addr value) (list-set env (+ 2 addr) value)))

; 打印一行字符串
(define printstr
  (lambda (cstr)
    (cond ((null? cstr) (newline))
          (else (display (integer->char (car cstr))) (printstr (cdr cstr))))))

; 调试输出
(define BF_DEBUG
  (lambda (env)
    (display "== BrainFUCK DEBUG ===================================================")(newline)
    (display " DP = ")(display (car env))(newline)
    (display " CP = ")(display (car (cdr env)))(newline)
    (display " LA : 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF")(newline)
    (display "MEM = ")
    (printstr (cdr (cdr env)))
    (display "======================================================================")(newline)
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 列表工具函数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 左子列表 [0:index)
(define sub_L
  (lambda (index env)
    (((Y (lambda (f)
           (lambda (e)
             (lambda (iter)
               (if (= index iter)
                   '()
                   (cons (list-ref e iter) ((f e) (+ iter 1)))
               ))))) env) 0)))

; 右子列表 (index:N]
(define sub_R
  (lambda (index env)
    (((Y (lambda (f)
           (lambda (e)
             (lambda (iter)
               (if (= 0 iter)
                   e
                   ((f (cdr e)) (- iter 1))
                ))))) env) (+ index 1))))

; 列表连接
(define list_catenate
  (lambda (_pre _post)
    (((Y (lambda (f)
           (lambda (pre)
             (lambda (post)
               (if (null? pre)
                   post
                   (cons (car pre) ((f (cdr pre)) post))
               ))))) _pre) _post)))


; 列表置数
(define list-set
  (lambda (list index value)
    (list_catenate (sub_L index list)
                   (cons value
                         (sub_R index list)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 环境访问函数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 计算数据指针的物理地址index
(define data_index
  (lambda (env)
    (+ 2 (car env))))

; 读取当前指针指向的cell值
(define read_data
  (lambda (env)
    (list-ref env (data_index env))))

; 修改当前指针指向的cell值
; 注意：传入单参函数
(define modify_data
  (lambda (func env)
    (list_catenate (sub_L (data_index env) env)
                   (cons (func (read_data env))
                         (sub_R (data_index env) env)))))

; 计算程序指针的物理地址index
(define code_index
  (lambda (env)
    (+ 2 (car (cdr env)))))

; 取CP指向的指令码
(define read_code
  (lambda (env)
    (list-ref env (code_index env))))

; 计算当前指令逻辑地址（offset）左侧的**匹配**的“[”指令的所在物理地址（index）
; 这里计算的是（当前所在内层）循环的入口地址
(define ret_index
  (lambda (env)
    ((((Y (lambda (f)
            (lambda (e)
              (lambda (cindex)
                (lambda (flag)
                  (if (= (list-ref env cindex) 93)
                      (((f env) (- cindex 1)) (+ flag 1))
                      (if (= (list-ref env cindex) 91)
                          (if (= flag 0)
                              cindex
                              (((f env) (- cindex 1)) (- flag 1)))
                          (((f env) (- cindex 1)) flag)))
                  ))))) env) (- (code_index env) 1)) 0)))

; 计算当前指令逻辑地址（offset）右侧的**匹配**的“]”指令的所在物理地址（index）的后一位
; 这里计算的是（当前所在内层）循环的跳出地址
(define pass_index
  (lambda (env)
    ((((Y (lambda (f)
            (lambda (e)
              (lambda (cindex)
                (lambda (flag)
                  (if (= (list-ref env cindex) 91)
                      (((f env) (+ cindex 1)) (+ flag 1))
                      (if (= (list-ref env cindex) 93)
                          (if (= flag 0)
                              (+ cindex 1)
                              (((f env) (+ cindex 1)) (- flag 1)))
                          (((f env) (+ cindex 1)) flag)))
                 ))))) env) (+ (code_index env) 1)) 0)))

; 修改指令指针（下条指令逻辑地址）
(define modify_code_offset
  (lambda (coffset env)
    (cons (car env) (cons coffset (sub_R 1 env)))))

; 获取下一条指令的逻辑地址
(define next
  (lambda (env)
    (+ 1 (car (cdr env)))))

; CP加一
(define cp++
  (lambda (env)
    (modify_code_offset (+ 1 (car (cdr env))) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 指令语义
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define p>
  (lambda (env)
    (cp++ (cons (+ 1 (car env)) (cdr env)))))

(define p<
  (lambda (env)
    (cp++ (cons (- (car env) 1) (cdr env)))))

(define ++
  (lambda (env)
    (cp++ (modify_data (lambda (x) (+ x 1)) env))))

(define --
  (lambda (env)
    (cp++ (modify_data (lambda (x) (- x 1)) env))))

; .
(define o
  (lambda (env)
    (display (integer->char (read_data env)))
    (cp++ env)))

; ,暂不实现

; [
(define loopl
  (lambda (env)
    (if (= 0 (read_data env))
        (modify_code_offset (- (pass_index env) 2) env) ;直接跳出
        (cp++ env) ;下条指令
    )))

; ]
(define loopr
  (lambda (env)
    (modify_code_offset (- (ret_index env) 2) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 解释器主体
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 单步执行：执行当前CP指向的指令
; 执行的结果当然是保存在新的env里面啦
(define step
  (lambda (env)
    (if (= (read_code env) 43) ;+
        (++ env)
        (if (= (read_code env) 45) ;-
            (-- env)
            (if (= (read_code env) 62) ;>
                (p> env)
                (if (= (read_code env) 60) ;<
                    (p< env)
                    (if (= (read_code env) 46) ;.
                        (o env)
                        (if (= (read_code env) 44) ;,
                            (p> env) ;暂未实现
                            (if (= (read_code env) 91) ;[
                                (loopl env)
                                (if (= (read_code env) 93) ;]
                                    (loopr env)
                                    env ; 未知指令，不执行任何动作
                                ))))))))))

; 主函数
;   读取到空白字符（32）时停止，并输出调试信息
(define bf_interpreter
  (lambda (env cnt)
    (cond ((= (read_code env) 32) (BF_DEBUG env)
                                  (display "iteration steps = ")(display cnt))
          (else (bf_interpreter (step env) (+ cnt 1))))))

; 设置环境
(define env
  (ENV_INIT 0 20 "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++. "))

; 开始解释执行
(bf_interpreter env 0)
```

</details>
