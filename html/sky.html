<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>天空大气光学模拟</title>
</head>
<body>
    <div class="container">
        <canvas id="skyCanvas" width="240" height="240" style="width: 240px; height: 240px;"></canvas>
        <div class="controls">
            <label for="sun_altitude_deg">alt:</label>
            <input type="range" id="sun_altitude_deg" min="-360" max="360" value="60" step="0.1" style="width: 100%;">
            <span class="value-display" id="angleValue">--°</span>
        </div>
    </div>

    <script>



const USE_FISHEYE_PROJECTION = false; // 是否使用鱼眼投影（否则使用XY投影）
const USE_SIMPLE_PHYSICS_MODEL = false; // 是否使用不符合物理但是比较好看的大气光学模型


let moon_texture_width = 160;
let moon_texture_height = 160;

const img = new Image();
img.src = '../image/H/moon.jpg';
img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    moon_texture_width = img.width;
    moon_texture_height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    moon_texture_rgba = ctx.getImageData(0, 0, img.width, img.height).data; // Uint8ClampedArray
    // console.log(JSON.stringify(Array.from(moon_texture_rgba)));
};


let RADIUS = 120;

// 物理常数
const PHYSICS = {
    // 大气光学参数
    MIE_G: 0.9,           // 米氏散射不对称因子
    RAYLEIGH_BETA: 0.3,  // 瑞利散射系数 感觉是海拔越高越小
    MIE_BETA_BASE: 0.001,      // 米氏散射系数 越大光斑越大
    MIE_BETA_MAX: 0.1,      // 米氏散射系数 越大光斑越大
    ATMOSPHERE_HEIGHT: 8.5, // 虚拟大气层厚度 (km)
    SUN_ANGULAR_SIZE: 0.5, // 太阳视直径 (度)

    // 波长相关的瑞利散射系数 (近似)
    RAYLEIGH_WAVELENGTH_FACTORS: [
        680, // Red
        550, // Green
        450  // Blue
    ],

    // 臭氧吸收系数
    OZONE_ABSORPTION: [
        0.005,  // Red   (650nm) — 弱吸收
        0.040,  // Green (550nm) — 中等吸收
        0.025   // Blue  (450nm) — 比绿光略弱（实际臭氧在~600nm最强，但简化模型）
    ],
};


function to_rad(deg) {
    return deg * Math.PI / 180;
}

function to_deg(rad) {
    return rad * 180 / Math.PI;
}

function horizontal_to_xyz(azimuth_deg, altitude_deg, R) {
    const altRad = to_rad(altitude_deg);
    const azRad = to_rad(180 - azimuth_deg);
    return [
        R * Math.cos(altRad) * Math.sin(azRad),
        R * Math.cos(altRad) * Math.cos(azRad),
        R * Math.sin(altRad)
    ];
}

function horizontal_to_projection_xy(azimuth_deg, altitude_deg, R) {
    const xyz = horizontal_to_xyz(azimuth_deg, altitude_deg, R);
    return [xyz[0] + RADIUS, xyz[1] + RADIUS];
}


function get_luminance(r, g, b) {
    return 0.299 * r + 0.587 * g + 0.114 * b;
}







function star_burst_filter(frame_buffer, width, height, sun_screen_x, sun_screen_y, sunBrightness) {
    // 亮度阈值
    const threshold = 0.9;

    const cx = sun_screen_x;
    const cy = sun_screen_y;
    const ix = Math.floor(cx), iy = Math.floor(cy);
    if (ix < 0 || ix >= width || iy < 0 || iy >= height) return;

    // 1. 读取原图中该像素的亮度
    const idx = (iy * width + ix) * 4;
    const r = frame_buffer[idx] / 255;
    const g = frame_buffer[idx + 1] / 255;
    const b = frame_buffer[idx + 2] / 255;
    const lum = get_luminance(r, g, b);

    if (lum <= threshold) return; // 不够亮，不绘制星芒

    // 2. 计算星芒颜色和强度
    const factor = Math.min(1, (lum - threshold) * 5);
    const sr = r * factor * 255;
    const sg = g * factor * 255;
    const sb = b * factor * 255;

    // 3. 绘制星芒（沿4个方向双向延伸）
    const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
    const blurLength = 100;
    const decay = 0.97;

    for (const [dx, dy] of directions) {
        const len = Math.hypot(dx, dy);
        const ndx = dx / len, ndy = dy / len;

        for (let d = 1; d <= blurLength; d++) {
            const alpha = Math.pow(decay, d);
            if (alpha < 0.01) break;

            // 正向
            let px = Math.floor(cx + ndx * d);
            let py = Math.floor(cy + ndy * d);
            if (px >= 0 && px < width && py >= 0 && py < height) {
                const i = (py * width + px) * 4;
                frame_buffer[i]     = Math.min(255, frame_buffer[i]     + sr * alpha);
                frame_buffer[i + 1] = Math.min(255, frame_buffer[i + 1] + sg * alpha);
                frame_buffer[i + 2] = Math.min(255, frame_buffer[i + 2] + sb * alpha);
            }

            // 反向
            px = Math.floor(cx - ndx * d);
            py = Math.floor(cy - ndy * d);
            if (px >= 0 && px < width && py >= 0 && py < height) {
                const i = (py * width + px) * 4;
                frame_buffer[i]     = Math.min(255, frame_buffer[i]     + sr * alpha);
                frame_buffer[i + 1] = Math.min(255, frame_buffer[i + 1] + sg * alpha);
                frame_buffer[i + 2] = Math.min(255, frame_buffer[i + 2] + sb * alpha);
            }
        }
    }
}



function draw_circle_outline(frame_buffer, fb_width, fb_height, center_x, center_y, radius, line_weight, red, green, blue, alpha) {
    if (radius <= 0 || line_weight <= 0) return;

    const r = Math.max(0, Math.min(255, Math.round(red)));
    const g = Math.max(0, Math.min(255, Math.round(green)));
    const b = Math.max(0, Math.min(255, Math.round(blue)));
    const a = Math.max(0, Math.min(255, Math.round(alpha)));

    // 计算内外半径（考虑线宽居中）
    const halfWeight = line_weight / 2;
    const outerR = radius + halfWeight;
    const innerR = Math.max(0, radius - halfWeight);

    const outerRSq = outerR * outerR;
    const innerRSq = innerR * innerR;

    // 包围盒（含线宽）
    const xMin = Math.max(0, Math.floor(center_x - outerR));
    const xMax = Math.min(fb_width - 1, Math.ceil(center_x + outerR));
    const yMin = Math.max(0, Math.floor(center_y - outerR));
    const yMax = Math.min(fb_height - 1, Math.ceil(center_y + outerR));

    for (let y = yMin; y <= yMax; y++) {
        for (let x = xMin; x <= xMax; x++) {
            const dx = x - center_x;
            const dy = y - center_y;
            const distSq = dx * dx + dy * dy;

            // 判断是否在环形区域内（包含外边界，排除内边界）
            if (distSq < outerRSq && distSq >= innerRSq) {
                const idx = (y * fb_width + x) * 4;
                frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + r);
                frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + g);
                frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + b);
                frame_buffer[idx + 3] = Math.min(255, frame_buffer[idx + 2] + a);
            }
        }
    }
}








// 基于球面几何 terminator 的月相绘制（带物理合理的软边缘）
function draw_moon(frame_buffer, fb_width, fb_height, center_x, center_y, lum, radius, phase_deg, tilt_deg) {
    const moonX = center_x;
    const moonY = center_y;
    const moonRadius = radius;

    // 太阳方向（单位向量），同原逻辑
    const cosPhase = Math.cos(to_rad(phase_deg));
    const sinPhase = Math.sin(to_rad(phase_deg));
    const sunDirX = cosPhase * Math.cos(to_rad(tilt_deg));
    const sunDirY = cosPhase * Math.sin(to_rad(tilt_deg));
    const sunDirZ = sinPhase;

    const sunLen = Math.sqrt(sunDirX * sunDirX + sunDirY * sunDirY + sunDirZ * sunDirZ);
    const sunUnitX = sunLen > 0 ? sunDirX / sunLen : 1;
    const sunUnitY = sunLen > 0 ? sunDirY / sunLen : 0;
    const sunUnitZ = sunLen > 0 ? sunDirZ / sunLen : 0;

    // 颜色与环境光
    const litColor = [220, 220, 200];
    const darkColor = [10, 10, 20];
    const ambient = 0.01;

    // 半影角宽度（弧度）：太阳角半径 ≈ 0.0047 rad，取稍大值保证可见性
    const PENUMBRA_HALF_ANGLE = 0.2; // ≈ 0.5°

    // 抗锯齿过渡带宽度（像素）
    const edgeSmoothWidth = 1.0;

    const r2 = moonRadius * moonRadius;
    for (let dy = -moonRadius; dy <= moonRadius; dy++) {
        for (let dx = -moonRadius; dx <= moonRadius; dx++) {
            const distSq = dx * dx + dy * dy;
            const distance = Math.sqrt(distSq);

            if (distance > moonRadius + edgeSmoothWidth) continue;

            const px = Math.floor(moonX + dx);
            const py = Math.floor(moonY + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            // === 1. 计算抗锯齿权重（基于圆盘覆盖比例）===
            let moonWeight;
            if (distance <= moonRadius - edgeSmoothWidth) {
                moonWeight = 1.0; // 完全在内部
            } else if (distance >= moonRadius + edgeSmoothWidth) {
                moonWeight = 0.0; // 完全在外部（应跳过，但保留以防边界误差）
                continue;
            } else {
                // 平滑过渡 [moonRadius - w, moonRadius + w]
                const t = (moonRadius + edgeSmoothWidth - distance) / (2 * edgeSmoothWidth);
                moonWeight = Math.max(0, Math.min(1, t)); // 线性插值，也可用 smoothstep
                // 可选更平滑：moonWeight = t * t * (3 - 2 * t);
            }

            if (moonWeight <= 0) continue;

            // === 2. 获取当前背景颜色（来自 frame_buffer）===
            const bgR = frame_buffer[idx] / 255;
            const bgG = frame_buffer[idx + 1] / 255;
            const bgB = frame_buffer[idx + 2] / 255;

            // 构造单位球面上的表面点（归一化位置向量 = 法向量）
            const len = Math.sqrt(dx * dx + dy * dy + r2 - dx * dx - dy * dy); // = moonRadius
            // 实际上，(dx, dy, dz) 在半径为 moonRadius 的球面上，所以单位向量为：
            const nx = dx / moonRadius;
            const ny = dy / moonRadius;
            const nz = Math.sqrt(Math.max(0, r2 - dx * dx - dy * dy)) / moonRadius;

            // 关键：计算该点与 terminator 的球面角距离
            // terminator 是太阳方向与月球中心构成的大圆
            // 点积 dot = cos(θ)，其中 θ 是表面点与太阳方向的夹角
            const dot = nx * sunUnitX + ny * sunUnitY + nz * sunUnitZ;

            // θ = acos(dot)，但避免 acos 开销，直接用 dot 表示角度关系
            // terminator 位于 dot = 0（即 θ = 90°）
            // 我们定义 signed_angle_dist ∝ -dot （因为 dot>0 为亮区）
            // 将角距离映射为线性过渡变量（单位：弧度等效）

            // 使用小角度近似：angle ≈ sqrt(1 - dot^2) 不适用；更简单：
            // 直接用 dot 作为“余弦空间”的代理变量，其梯度在 terminator 附近 ≈ 1/rad
            // 因此，我们定义“有效角偏移”为：
            const angleFromTerminator = Math.acos(Math.max(-1, Math.min(1, dot))) - Math.PI / 2; // ∈ [-π/2, π/2]

            // 或者更高效（避免 acos）：利用 sin(θ - π/2) = -cosθ = -dot
            // 在 terminator 附近（θ≈π/2），有 θ - π/2 ≈ -dot （一阶泰勒）
            // 所以可用：approxAngle = -dot （单位为“弧度等效”，需缩放）
            // 但为保精度，这里采用 acos 方法（可选优化见注释）

            // === 软边缘判断 ===
            let intensity;
            if (angleFromTerminator >= PENUMBRA_HALF_ANGLE) {
                intensity = 1.0; // 完全照亮
            } else if (angleFromTerminator <= -PENUMBRA_HALF_ANGLE) {
                intensity = ambient; // 完全背光
            } else {
                // 映射到 [0,1]
                const t = (angleFromTerminator + PENUMBRA_HALF_ANGLE) / (2 * PENUMBRA_HALF_ANGLE);
                const smoothT = t * t * (3 - 2 * t); // smoothstep
                intensity = ambient + (1 - ambient) * smoothT;
            }

            // 调整全局亮度
            intensity *= lum;






            // === 纹理映射：先绕 Z 轴旋转 -alpha，再映射到经纬度 ===
            let u_norm = dx / moonRadius;   // ∈ [-1, 1]
            let v_norm = dy / moonRadius;   // ∈ [-1, 1]

            // 绕原点旋转 -alpha（使贴图随光照方向对齐）
            const cosA = Math.cos(-to_rad(tilt_deg));
            const sinA = Math.sin(-to_rad(tilt_deg));
            const u_rot = u_norm * cosA - v_norm * sinA;
            const v_rot = u_norm * sinA + v_norm * cosA;

            // 映射到 [0,1] 贴图空间
            let u = (u_rot + 1) * 0.5; // [-1,1] → [0,1]
            let v = (v_rot + 1) * 0.5;

            // 可选：限制在 [0,1] 内（避免边缘采样异常）
            if (u < 0 || u > 1 || v < 0 || v > 1) {
                // 可选择 clamp 或 skip；这里 clamp 更安全
                u = Math.max(0, Math.min(1, u));
                v = Math.max(0, Math.min(1, v));
            }

            // 双线性采样
            const tx = u * moon_texture_width - 0.5;
            const ty = v * moon_texture_height - 0.5;

            const x0 = Math.floor(tx);
            const y0 = Math.floor(ty);
            const x1 = (x0 + 1) % moon_texture_width;
            const y1 = Math.min(y0 + 1, moon_texture_height - 1);

            const wx = tx - x0;
            const wy = ty - y0;

            function getPixel(tex, x, y, c) {
                return tex[((y * moon_texture_width + x) * 4) + c];
            }

            const c00_r = getPixel(moon_texture_rgba, x0, y0, 0);
            const c00_g = getPixel(moon_texture_rgba, x0, y0, 1);
            const c00_b = getPixel(moon_texture_rgba, x0, y0, 2);

            const c10_r = getPixel(moon_texture_rgba, x1, y0, 0);
            const c10_g = getPixel(moon_texture_rgba, x1, y0, 1);
            const c10_b = getPixel(moon_texture_rgba, x1, y0, 2);

            const c01_r = getPixel(moon_texture_rgba, x0, y1, 0);
            const c01_g = getPixel(moon_texture_rgba, x0, y1, 1);
            const c01_b = getPixel(moon_texture_rgba, x0, y1, 2);

            const c11_r = getPixel(moon_texture_rgba, x1, y1, 0);
            const c11_g = getPixel(moon_texture_rgba, x1, y1, 1);
            const c11_b = getPixel(moon_texture_rgba, x1, y1, 2);

            // bilinear interpolation
            const r0 = c00_r + wx * (c10_r - c00_r);
            const g0 = c00_g + wx * (c10_g - c00_g);
            const b0 = c00_b + wx * (c10_b - c00_b);

            const r1 = c01_r + wx * (c11_r - c01_r);
            const g1 = c01_g + wx * (c11_g - c01_g);
            const b1 = c01_b + wx * (c11_b - c01_b);

            let texR = r0 + wy * (r1 - r0);
            let texG = g0 + wy * (g1 - g0);
            let texB = b0 + wy * (b1 - b0);

            // 应用光照强度（保留你的明暗效果）
            const r = Math.round(texR * intensity);
            const g = Math.round(texG * intensity);
            const b = Math.round(texB * intensity);




            // const r = Math.round(darkColor[0] + intensity * (litColor[0] - darkColor[0]));
            // const g = Math.round(darkColor[1] + intensity * (litColor[1] - darkColor[1]));
            // const b = Math.round(darkColor[2] + intensity * (litColor[2] - darkColor[2]));



            const finalR = moonWeight * r + (1 - moonWeight) * bgR;
            const finalG = moonWeight * g + (1 - moonWeight) * bgG;
            const finalB = moonWeight * b + (1 - moonWeight) * bgB;

            frame_buffer[idx]     = finalR;
            frame_buffer[idx + 1] = finalG;
            frame_buffer[idx + 2] = finalB;
        }
    }
}




function draw_star(frame_buffer, fb_width, fb_height, stars) {
    // 从星等转换为相对亮度（归一化到 [0,1]，mag=0 → 1.0，mag=6 → ~0.01）
     // 增加一个衰减系数（平均蓝天亮度），以便白天能够掩盖亮星
    function magnitudeToRelativeLuminance(mag) {
        return 0.7 * Math.pow(10, -0.4 * mag);
    }

    const maxGlowRadius = 2; // 光晕最大半径（像素）

    for (const star of stars) {
        const starLumBase = magnitudeToRelativeLuminance(star[2]);
        const sx = star[0];
        const sy = star[1];

        // 遍历光晕区域（正方形包围圆）
        for (let dy = -maxGlowRadius; dy <= maxGlowRadius; dy++) {
            for (let dx = -maxGlowRadius; dx <= maxGlowRadius; dx++) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > maxGlowRadius) continue;

                const px = Math.round(sx + dx);
                const py = Math.round(sy + dy);
                if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

                // 获取背景亮度用于对比度抑制
                const bgIdx = (py * fb_width + px) * 4;
                const bgR = frame_buffer[bgIdx] / 255;
                const bgG = frame_buffer[bgIdx + 1] / 255;
                const bgB = frame_buffer[bgIdx + 2] / 255;
                const bgLum = 0.299 * bgR + 0.587 * bgG + 0.114 * bgB;

                // 计算恒星在该点的原始发光强度（带光晕衰减）
                const glowFactor = Math.exp(-dist * 0.3); // 调整衰减速度（0.3 可调）
                let starLum = starLumBase * glowFactor;

                // 对比度抑制：白天背景亮时，星星和光晕都应被压制
                const contrast = starLum / (bgLum + 0.001);
                let visibility = 1.0;
                if (contrast < 1.0) {
                    visibility = Math.pow(contrast, 3);
                }
                starLum *= visibility;

                // 转为 0–255 范围
                const add = Math.min(255, starLum * 255);

                // 叠加到 RGB（保持白色光晕，可改为彩色）
                frame_buffer[bgIdx]     = Math.min(255, frame_buffer[bgIdx]     + add);
                frame_buffer[bgIdx + 1] = Math.min(255, frame_buffer[bgIdx + 1] + add);
                frame_buffer[bgIdx + 2] = Math.min(255, frame_buffer[bgIdx + 2] + add);
            }
        }
    }
}









// 计算大气散射强度
function calculate_scattered_pixel(ray_vec, sun_vec) {
    if (isNaN(ray_vec[2])) return [0, 0, 0];

    const ray_length = Math.sqrt(ray_vec[0] * ray_vec[0] + ray_vec[1] * ray_vec[1] + ray_vec[2] * ray_vec[2]);
    if (ray_length === 0) return [0, 0, 0];

    const ray_norm = [
        ray_vec[0] / ray_length,
        ray_vec[1] / ray_length,
        ray_vec[2] / ray_length,
    ];

    // 太阳方向归一化
    const sun_vec_radius = Math.sqrt(sun_vec[0] * sun_vec[0] + sun_vec[1] * sun_vec[1] + sun_vec[2] * sun_vec[2]);
    const sun_norm = [
        sun_vec[0] / sun_vec_radius,
        sun_vec[1] / sun_vec_radius,
        sun_vec[2] / sun_vec_radius,
    ];


    // 太阳光入射路径：计算仰角、天顶角、大气光学质量
    const sunElevation = Math.asin(Math.max(-1, Math.min(1, sun_norm[2]))); // [-π/2, π/2]
    const sunZenith = Math.PI / 2 - sunElevation; // [0, π]
    const sunElevationDeg = sunElevation * 180 / Math.PI;
    let sunAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (sunElevationDeg >= 0) {
        const theta = 90 - sunElevationDeg; // 天顶角 in degrees
        sunAirMass = 1.0 / (Math.cos(sunZenith) + 0.50572 * Math.pow(96.07995 - theta, -1.6364));
    }
    else {
        sunAirMass = 40;
    }


    // 观察者视线的仰角、天顶角、大气光学质量
    const viewZenithAngle = Math.acos(Math.max(0, Math.min(1, ray_norm[2])));
    const viewZenithDeg = viewZenithAngle * 180 / Math.PI;
    const viewElevationDeg = 90 - viewZenithDeg;
    let viewAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (viewElevationDeg >= 0) {
        const theta = 90 - viewZenithDeg; // 天顶角 in degrees
        viewAirMass = 1.0 / (Math.cos(viewZenithAngle) + 0.50572 * Math.pow(96.07995 - theta, -1.6364));
    }
    else {
        viewAirMass = 40;
    }


    // 观察方向与太阳方向夹角
    const cosTheta = ray_norm[0] * sun_norm[0] +
                    ray_norm[1] * sun_norm[1] +
                    ray_norm[2] * sun_norm[2];


    // 米氏散射相函数
    const miePhase = Math.pow(
        1 + PHYSICS.MIE_G * PHYSICS.MIE_G - 2 * PHYSICS.MIE_G * cosTheta,
        -1.5
    );


    // 瑞利散射相函数
    const rayleighPhase = (1 + cosTheta * cosTheta) / 4 * 3;


    // 计算视线方向的大气密度系数：直觉上来看，密度越大，对散射的贡献越大
    const H = PHYSICS.ATMOSPHERE_HEIGHT; // km，标高
    const mu = Math.max(0.01, ray_norm[2]); // 避免除零，mu = cos(天顶角)
    const densityFactor = Math.exp(-mu / H);


    // 分波长计算瑞利散射系数
    const wavelengths = PHYSICS.RAYLEIGH_WAVELENGTH_FACTORS;
    const rayleighBetaBase = PHYSICS.RAYLEIGH_BETA; // 参考波长下的 β
    const referenceWavelength = wavelengths[1]; // G分量作为参考（550nm）
    const betaRayleigh = [];
    for (let i = 0; i < wavelengths.length; i++) {
        betaRayleigh[i] = rayleighBetaBase * Math.pow(referenceWavelength / wavelengths[i], 4);
    }


    // 米氏散射系数：当太阳接近地平线时，光线穿过更厚的低层大气，气溶胶路径长度剧增，米氏散射贡献显著上升
    const effectiveMieBeta = Math.min(PHYSICS.MIE_BETA_MAX, PHYSICS.MIE_BETA_BASE * sunAirMass);


    // 计算每个通道的散射强度（考虑光程衰减）
    const intensities = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // 散射光强度 ∝ 相函数 × exp(-totalBeta * sunAirMass) × density
        // 注意：实际是体散射积分，此处简化为比例模型
        const rayleighContrib = betaRayleigh[i] * rayleighPhase;
        const mieContrib = effectiveMieBeta * miePhase;
        const totalScattering = (rayleighContrib + mieContrib) * densityFactor;

        // 衰减：散射光在传播到观察者途中也会被吸收
        const totalBeta = betaRayleigh[i] + effectiveMieBeta; // 总消光系数（简化）
        let attenuation = 0;
        if (USE_SIMPLE_PHYSICS_MODEL) {
            attenuation = Math.exp(-totalBeta * sunAirMass * 0.1); // 另一种不符合物理但是还算好看的衰减模型
        }
        else {
            // 独立发现的关键修正：衰减中加入时间调节因子，防止白天出现过于明显的维纳斯带
            let scale = 0.5 * Math.cos(2 * sunElevation) + 0.501; // 调节因子，控制一天中不同时间的衰减强度
            attenuation = Math.exp(-totalBeta * viewAirMass * scale);
        }

        // 臭氧吸收
        const ozoneTransmittance = Math.exp(-PHYSICS.OZONE_ABSORPTION[i] * sunAirMass * 0.8); // 调节因子

        intensities[i] = totalScattering * attenuation * ozoneTransmittance;
    }

    // 归一化或缩放到 [0,1]
    let [r, g, b] = intensities;

    // 太阳落到地平线以下时，进一步衰减散射光
    const night_attn = (sunElevationDeg >= 0) ? 1.0 : Math.max(0, Math.exp(0.016 * sunElevationDeg));
    r *= night_attn;
    g *= night_attn;
    b *= night_attn;

    // 全局增益
    const global_gain = 2.0;

    return [
        Math.min(1, r * global_gain), // R
        Math.min(1, g * global_gain), // G
        Math.min(1, b * global_gain)  // B
    ];
}



class SkyRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        this.canvas.width = RADIUS * 2;
        this.canvas.height = RADIUS * 2;

        function adaptRatio(context) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
            return devicePixelRatio / backingStoreRatio;
        }
        this.RATIO = adaptRatio(this.ctx);
        this.canvas.width = this.canvas.width * this.RATIO;
        this.canvas.height = this.canvas.height * this.RATIO;
        RADIUS *= this.RATIO;

        // 获取DOM元素
        this.angleSlider = document.getElementById('sun_altitude_deg');
        this.angleValue = document.getElementById('angleValue');
        
        // 监听滑块变化
        this.angleSlider.addEventListener('input', () => {
            this.update_sun_altitude();
        });
        
        // 初始化太阳角度
        this.sun_altitude_deg = 45; // 弧度
        this.update_sun_altitude();
    }

    update_sun_altitude() {
        this.sun_altitude_deg = parseFloat(this.angleSlider.value);
        this.angleValue.textContent = `${this.angleSlider.value}°`;
        this.render();
    }


    // 渲染整个天空
    render() {
        const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
        const frame_buffer = imageData.data;

        draw_moon(
            frame_buffer, RADIUS*2, RADIUS*2, RADIUS/2, RADIUS/2,
            0.8, 30, 90-this.sun_altitude_deg, this.sun_altitude_deg/3);

        const star0_proj_xy = horizontal_to_projection_xy(0  , 60, RADIUS);
        const star1_proj_xy = horizontal_to_projection_xy(45 , 60, RADIUS);
        const star2_proj_xy = horizontal_to_projection_xy(90 , 60, RADIUS);
        const star3_proj_xy = horizontal_to_projection_xy(135, 60, RADIUS);
        const star4_proj_xy = horizontal_to_projection_xy(180, 60, RADIUS);
        const star5_proj_xy = horizontal_to_projection_xy(225, 60, RADIUS);
        const star6_proj_xy = horizontal_to_projection_xy(270, 60, RADIUS);
        const star7_proj_xy = horizontal_to_projection_xy(315, 60, RADIUS);

        const stars = [
            [star0_proj_xy[0], star0_proj_xy[1], Math.random() * 1.5],
            [star1_proj_xy[0], star1_proj_xy[1], Math.random() * 1.5],
            [star2_proj_xy[0], star2_proj_xy[1], Math.random() * 1.5],
            [star3_proj_xy[0], star3_proj_xy[1], Math.random() * 1.5],
            [star4_proj_xy[0], star4_proj_xy[1], Math.random() * 1.5],
            [star5_proj_xy[0], star5_proj_xy[1], Math.random() * 1.5],
            [star6_proj_xy[0], star6_proj_xy[1], Math.random() * 1.5],
            [star7_proj_xy[0], star7_proj_xy[1], Math.random() * 1.5],
        ];

        const sun_azi = this.sun_altitude_deg + 180;
        const sun_alt = 80 * Math.cos(to_rad(this.sun_altitude_deg));
        const sun_r = RADIUS;

        const sun_vec = horizontal_to_xyz(sun_azi, sun_alt, sun_r);

        const sun_projection_xy = horizontal_to_projection_xy(sun_azi, sun_alt, sun_r);

        for (let y = 0; y < this.canvas.height; y++) {
            for (let x = 0; x < this.canvas.width; x++) {
                const pixel_index = (y * this.canvas.width + x) * 4;

                // 计算从观察者到该像素的方向向量

                const cx = RADIUS;
                const cy = RADIUS;
                const dx = x - cx;
                const dy = y - cy;

                let ray_vec = [0, 0, 0];
                if (USE_FISHEYE_PROJECTION) {
                    // 鱼眼投影
                    let r = Math.sqrt(dx*dx + dy*dy) / RADIUS; // 归一化半径
                    if (r <= 1) {
                        const theta = r * Math.PI / 2; // 天顶角
                        const phi = Math.atan2(dy, dx); // 方位角
                        ray_vec = [
                            Math.sin(theta) * Math.cos(phi),
                            Math.sin(theta) * Math.sin(phi),
                            Math.cos(theta)
                        ];
                    }
                }
                else {
                    // XY投影
                    ray_vec = [ dx, dy, Math.sqrt(RADIUS*RADIUS - (dx*dx + dy*dy)) ];
                }

                const scattered_sky_pixel = calculate_scattered_pixel(ray_vec, sun_vec);


                // 应用散射颜色
                frame_buffer[pixel_index    ] += Math.min(255, scattered_sky_pixel[0] * 255);
                frame_buffer[pixel_index + 1] += Math.min(255, scattered_sky_pixel[1] * 255);
                frame_buffer[pixel_index + 2] += Math.min(255, scattered_sky_pixel[2] * 255);
                frame_buffer[pixel_index + 3] = 255;
            }
        }

        draw_star(frame_buffer, RADIUS*2, RADIUS*2, stars);

        star_burst_filter(frame_buffer, RADIUS*2, RADIUS*2, sun_projection_xy[0], sun_projection_xy[1], 0, 0.97, 160);


        // draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS * 0.3, 1, 64, 64, 64, 255);

        // 绘制散射后的天空
        this.ctx.putImageData(imageData, 0, 0);
    }

}

// 初始化渲染器
window.onload = function() {
    const renderer = new SkyRenderer('skyCanvas');

    let alt = 0;

    function draw() {
        renderer.angleSlider.value = alt;
        alt++;
        if (alt >= 180) alt = -180;
        renderer.update_sun_altitude();
        requestAnimationFrame(draw);
    }

    draw();
};
    </script>
</body>
</html>
