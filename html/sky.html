<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>天空大气光学模拟</title>
</head>
<body>
    <div class="container">
        <canvas id="skyCanvas" width="240" height="240" style="width: 240px; height: 240px;"></canvas>
        <div class="controls">
            <label for="sunAngle">alt:</label>
            <input type="range" id="sunAngle" min="-360" max="360" value="60" step="0.1" style="width: 100%;">
            <span class="value-display" id="angleValue">--°</span>
        </div>
    </div>

    <script>



const IS_FISHEYE = false; // 是否使用鱼眼投影（否则使用XY投影）
const IS_SIMPLE_MODEL = false; // 是否使用不符合物理但是比较好看的大气光学模型

let moonTextureData;
let texWidth;
let texHeight;

const img = new Image();
img.src = '../image/H/moon.jpg';
img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    texWidth = img.width;
    texHeight = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    moonTextureData = ctx.getImageData(0, 0, img.width, img.height).data; // Uint8ClampedArray
};





// 物理常数
const PHYSICS = {
    // 大气光学参数
    MIE_G: 0.9,           // 米氏散射不对称因子
    RAYLEIGH_BETA: 0.3,  // 瑞利散射系数 感觉是海拔越高越小
    MIE_BETA_BASE: 0.001,      // 米氏散射系数 越大光斑越大
    MIE_BETA_MAX: 0.1,      // 米氏散射系数 越大光斑越大
    ATMOSPHERE_HEIGHT: 8.5, // 虚拟大气层厚度 (km)
    SUN_ANGULAR_SIZE: 0.5, // 太阳视直径 (度)

    // 波长相关的瑞利散射系数 (近似)
    RAYLEIGH_WAVELENGTH_FACTORS: [
        680, // Red
        550, // Green
        450  // Blue
    ],

    // 臭氧吸收系数（近似，单位：1/km，针对 R/G/B 通道）
    // 参考 Chappuis 吸收带：蓝绿光吸收强，红光弱
    OZONE_ABSORPTION: [
        0.005,  // Red   (650nm) — 弱吸收
        0.040,  // Green (550nm) — 中等吸收
        0.025   // Blue  (450nm) — 比绿光略弱（实际臭氧在~600nm最强，但简化模型）
    ],

};











function star_burst_filter(pixels, width, height, sunScreenPos, sunBrightness) {
    const threshold = 0.9;
    const brightMask = new Array(width * height * 4).fill(0);
    
    // 1. 创建高亮掩码
    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i] / 255, g = pixels[i+1] / 255, b = pixels[i+2] / 255;
        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
        if (lum > threshold) {
            const factor = Math.min(1, (lum - threshold) * 5);
            brightMask[i] = r * factor * 255;
            brightMask[i+1] = g * factor * 255;
            brightMask[i+2] = b * factor * 255;
            brightMask[i+3] = 255;
        }
    }

    // 2. 如果提供了 sunScreenPos，检查该位置是否在 brightMask 中足够亮
    let starCenter = null;
    let starColor = [0, 0, 0];
    if (sunScreenPos) {
        const { x: cx, y: cy } = sunScreenPos;
        const ix = Math.floor(cx), iy = Math.floor(cy);
        if (ix >= 0 && ix < width && iy >= 0 && iy < height) {
            const idx = (iy * width + ix) * 4;
            const br = brightMask[idx], bg = brightMask[idx+1], bb = brightMask[idx+2];
            const maskLum = 0.299 * br + 0.587 * bg + 0.114 * bb;
            // 只有当 brightMask 在该位置有显著亮度时，才启用星芒
            if (maskLum > 0.1) { // 阈值可调，避免噪声触发
                starCenter = { x: cx, y: cy };
                starColor = [br, bg, bb];
            }
        }
    }

    // 若未提供有效 sunScreenPos 或位置不亮，则可选：自动找最亮点（此处暂不实现，保持原逻辑）

    // 3. 生成星芒
    const starResult = new Array(width * height * 4).fill(0);
    const directions = [
        [1, 0], [0, 1], [1, 1], [1, -1]
    ];
    const blurLength = 100;
    const decay = 0.97;

    if (starCenter) {
        const { x: cx, y: cy } = starCenter;
        const [sr, sg, sb] = starColor;

        for (const [dx, dy] of directions) {
            const len = Math.hypot(dx, dy);
            const ndx = dx / len, ndy = dy / len;

            for (let d = 1; d <= blurLength; d++) {
                const alpha = Math.pow(decay, d);
                if (alpha < 0.01) break;

                const px = Math.floor(cx + ndx * d);
                const py = Math.floor(cy + ndy * d);
                const nx = Math.floor(cx - ndx * d);
                const ny = Math.floor(cy - ndy * d);

                // 正向
                if (px >= 0 && px < width && py >= 0 && py < height) {
                    const idx = (py * width + px) * 4;
                    starResult[idx]     += sr * alpha;
                    starResult[idx + 1] += sg * alpha;
                    starResult[idx + 2] += sb * alpha;
                }
                // 反向
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = (ny * width + nx) * 4;
                    starResult[idx]     += sr * alpha;
                    starResult[idx + 1] += sg * alpha;
                    starResult[idx + 2] += sb * alpha;
                }
            }
        }
    }

    // 4. 叠加星芒到原图
    for (let i = 0; i < pixels.length; i++) {
        pixels[i] = Math.min(255, pixels[i] + starResult[i]);
    }
}


// 基于球面几何 terminator 的月相绘制（带物理合理的软边缘）
function draw_moon(frame_buffer, fb_width, fb_height, center_x, center_y, lum, radius, phase, alpha) {
    const moonX = center_x;
    const moonY = center_y;
    const moonRadius = radius;

    // 太阳方向（单位向量），同原逻辑
    const cosPhase = Math.cos(phase);
    const sinPhase = Math.sin(phase);
    const sunDirX = cosPhase * Math.cos(alpha);
    const sunDirY = cosPhase * Math.sin(alpha);
    const sunDirZ = sinPhase;

    const sunLen = Math.sqrt(sunDirX * sunDirX + sunDirY * sunDirY + sunDirZ * sunDirZ);
    const sunUnitX = sunLen > 0 ? sunDirX / sunLen : 1;
    const sunUnitY = sunLen > 0 ? sunDirY / sunLen : 0;
    const sunUnitZ = sunLen > 0 ? sunDirZ / sunLen : 0;

    // 颜色与环境光
    const litColor = [220, 220, 210];
    const darkColor = [10, 10, 20];
    const ambient = 0.01;

    // 半影角宽度（弧度）：太阳角半径 ≈ 0.0047 rad，取稍大值保证可见性
    const PENUMBRA_HALF_ANGLE = 0.2; // ≈ 0.5°

    const r2 = moonRadius * moonRadius;
    for (let dy = -moonRadius; dy <= moonRadius; dy++) {
        for (let dx = -moonRadius; dx <= moonRadius; dx++) {
            if (dx * dx + dy * dy > r2) continue;

            const px = Math.floor(moonX + dx);
            const py = Math.floor(moonY + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            // 构造单位球面上的表面点（归一化位置向量 = 法向量）
            const len = Math.sqrt(dx * dx + dy * dy + r2 - dx * dx - dy * dy); // = moonRadius
            // 实际上，(dx, dy, dz) 在半径为 moonRadius 的球面上，所以单位向量为：
            const nx = dx / moonRadius;
            const ny = dy / moonRadius;
            const nz = Math.sqrt(Math.max(0, r2 - dx * dx - dy * dy)) / moonRadius;

            // 关键：计算该点与 terminator 的球面角距离
            // terminator 是太阳方向与月球中心构成的大圆
            // 点积 dot = cos(θ)，其中 θ 是表面点与太阳方向的夹角
            const dot = nx * sunUnitX + ny * sunUnitY + nz * sunUnitZ;

            // θ = acos(dot)，但避免 acos 开销，直接用 dot 表示角度关系
            // terminator 位于 dot = 0（即 θ = 90°）
            // 我们定义 signed_angle_dist ∝ -dot （因为 dot>0 为亮区）
            // 将角距离映射为线性过渡变量（单位：弧度等效）

            // 使用小角度近似：angle ≈ sqrt(1 - dot^2) 不适用；更简单：
            // 直接用 dot 作为“余弦空间”的代理变量，其梯度在 terminator 附近 ≈ 1/rad
            // 因此，我们定义“有效角偏移”为：
            const angleFromTerminator = Math.acos(Math.max(-1, Math.min(1, dot))) - Math.PI / 2; // ∈ [-π/2, π/2]

            // 或者更高效（避免 acos）：利用 sin(θ - π/2) = -cosθ = -dot
            // 在 terminator 附近（θ≈π/2），有 θ - π/2 ≈ -dot （一阶泰勒）
            // 所以可用：approxAngle = -dot （单位为“弧度等效”，需缩放）
            // 但为保精度，这里采用 acos 方法（可选优化见注释）

            // === 软边缘判断 ===
            let intensity;
            if (angleFromTerminator >= PENUMBRA_HALF_ANGLE) {
                intensity = 1.0; // 完全照亮
            } else if (angleFromTerminator <= -PENUMBRA_HALF_ANGLE) {
                intensity = ambient; // 完全背光
            } else {
                // 映射到 [0,1]
                const t = (angleFromTerminator + PENUMBRA_HALF_ANGLE) / (2 * PENUMBRA_HALF_ANGLE);
                const smoothT = t * t * (3 - 2 * t); // smoothstep
                intensity = ambient + (1 - ambient) * smoothT;
            }

            // 调整全局亮度
            intensity *= lum;






            // === 纹理映射：法向量 → 经纬度 → UV ===
            // 注意：月球贴图通常是 equirectangular 投影，经度 0 在中间
            const lon = Math.atan2(nx, nz); // [-π, π]
            const lat = Math.asin(ny);       // [-π/2, π/2]

            let u = (lon + Math.PI) / (2 * Math.PI); // [0, 1)
            let v = (lat + Math.PI / 2) / Math.PI;   // [0, 1]

            // 处理边缘 wrap（可选，但推荐）
            u = u - Math.floor(u); // 保证 [0,1)

            // 双线性采样
            const tx = u * texWidth - 0.5;
            const ty = v * texHeight - 0.5;

            const x0 = Math.floor(tx);
            const y0 = Math.floor(ty);
            const x1 = (x0 + 1) % texWidth;
            const y1 = Math.min(y0 + 1, texHeight - 1);

            const wx = tx - x0;
            const wy = ty - y0;

            function getPixel(tex, x, y, c) {
                return tex[((y * texWidth + x) * 4) + c];
            }

            const c00_r = getPixel(moonTextureData, x0, y0, 0);
            const c00_g = getPixel(moonTextureData, x0, y0, 1);
            const c00_b = getPixel(moonTextureData, x0, y0, 2);

            const c10_r = getPixel(moonTextureData, x1, y0, 0);
            const c10_g = getPixel(moonTextureData, x1, y0, 1);
            const c10_b = getPixel(moonTextureData, x1, y0, 2);

            const c01_r = getPixel(moonTextureData, x0, y1, 0);
            const c01_g = getPixel(moonTextureData, x0, y1, 1);
            const c01_b = getPixel(moonTextureData, x0, y1, 2);

            const c11_r = getPixel(moonTextureData, x1, y1, 0);
            const c11_g = getPixel(moonTextureData, x1, y1, 1);
            const c11_b = getPixel(moonTextureData, x1, y1, 2);

            // bilinear interpolation
            const r0 = c00_r + wx * (c10_r - c00_r);
            const g0 = c00_g + wx * (c10_g - c00_g);
            const b0 = c00_b + wx * (c10_b - c00_b);

            const r1 = c01_r + wx * (c11_r - c01_r);
            const g1 = c01_g + wx * (c11_g - c01_g);
            const b1 = c01_b + wx * (c11_b - c01_b);

            let texR = r0 + wy * (r1 - r0);
            let texG = g0 + wy * (g1 - g0);
            let texB = b0 + wy * (b1 - b0);

            // 应用光照强度（保留你的明暗效果）
            const r = Math.round(texR * intensity);
            const g = Math.round(texG * intensity);
            const b = Math.round(texB * intensity);




            // const r = Math.round(darkColor[0] + intensity * (litColor[0] - darkColor[0]));
            // const g = Math.round(darkColor[1] + intensity * (litColor[1] - darkColor[1]));
            // const b = Math.round(darkColor[2] + intensity * (litColor[2] - darkColor[2]));

            frame_buffer[idx]     = r;
            frame_buffer[idx + 1] = g;
            frame_buffer[idx + 2] = b;
        }
    }
}




function draw_star(frame_buffer, fb_width, fb_height, stars) {
    // 从星等转换为相对亮度（归一化到 [0,1]，mag=0 → 1.0，mag=6 → ~0.01）
     // 增加一个衰减系数（平均蓝天亮度），以便白天能够掩盖亮星
    function magnitudeToRelativeLuminance(mag) {
        return 0.7 * Math.pow(10, -0.4 * mag);
    }

    const maxGlowRadius = 2; // 光晕最大半径（像素）

    for (const star of stars) {
        const starLumBase = magnitudeToRelativeLuminance(star.mag);
        const sx = star.x;
        const sy = star.y;

        // 遍历光晕区域（正方形包围圆）
        for (let dy = -maxGlowRadius; dy <= maxGlowRadius; dy++) {
            for (let dx = -maxGlowRadius; dx <= maxGlowRadius; dx++) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > maxGlowRadius) continue;

                const px = Math.round(sx + dx);
                const py = Math.round(sy + dy);
                if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

                // 获取背景亮度用于对比度抑制
                const bgIdx = (py * fb_width + px) * 4;
                const bgR = frame_buffer[bgIdx] / 255;
                const bgG = frame_buffer[bgIdx + 1] / 255;
                const bgB = frame_buffer[bgIdx + 2] / 255;
                const bgLum = 0.299 * bgR + 0.587 * bgG + 0.114 * bgB;

                // 计算恒星在该点的原始发光强度（带光晕衰减）
                const glowFactor = Math.exp(-dist * 0.3); // 调整衰减速度（0.3 可调）
                let starLum = starLumBase * glowFactor;

                // 对比度抑制：白天背景亮时，星星和光晕都应被压制
                const contrast = starLum / (bgLum + 0.001);
                let visibility = 1.0;
                if (contrast < 1.0) {
                    visibility = Math.pow(contrast, 3);
                }
                starLum *= visibility;

                // 转为 0–255 范围
                const add = Math.min(255, starLum * 255);

                // 叠加到 RGB（保持白色光晕，可改为彩色）
                frame_buffer[bgIdx]     = Math.min(255, frame_buffer[bgIdx]     + add);
                frame_buffer[bgIdx + 1] = Math.min(255, frame_buffer[bgIdx + 1] + add);
                frame_buffer[bgIdx + 2] = Math.min(255, frame_buffer[bgIdx + 2] + add);
            }
        }
    }
}












// 计算大气散射强度
function calculateScattering(rayDir, sunDir) {
    if (isNaN(rayDir.z)) return { r: 0, g: 0, b: 0 };

    const rayLength = Math.sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y + rayDir.z * rayDir.z);
    if (rayLength === 0) return { r: 0, g: 0, b: 0 };

    const normalizedRay = {
        x: rayDir.x / rayLength,
        y: rayDir.y / rayLength,
        z: rayDir.z / rayLength,
    };

    // 太阳方向归一化
    const sunR = Math.sqrt(sunDir.x * sunDir.x + sunDir.y * sunDir.y + sunDir.z * sunDir.z);
    const sunDirection = {
        x: sunDir.x / sunR,
        y: sunDir.y / sunR,
        z: sunDir.z / sunR,
    };


    // 太阳光入射路径：计算仰角、天顶角、大气光学质量
    const sunElevation = Math.asin(Math.max(-1, Math.min(1, sunDirection.z))); // [-π/2, π/2]
    const sunZenith = Math.PI / 2 - sunElevation; // [0, π]
    const sunElevationDeg = sunElevation * 180 / Math.PI;
    let sunAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (sunElevationDeg >= 0) {
        const theta = 90 - sunElevationDeg; // 天顶角 in degrees
        sunAirMass = 1.0 / (Math.cos(sunZenith) + 0.50572 * Math.pow(96.07995 - theta, -1.6364));
    }
    else {
        sunAirMass = 40;
    }


    // 观察者视线的仰角、天顶角、大气光学质量
    const viewZenithAngle = Math.acos(Math.max(0, Math.min(1, normalizedRay.z)));
    const viewZenithDeg = viewZenithAngle * 180 / Math.PI;
    const viewElevationDeg = 90 - viewZenithDeg;
    let viewAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (viewElevationDeg >= 0) {
        const theta = 90 - viewZenithDeg; // 天顶角 in degrees
        viewAirMass = 1.0 / (Math.cos(viewZenithAngle) + 0.50572 * Math.pow(96.07995 - theta, -1.6364));
    }
    else {
        viewAirMass = 40;
    }


    // 观察方向与太阳方向夹角
    const cosTheta = normalizedRay.x * sunDirection.x +
                    normalizedRay.y * sunDirection.y +
                    normalizedRay.z * sunDirection.z;


    // 米氏散射相函数
    const miePhase = Math.pow(
        1 + PHYSICS.MIE_G * PHYSICS.MIE_G - 2 * PHYSICS.MIE_G * cosTheta,
        -1.5
    );


    // 瑞利散射相函数
    const rayleighPhase = (1 + cosTheta * cosTheta) / 4 * 3;


    // 计算视线方向的大气密度系数：直觉上来看，密度越大，对散射的贡献越大
    const H = PHYSICS.ATMOSPHERE_HEIGHT; // km，标高
    const mu = Math.max(0.01, normalizedRay.z); // 避免除零，mu = cos(天顶角)
    const densityFactor = Math.exp(-mu / H);


    // 分波长计算瑞利散射系数
    const wavelengths = PHYSICS.RAYLEIGH_WAVELENGTH_FACTORS;
    const rayleighBetaBase = PHYSICS.RAYLEIGH_BETA; // 参考波长下的 β
    const referenceWavelength = wavelengths[1]; // G分量作为参考（550nm）
    const betaRayleigh = [];
    for (let i = 0; i < wavelengths.length; i++) {
        betaRayleigh[i] = rayleighBetaBase * Math.pow(referenceWavelength / wavelengths[i], 4);
    }


    // 米氏散射系数：当太阳接近地平线时，光线穿过更厚的低层大气，气溶胶路径长度剧增，米氏散射贡献显著上升
    const effectiveMieBeta = Math.min(PHYSICS.MIE_BETA_MAX, PHYSICS.MIE_BETA_BASE * sunAirMass);


    // 计算每个通道的散射强度（考虑光程衰减）
    const intensities = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // 散射光强度 ∝ 相函数 × exp(-totalBeta * sunAirMass) × density
        // 注意：实际是体散射积分，此处简化为比例模型
        const rayleighContrib = betaRayleigh[i] * rayleighPhase;
        const mieContrib = effectiveMieBeta * miePhase;
        const totalScattering = (rayleighContrib + mieContrib) * densityFactor;

        // 衰减：散射光在传播到观察者途中也会被吸收
        const totalBeta = betaRayleigh[i] + effectiveMieBeta; // 总消光系数（简化）
        let attenuation = 0;
        if (IS_SIMPLE_MODEL) {
            attenuation = Math.exp(-totalBeta * sunAirMass * 0.1); // 另一种不符合物理但是还算好看的衰减模型
        }
        else {
            // 独立发现的关键修正：衰减中加入时间调节因子，防止白天出现过于明显的维纳斯带
            let scale = 0.5 * Math.cos(2 * sunElevation) + 0.501; // 调节因子，控制一天中不同时间的衰减强度
            attenuation = Math.exp(-totalBeta * viewAirMass * scale);
        }

        // 臭氧吸收
        const ozoneTransmittance = Math.exp(-PHYSICS.OZONE_ABSORPTION[i] * sunAirMass * 0.8); // 调节因子

        intensities[i] = totalScattering * attenuation * ozoneTransmittance;
    }

    // 归一化或缩放到 [0,1]
    let [r, g, b] = intensities;

    // 最终裁剪
    return {
        r: Math.min(1, r * 2.0), // 根据场景调整全局增益
        g: Math.min(1, g * 2.0),
        b: Math.min(1, b * 2.0)
    };
}

function to_rad(deg) {
    return deg * Math.PI / 180;
}

function to_deg(rad) {
    return rad * 180 / Math.PI;
}

function horizontal_to_ground_coords(azimuth_deg, altitude_deg, R) {
    const altRad = to_rad(altitude_deg);
    const azRad = to_rad(azimuth_deg);
    return {
        x: R * Math.cos(altRad) * Math.sin(azRad),
        y: R * Math.cos(altRad) * Math.cos(azRad),
        z: R * Math.sin(altRad)
    };
}


class SkyRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        
        function adaptRatio(context) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
            return devicePixelRatio / backingStoreRatio;
        }
        this.RATIO = adaptRatio(this.ctx);
        this.canvas.width = this.canvas.width * this.RATIO;
        this.canvas.height = this.canvas.height * this.RATIO;
        
        // 获取DOM元素
        this.angleSlider = document.getElementById('sunAngle');
        this.angleValue = document.getElementById('angleValue');
        
        // 监听滑块变化
        this.angleSlider.addEventListener('input', () => {
            this.updateSunAngle();
        });
        
        // 初始化太阳角度
        this.sunAngle = 45 * Math.PI / 180; // 弧度
        this.updateSunAngle();
    }

    updateSunAngle() {
        this.sunAngle = parseFloat(this.angleSlider.value) * Math.PI / 180;
        this.angleValue.textContent = `${this.angleSlider.value}°`;
        this.render();
    }

    // 计算太阳位置
    getSunPosition() {
        const R = this.canvas.height / 2;
        return {
            x: R + R * Math.cos(this.sunAngle),
            y: R
        };
    }

    // 渲染整个天空
    render() {
        const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
        const frame_buffer = imageData.data;

        const R = this.canvas.height / 2;

        draw_moon(
            frame_buffer, R*2, R*2, R/2, R/2,
            0.8, 30, Math.PI / 2 - this.sunAngle, this.sunAngle);

        const stars = [
            { x: R - 50, y: R - 50, mag: 0.0 },
            { x: R - 50, y: R + 50, mag: 0.5 },
            { x: R + 50, y: R - 50, mag: 1.0 },
            { x: R + 50, y: R + 50, mag: 1.2 }
        ];


        const sunPos = this.getSunPosition();

        // const sunDir = {
        //     x: R * Math.cos(this.sunAngle),
        //     y: 0,
        //     z: R * Math.sin(this.sunAngle)
        // };

        const sunDir = horizontal_to_ground_coords(
            90, // azimuth
            parseInt(this.angleSlider.value), // altitude
            R
        );

        for (let y = 0; y < this.canvas.height; y++) {
            for (let x = 0; x < this.canvas.width; x++) {
                const pixelIndex = (y * this.canvas.width + x) * 4;

                // 计算从观察者到该像素的方向向量

                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const dx = x - cx;
                const dy = y - cy;

                let rayDir = {x: 0, y: 0, z: 0};
                if (IS_FISHEYE) {
                    // 鱼眼投影
                    let r = Math.sqrt(dx*dx + dy*dy) / (this.canvas.height / 2); // 归一化半径
                    if (r <= 1) {
                        const theta = r * Math.PI / 2; // 天顶角
                        const phi = Math.atan2(dy, dx); // 方位角
                        rayDir = {
                            x: Math.sin(theta) * Math.cos(phi),
                            y: Math.sin(theta) * Math.sin(phi),
                            z: Math.cos(theta)
                        };
                    }
                }
                else {
                    // XY投影
                    rayDir = {
                        x: dx,
                        y: dy,
                        z: Math.sqrt(R*R - (dx*dx + dy*dy))
                    };
                }

                const scatterColor = calculateScattering(rayDir, sunDir);

                // 应用散射颜色
                frame_buffer[pixelIndex] += Math.min(255, scatterColor.r * 255);
                frame_buffer[pixelIndex + 1] += Math.min(255, scatterColor.g * 255);
                frame_buffer[pixelIndex + 2] += Math.min(255, scatterColor.b * 255);
                frame_buffer[pixelIndex + 3] = 255;
            }
        }

        draw_star(frame_buffer, this.canvas.width, this.canvas.height, stars);

        star_burst_filter(frame_buffer, this.canvas.width, this.canvas.height, sunPos, 0, 0.97, 160);

        // 绘制散射后的天空
        this.ctx.putImageData(imageData, 0, 0);
    }

}

// 初始化渲染器
window.onload = function() {
    const renderer = new SkyRenderer('skyCanvas');

    let alt = 0;

    setInterval(() => {
        renderer.angleSlider.value = alt;
        alt++;
        if (alt >= 180) alt = -180;
        renderer.updateSunAngle();
    }, 0);
};
    </script>
</body>
</html>
