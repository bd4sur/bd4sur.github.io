<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>天空大气光学模拟</title>
    <style>
body {
    background-color: #000000;
    color: #fff;
}
    </style>
</head>
<body>
    <div class="container" style="text-align: center;">
        <div>星历+天空大气光学模拟</div>
        <div>&copy; BD4SUR 2011-08 2011-09 2026-01</div>
        <table style="margin: 0px auto;">
            <tr><td></td><td>北 N</td><td></td></tr>
            <tr>
                <td>东 E</td>
                <td><canvas id="skyCanvas" width="240" height="240" style="width: 240px; height: 240px;"></canvas></td>
                <td>W 西</td>
            </tr>
            <tr><td></td><td>南 S</td><td></td></tr>
        </table>
        <div id="datetime">-</div>
        <div>屏幕朝向地面，顶部指向北方</div>
        <div id="fps">FPS: --</div>
    </div>

    <script src="../script/eph.js"></script>
    <script>



const USE_FISHEYE_PROJECTION = true; // 是否使用鱼眼投影（否则使用XY投影）


let moon_texture_width = 160;
let moon_texture_height = 160;

const img = new Image();
img.src = '../image/H/moon.jpg';
img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    moon_texture_width = img.width;
    moon_texture_height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    moon_texture_rgba = ctx.getImageData(0, 0, img.width, img.height).data; // Uint8ClampedArray
    // console.log(JSON.stringify(Array.from(moon_texture_rgba)));
};

let counter = 3600*6;

let RADIUS = 120;

// 物理常数
const PHYSICS = {
    // 大气光学参数
    MIE_G: 0.9,           // 米氏散射不对称因子
    RAYLEIGH_BETA: 0.3,  // 瑞利散射系数 感觉是海拔越高越小
    MIE_BETA_BASE: 0.001,      // 米氏散射系数 越大光斑越大
    MIE_BETA_MAX: 0.1,      // 米氏散射系数 越大光斑越大
    ATMOSPHERE_HEIGHT: 8.5, // 虚拟大气层厚度 (km)
    SUN_ANGULAR_SIZE: 0.5, // 太阳视直径 (度)

    // 波长相关的瑞利散射系数 (近似)
    RAYLEIGH_WAVELENGTH_FACTORS: [
        680, // Red
        550, // Green
        450  // Blue
    ],

    // 臭氧吸收系数
    OZONE_ABSORPTION: [
        0.005,  // Red   (650nm) — 弱吸收
        0.040,  // Green (550nm) — 中等吸收
        0.025   // Blue  (450nm) — 比绿光略弱（实际臭氧在~600nm最强，但简化模型）
    ],
};


function to_rad(deg) {
    return deg * Math.PI / 180;
}

function to_deg(rad) {
    return rad * 180 / Math.PI;
}

// 将hms格式的赤经转为度数
function ra_hms_to_deg(h, m, s) {
    let totalHours = h + m / 60.0 + s / 3600.0;
    let degrees = totalHours * 15.0;
    degrees = degrees % 360;
    if (degrees < 0) degrees += 360;
    return degrees;
}

// 将度分秒格式的赤纬转为度数
function dec_dms_to_decimal(d, m, s) {
    const sign = d < 0 ? -1 : 1;
    const absD = Math.abs(d);
    const decimal = sign * (absD + m / 60 + s / 3600);
    return decimal;
}

// 地平天球的球坐标系→地平天球的笛卡尔坐标系
function horizontal_to_xyz(azimuth_deg, altitude_deg, R) {
    const altRad = to_rad(altitude_deg);
    const azRad = to_rad(180 + azimuth_deg);
    return [
        R * Math.cos(altRad) * Math.sin(azRad),
        R * Math.cos(altRad) * Math.cos(azRad),
        R * Math.sin(altRad)
    ];
}

// 地平天球的球坐标系→地平天球的笛卡尔坐标系→投影到地面投影坐标系
function horizontal_to_screen_xy(azimuth_deg, altitude_deg, R) {
    // 鱼眼投影
    if (USE_FISHEYE_PROJECTION) {
        const az_rad = (-azimuth_deg * Math.PI) / 180; // 因为是躺在地上看天，所以方位角是从正北逆时针旋转
        const alt_rad = (altitude_deg * Math.PI) / 180;
        // 天顶距（zenith distance）θ = π/2 - altitude
        const theta = Math.PI / 2 - alt_rad; // 弧度
        // 等距鱼眼投影：r ∝ θ，且当地平线（θ = π/2）时 r = R
        // 所以 r = R * (θ / (π/2)) = (2R / π) * θ
        const r = (2 * R / Math.PI) * theta;
        // 投影到平面：X指向东（注意因为是躺在地上看天，所以东是屏幕坐标系的左侧/负半轴），Y指向北
        // azimuth=0°（北）→ (0, r)；azimuth=90°（东）→ (r, 0)
        const X = r * Math.sin(az_rad);
        const Y = -r * Math.cos(az_rad);
        return [X + RADIUS, Y + RADIUS];
    }
    // XY投影：笛卡尔坐标系的XY直接垂直投射到地平面上
    else {
        const xyz = horizontal_to_xyz(azimuth_deg, altitude_deg, R);
        if (altitude_deg >= 0) {
            return [xyz[0] + RADIUS, xyz[1] + RADIUS]; // 转到canvas的屏幕坐标系
        }
        else {
            return [xyz[0] - RADIUS, xyz[1] - RADIUS]; // 地平面以下的，移出canvas显示范围
        }
    }
}


// 屏幕坐标系→地面投影坐标系→反演回地平天球的直角坐标系
function screen_xy_to_xyz(scr_x, scr_y) {
    const cx = RADIUS;
    const cy = RADIUS;
    const dx = scr_x - cx;
    const dy = scr_y - cy;
    let hor_xyz = [0, 0, 0];
    // 鱼眼投影
    if (USE_FISHEYE_PROJECTION) {
        let r = Math.sqrt(dx*dx + dy*dy) / RADIUS; // 归一化半径
        if (r <= 1) {
            const theta = r * Math.PI / 2; // 天顶角
            const phi = Math.atan2(dy, dx); // 方位角
            hor_xyz = [
                RADIUS * Math.sin(theta) * Math.cos(phi),
                RADIUS * Math.sin(theta) * Math.sin(phi),
                RADIUS * Math.cos(theta)
            ];
        }
    }
    // XY投影
    else {
        hor_xyz = [ dx, dy, Math.sqrt(RADIUS*RADIUS - (dx*dx + dy*dy)) ];
    }
    return hor_xyz;
}


function get_luminance(r, g, b) {
    return 0.299 * r + 0.587 * g + 0.114 * b;
}







function star_burst_filter(frame_buffer, width, height, sun_screen_x, sun_screen_y, sunBrightness) {
    // 亮度阈值
    const threshold = 0.9;

    const cx = sun_screen_x;
    const cy = sun_screen_y;
    const ix = Math.floor(cx), iy = Math.floor(cy);
    if (ix < 0 || ix >= width || iy < 0 || iy >= height) return;

    // 1. 读取原图中该像素的亮度
    const idx = (iy * width + ix) * 4;
    const r = frame_buffer[idx] / 255;
    const g = frame_buffer[idx + 1] / 255;
    const b = frame_buffer[idx + 2] / 255;
    const lum = get_luminance(r, g, b);

    if (lum <= threshold) return; // 不够亮，不绘制星芒

    // 2. 计算星芒颜色和强度
    const factor = Math.min(1, (lum - threshold) * 5);
    const sr = r * factor * 255;
    const sg = g * factor * 255;
    const sb = b * factor * 255;

    // 3. 绘制星芒（沿4个方向双向延伸）
    const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
    const blurLength = 100;
    const decay = 0.97;

    for (const [dx, dy] of directions) {
        const len = Math.hypot(dx, dy);
        const ndx = dx / len, ndy = dy / len;

        for (let d = 1; d <= blurLength; d++) {
            const alpha = Math.pow(decay, d);
            if (alpha < 0.01) break;

            // 正向
            let px = Math.floor(cx + ndx * d);
            let py = Math.floor(cy + ndy * d);
            if (px >= 0 && px < width && py >= 0 && py < height) {
                const i = (py * width + px) * 4;
                frame_buffer[i]     = Math.min(255, frame_buffer[i]     + sr * alpha);
                frame_buffer[i + 1] = Math.min(255, frame_buffer[i + 1] + sg * alpha);
                frame_buffer[i + 2] = Math.min(255, frame_buffer[i + 2] + sb * alpha);
            }

            // 反向
            px = Math.floor(cx - ndx * d);
            py = Math.floor(cy - ndy * d);
            if (px >= 0 && px < width && py >= 0 && py < height) {
                const i = (py * width + px) * 4;
                frame_buffer[i]     = Math.min(255, frame_buffer[i]     + sr * alpha);
                frame_buffer[i + 1] = Math.min(255, frame_buffer[i + 1] + sg * alpha);
                frame_buffer[i + 2] = Math.min(255, frame_buffer[i + 2] + sb * alpha);
            }
        }
    }
}




function draw_line(frame_buffer, fb_width, fb_height, x1, y1, x2, y2, line_width, r, g, b) {
    if (line_width <= 0) return;

    // 确保颜色在 [0, 255] 范围内
    const cr = Math.max(0, Math.min(255, Math.round(r)));
    const cg = Math.max(0, Math.min(255, Math.round(g)));
    const cb = Math.max(0, Math.min(255, Math.round(b)));

    const dx = x2 - x1;
    const dy = y2 - y1;
    const len_sq = dx * dx + dy * dy;

    if (len_sq === 0) {
        // 退化为点：绘制圆形
        const radius = line_width / 2;
        const r_sq = radius * radius;
        const xMin = Math.max(0, Math.floor(x1 - radius));
        const xMax = Math.min(fb_width - 1, Math.ceil(x1 + radius));
        const yMin = Math.max(0, Math.floor(y1 - radius));
        const yMax = Math.min(fb_height - 1, Math.ceil(y1 + radius));

        for (let y = yMin; y <= yMax; y++) {
            for (let x = xMin; x <= xMax; x++) {
                const dist_sq = (x - x1) * (x - x1) + (y - y1) * (y - y1);
                if (dist_sq <= r_sq) {
                    const idx = (y * fb_width + x) * 4;
                    frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + cr);
                    frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + cg);
                    frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + cb);
                    frame_buffer[idx + 3] = 255;
                }
            }
        }
        return;
    }

    const len = Math.sqrt(len_sq);
    const inv_len = 1 / len;
    const nx = -dy * inv_len; // 法向量（垂直于线段）
    const ny = dx * inv_len;

    const half_w = line_width / 2;

    // 包围盒（含线宽）
    const xMin = Math.max(0, Math.floor(Math.min(x1, x2) - half_w));
    const xMax = Math.min(fb_width - 1, Math.ceil(Math.max(x1, x2) + half_w));
    const yMin = Math.max(0, Math.floor(Math.min(y1, y2) - half_w));
    const yMax = Math.min(fb_height - 1, Math.ceil(Math.max(y1, y2) + half_w));

    for (let y = yMin; y <= yMax; y++) {
        for (let x = xMin; x <= xMax; x++) {
            // 计算点 (x, y) 到线段的有符号距离
            const px = x - x1;
            const py = y - y1;

            // 投影长度（参数 t）
            const t = (px * dx + py * dy) / len_sq;
            let closest_x, closest_y;

            if (t < 0) {
                closest_x = x1;
                closest_y = y1;
            } else if (t > 1) {
                closest_x = x2;
                closest_y = y2;
            } else {
                closest_x = x1 + t * dx;
                closest_y = y1 + t * dy;
            }

            const dist = Math.sqrt((x - closest_x) ** 2 + (y - closest_y) ** 2);

            if (dist > half_w) continue;

            // 抗锯齿：边缘平滑过渡（可选，此处使用简单线性）
            let alpha = 1.0;
            const edge_fade = 1.0; // 像素，可调
            if (dist > half_w - edge_fade) {
                alpha = (half_w - dist) / edge_fade;
                alpha = Math.max(0, Math.min(1, alpha));
            }

            const idx = (y * fb_width + x) * 4;
            const add_r = cr * alpha;
            const add_g = cg * alpha;
            const add_b = cb * alpha;

            frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + add_r);
            frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + add_g);
            frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + add_b);
            frame_buffer[idx + 3] = 255;
        }
    }
}


function draw_circle_outline(frame_buffer, fb_width, fb_height, center_x, center_y, radius, line_weight, red, green, blue, alpha) {
    if (radius <= 0 || line_weight <= 0) return;

    const r = Math.max(0, Math.min(255, Math.round(red)));
    const g = Math.max(0, Math.min(255, Math.round(green)));
    const b = Math.max(0, Math.min(255, Math.round(blue)));
    const a = Math.max(0, Math.min(255, Math.round(alpha)));

    // 计算内外半径（考虑线宽居中）
    const halfWeight = line_weight / 2;
    const outerR = radius + halfWeight;
    const innerR = Math.max(0, radius - halfWeight);

    const outerRSq = outerR * outerR;
    const innerRSq = innerR * innerR;

    // 包围盒（含线宽）
    const xMin = Math.max(0, Math.floor(center_x - outerR));
    const xMax = Math.min(fb_width - 1, Math.ceil(center_x + outerR));
    const yMin = Math.max(0, Math.floor(center_y - outerR));
    const yMax = Math.min(fb_height - 1, Math.ceil(center_y + outerR));

    for (let y = yMin; y <= yMax; y++) {
        for (let x = xMin; x <= xMax; x++) {
            const dx = x - center_x;
            const dy = y - center_y;
            const distSq = dx * dx + dy * dy;

            // 判断是否在环形区域内（包含外边界，排除内边界）
            if (distSq < outerRSq && distSq >= innerRSq) {
                const idx = (y * fb_width + x) * 4;
                frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + r);
                frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + g);
                frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + b);
                frame_buffer[idx + 3] = Math.min(255, frame_buffer[idx + 2] + a);
            }
        }
    }
}


// 地面填充纯黑色
function draw_horizon(frame_buffer, fb_width, fb_height) {
    const cx = fb_width / 2;
    const cy = fb_height / 2;
    const R_sq = RADIUS * RADIUS;
    for (let y = 0; y < fb_height; y++) {
        for (let x = 0; x < fb_width; x++) {
            const dx = x - cx;
            const dy = y - cy;
            if (dx * dx + dy * dy > R_sq) {
                const idx = (y * fb_width + x) * 4;
                frame_buffer[idx]     = 0;     // R
                frame_buffer[idx + 1] = 0;     // G
                frame_buffer[idx + 2] = 0;     // B
                frame_buffer[idx + 3] = 255;   // A
            }
        }
    }
}




function draw_sun(frame_buffer, fb_width, fb_height, sun_x, sun_y, sun_altitude_deg, sun_radius) {
    // 1. 太阳半径（随高度变化）：地平线附近略大
    const baseRadius = (sun_radius < 6) ? 6 : sun_radius; // 像素
    const radius = baseRadius * (1 + 0.20 * Math.max(0, 1 - sun_altitude_deg / 10)); // 地平线+15%

    // 2. 光晕半径（可调）
    const glowRadius = Math.max(radius, 6); // 可根据需要调整

    // 3. 太阳颜色：随高度从红→黄→白
    let r, g, b;
    if (sun_altitude_deg < 5) {
        // 接近地平线：深红到橙
        const t = Math.min(1, sun_altitude_deg / 5);
        r = 255;
        g = Math.round(160 * t);
        b = Math.round(40 * t);
    } else if (sun_altitude_deg < 15) {
        // 低空：橙黄
        const t = (sun_altitude_deg - 5) / 10;
        r = 255;
        g = Math.round(160 + 95 * t);
        b = Math.round(40 + 60 * t);
    } else {
        // 中天：白色
        r = 255;
        g = 255;
        b = 255;
    }

    // 4. 抗锯齿边缘宽度
    const edgeSmoothWidth = 1;

    // 5. 绘制太阳本体（带软边缘）
    for (let dy = -glowRadius; dy <= glowRadius; dy++) {
        for (let dx = -glowRadius; dx <= glowRadius; dx++) {
            const dist = Math.sqrt(dx * dx + dy * dy);
            const px = Math.floor(sun_x + dx);
            const py = Math.floor(sun_y + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            // 背景颜色（用于混合）
            const bgR = frame_buffer[idx] / 255;
            const bgG = frame_buffer[idx + 1] / 255;
            const bgB = frame_buffer[idx + 2] / 255;

            // === 太阳光晕（指数衰减）===
            let glow = 0;
            if (dist <= glowRadius) {
                // 光晕强度随距离衰减
                const glowFactor = Math.exp(-dist / (glowRadius * 0.6));
                glow = Math.min(1, glowFactor * 0.8); // 控制整体亮度
            }

            // === 太阳本体（带抗锯齿）===
            let diskWeight = 0;
            if (dist <= radius + edgeSmoothWidth) {
                if (dist <= radius - edgeSmoothWidth) {
                    diskWeight = 1.0;
                }
                else if (dist < radius + edgeSmoothWidth) {
                    const t = (radius + edgeSmoothWidth - dist) / (2 * edgeSmoothWidth);
                    diskWeight = Math.max(0, Math.min(1, t * t * (3 - 2 * t))); // smoothstep
                }
            }

            // 合并：中心最亮（diskWeight=1），向外过渡到光晕
            const totalR = diskWeight * r + glow * r;
            const totalG = diskWeight * g + glow * g;
            const totalB = diskWeight * b + glow * b;

            // 混合到背景（直接覆盖或叠加，这里选择叠加以保留星芒基础）
            frame_buffer[idx]     = Math.min(255, bgR * 255 + totalR);
            frame_buffer[idx + 1] = Math.min(255, bgG * 255 + totalG);
            frame_buffer[idx + 2] = Math.min(255, bgB * 255 + totalB);
        }
    }
}



// 基于球面几何 terminator 的月相绘制（带物理合理的软边缘）
function draw_moon(frame_buffer, fb_width, fb_height, center_x, center_y, lum, radius, phase_deg, tilt_deg) {
    const moonX = center_x;
    const moonY = center_y;
    const moonRadius = radius;

    // 太阳方向（单位向量），同原逻辑
    phase_deg += 90;
    const cosPhase = Math.cos(to_rad(phase_deg));
    const sinPhase = Math.sin(to_rad(phase_deg));
    const sunDirX = cosPhase * Math.cos(to_rad(tilt_deg));
    const sunDirY = cosPhase * Math.sin(to_rad(tilt_deg));
    const sunDirZ = sinPhase;

    const sunLen = Math.sqrt(sunDirX * sunDirX + sunDirY * sunDirY + sunDirZ * sunDirZ);
    const sunUnitX = sunLen > 0 ? sunDirX / sunLen : 1;
    const sunUnitY = sunLen > 0 ? sunDirY / sunLen : 0;
    const sunUnitZ = sunLen > 0 ? sunDirZ / sunLen : 0;

    // 颜色与环境光
    const litColor = [220, 220, 200];
    const darkColor = [10, 10, 20];
    const ambient = 0.01;

    // 半影角宽度（弧度）：太阳角半径 ≈ 0.0047 rad，取稍大值保证可见性
    const PENUMBRA_HALF_ANGLE = 0.2; // ≈ 0.5°

    // 抗锯齿过渡带宽度（像素）
    const edgeSmoothWidth = 1.0;

    const r2 = moonRadius * moonRadius;
    for (let dy = -moonRadius; dy <= moonRadius; dy++) {
        for (let dx = -moonRadius; dx <= moonRadius; dx++) {
            const distSq = dx * dx + dy * dy;
            const distance = Math.sqrt(distSq);

            if (distance > moonRadius + edgeSmoothWidth) continue;

            const px = Math.floor(moonX + dx);
            const py = Math.floor(moonY + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            // === 1. 计算抗锯齿权重（基于圆盘覆盖比例）===
            let moonWeight;
            if (distance <= moonRadius - edgeSmoothWidth) {
                moonWeight = 1.0; // 完全在内部
            } else if (distance >= moonRadius + edgeSmoothWidth) {
                moonWeight = 0.0; // 完全在外部（应跳过，但保留以防边界误差）
                continue;
            } else {
                // 平滑过渡 [moonRadius - w, moonRadius + w]
                const t = (moonRadius + edgeSmoothWidth - distance) / (2 * edgeSmoothWidth);
                moonWeight = Math.max(0, Math.min(1, t)); // 线性插值，也可用 smoothstep
                // 可选更平滑：moonWeight = t * t * (3 - 2 * t);
            }

            if (moonWeight <= 0) continue;

            // === 2. 获取当前背景颜色（来自 frame_buffer）===
            const bgR = frame_buffer[idx] / 255;
            const bgG = frame_buffer[idx + 1] / 255;
            const bgB = frame_buffer[idx + 2] / 255;

            // 构造单位球面上的表面点（归一化位置向量 = 法向量）
            const len = Math.sqrt(dx * dx + dy * dy + r2 - dx * dx - dy * dy); // = moonRadius
            // 实际上，(dx, dy, dz) 在半径为 moonRadius 的球面上，所以单位向量为：
            const nx = dx / moonRadius;
            const ny = dy / moonRadius;
            const nz = Math.sqrt(Math.max(0, r2 - dx * dx - dy * dy)) / moonRadius;

            // 关键：计算该点与 terminator 的球面角距离
            // terminator 是太阳方向与月球中心构成的大圆
            // 点积 dot = cos(θ)，其中 θ 是表面点与太阳方向的夹角
            const dot = nx * sunUnitX + ny * sunUnitY + nz * sunUnitZ;

            // θ = acos(dot)，但避免 acos 开销，直接用 dot 表示角度关系
            // terminator 位于 dot = 0（即 θ = 90°）
            // 我们定义 signed_angle_dist ∝ -dot （因为 dot>0 为亮区）
            // 将角距离映射为线性过渡变量（单位：弧度等效）

            // 使用小角度近似：angle ≈ sqrt(1 - dot^2) 不适用；更简单：
            // 直接用 dot 作为“余弦空间”的代理变量，其梯度在 terminator 附近 ≈ 1/rad
            // 因此，我们定义“有效角偏移”为：
            const angleFromTerminator = Math.acos(Math.max(-1, Math.min(1, dot))) - Math.PI / 2; // ∈ [-π/2, π/2]

            // 或者更高效（避免 acos）：利用 sin(θ - π/2) = -cosθ = -dot
            // 在 terminator 附近（θ≈π/2），有 θ - π/2 ≈ -dot （一阶泰勒）
            // 所以可用：approxAngle = -dot （单位为“弧度等效”，需缩放）
            // 但为保精度，这里采用 acos 方法（可选优化见注释）

            // === 软边缘判断 ===
            let intensity;
            if (angleFromTerminator >= PENUMBRA_HALF_ANGLE) {
                intensity = 1.0; // 完全照亮
            } else if (angleFromTerminator <= -PENUMBRA_HALF_ANGLE) {
                intensity = ambient; // 完全背光
            } else {
                // 映射到 [0,1]
                const t = (angleFromTerminator + PENUMBRA_HALF_ANGLE) / (2 * PENUMBRA_HALF_ANGLE);
                const smoothT = t * t * (3 - 2 * t); // smoothstep
                intensity = ambient + (1 - ambient) * smoothT;
            }

            // 调整全局亮度
            intensity *= lum;






            // === 纹理映射：先绕 Z 轴旋转 -alpha，再映射到经纬度 ===
            let u_norm = dx / moonRadius;   // ∈ [-1, 1]
            let v_norm = dy / moonRadius;   // ∈ [-1, 1]

            // 绕原点旋转 -alpha（使贴图随光照方向对齐）
            const cosA = Math.cos(-to_rad(tilt_deg));
            const sinA = Math.sin(-to_rad(tilt_deg));
            const u_rot = u_norm * cosA - v_norm * sinA;
            const v_rot = u_norm * sinA + v_norm * cosA;

            // 映射到 [0,1] 贴图空间
            let u = (u_rot + 1) * 0.5; // [-1,1] → [0,1]
            let v = (v_rot + 1) * 0.5;

            // 可选：限制在 [0,1] 内（避免边缘采样异常）
            if (u < 0 || u > 1 || v < 0 || v > 1) {
                // 可选择 clamp 或 skip；这里 clamp 更安全
                u = Math.max(0, Math.min(1, u));
                v = Math.max(0, Math.min(1, v));
            }

            // 双线性采样
            const tx = u * moon_texture_width - 0.5;
            const ty = v * moon_texture_height - 0.5;

            const x0 = Math.floor(tx);
            const y0 = Math.floor(ty);
            const x1 = (x0 + 1) % moon_texture_width;
            const y1 = Math.min(y0 + 1, moon_texture_height - 1);

            const wx = tx - x0;
            const wy = ty - y0;

            function getPixel(tex, x, y, c) {
                return tex[((y * moon_texture_width + x) * 4) + c];
            }

            const c00_r = getPixel(moon_texture_rgba, x0, y0, 0);
            const c00_g = getPixel(moon_texture_rgba, x0, y0, 1);
            const c00_b = getPixel(moon_texture_rgba, x0, y0, 2);

            const c10_r = getPixel(moon_texture_rgba, x1, y0, 0);
            const c10_g = getPixel(moon_texture_rgba, x1, y0, 1);
            const c10_b = getPixel(moon_texture_rgba, x1, y0, 2);

            const c01_r = getPixel(moon_texture_rgba, x0, y1, 0);
            const c01_g = getPixel(moon_texture_rgba, x0, y1, 1);
            const c01_b = getPixel(moon_texture_rgba, x0, y1, 2);

            const c11_r = getPixel(moon_texture_rgba, x1, y1, 0);
            const c11_g = getPixel(moon_texture_rgba, x1, y1, 1);
            const c11_b = getPixel(moon_texture_rgba, x1, y1, 2);

            // bilinear interpolation
            const r0 = c00_r + wx * (c10_r - c00_r);
            const g0 = c00_g + wx * (c10_g - c00_g);
            const b0 = c00_b + wx * (c10_b - c00_b);

            const r1 = c01_r + wx * (c11_r - c01_r);
            const g1 = c01_g + wx * (c11_g - c01_g);
            const b1 = c01_b + wx * (c11_b - c01_b);

            let texR = r0 + wy * (r1 - r0);
            let texG = g0 + wy * (g1 - g0);
            let texB = b0 + wy * (b1 - b0);

            // 应用光照强度（保留你的明暗效果）
            const r = Math.round(texR * intensity);
            const g = Math.round(texG * intensity);
            const b = Math.round(texB * intensity);




            // const r = Math.round(darkColor[0] + intensity * (litColor[0] - darkColor[0]));
            // const g = Math.round(darkColor[1] + intensity * (litColor[1] - darkColor[1]));
            // const b = Math.round(darkColor[2] + intensity * (litColor[2] - darkColor[2]));



            const finalR = moonWeight * r + (1 - moonWeight) * bgR;
            const finalG = moonWeight * g + (1 - moonWeight) * bgG;
            const finalB = moonWeight * b + (1 - moonWeight) * bgB;

            frame_buffer[idx]     = finalR;
            frame_buffer[idx + 1] = finalG;
            frame_buffer[idx + 2] = finalB;
        }
    }
}




function draw_star(frame_buffer, fb_width, fb_height, stars) {
    // 从星等转换为相对亮度（归一化到 [0,1]，mag=0 → 1.0，mag=6 → ~0.01）
     // 增加一个衰减系数（平均蓝天亮度），以便白天能够掩盖亮星
    function magnitudeToRelativeLuminance(mag) {
        return 0.7 * Math.pow(10, -0.4 * mag);
    }

    const maxGlowRadius = 2; // 光晕最大半径（像素）

    for (const star of stars) {
        const starLumBase = magnitudeToRelativeLuminance(star[2]);
        const sx = star[0];
        const sy = star[1];

        // 遍历光晕区域（正方形包围圆）
        for (let dy = -maxGlowRadius; dy <= maxGlowRadius; dy++) {
            for (let dx = -maxGlowRadius; dx <= maxGlowRadius; dx++) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > maxGlowRadius) continue;

                const px = Math.round(sx + dx);
                const py = Math.round(sy + dy);
                if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

                // 获取背景亮度用于对比度抑制
                const bgIdx = (py * fb_width + px) * 4;
                const bgR = frame_buffer[bgIdx] / 255;
                const bgG = frame_buffer[bgIdx + 1] / 255;
                const bgB = frame_buffer[bgIdx + 2] / 255;
                const bgLum = 0.299 * bgR + 0.587 * bgG + 0.114 * bgB;

                // 计算恒星在该点的原始发光强度（带光晕衰减）
                const glowFactor = Math.exp(-dist * 0.3); // 调整衰减速度（0.3 可调）
                let starLum = starLumBase * glowFactor;

                // 对比度抑制：白天背景亮时，星星和光晕都应被压制
                const contrast = starLum / (bgLum + 0.001);
                let visibility = 1.0;
                if (contrast < 1.0) {
                    // visibility = Math.pow(contrast, 3);
                    visibility = contrast * contrast * contrast;
                }
                starLum *= visibility;

                // 转为 0–255 范围
                const add = Math.min(255, starLum * 255);

                // 叠加到 RGB（保持白色光晕，可改为彩色）
                frame_buffer[bgIdx]     = Math.min(255, frame_buffer[bgIdx]     + add);
                frame_buffer[bgIdx + 1] = Math.min(255, frame_buffer[bgIdx + 1] + add);
                frame_buffer[bgIdx + 2] = Math.min(255, frame_buffer[bgIdx + 2] + add);
            }
        }
    }
}





/**
 * 绘制赤道坐标系下的子午圈或纬度圈（投影到地平屏幕）
 * @param {Uint8ClampedArray} frame_buffer - 帧缓冲区
 * @param {number} fb_width - 缓冲区宽度
 * @param {number} fb_height - 缓冲区高度
 * @param {boolean} isMeridian - true: 子午圈（固定RA）；false: 纬度圈（固定Dec）
 * @param {number|null} ra_hours - 子午圈的赤经（小时），仅当 isMeridian=true 时有效
 * @param {number|null} dec_deg - 纬度圈的赤纬（度），仅当 isMeridian=false 时有效
 * @param {number} line_weight - 线宽（像素），建议 ≥1
 * @param {number} colorR, colorG, colorB - RGB 颜色分量 [0-255]
 * @param {number} year, month, day, hour, minute, second, timezone, longitude, latitude - 观测参数
 */
function draw_celestial_circle(
    frame_buffer, fb_width, fb_height,
    isMeridian, ra_hours, dec_deg,
    line_weight, colorR, colorG, colorB,
    year, month, day, hour, minute, second, timezone, longitude, latitude
) {
    const POINTS = 360; // 提高采样密度以获得更平滑曲线
    const R = RADIUS;

    let points = [];

    if (isMeridian) {
        // 子午圈：固定 RA，遍历 Dec ∈ [-90°, +90°]
        if (ra_hours === null || ra_hours < 0 || ra_hours > 24) return;
        const ra_deg = (ra_hours % 24) * 15;
        for (let i = 0; i <= POINTS; i++) {
            const dec = -90 + (180 * i / POINTS);
            const [alt, az] = equatorial_to_horizontal(
                ra_deg, dec, year, month, day, hour, minute, second, timezone, longitude, latitude
            );
            if (alt >= 0) {
                const [x, y] = horizontal_to_screen_xy(az, alt, R);
                points.push([x, y]);
            } else {
                points.push(null);
            }
        }
    } else {
        // 纬度圈：固定 Dec，遍历 RA ∈ [0h, 24h)
        if (dec_deg === null || dec_deg < -90 || dec_deg > 90) return;
        for (let i = 0; i <= POINTS; i++) {
            const ra_h = 24 * i / POINTS;
            const ra_deg = (ra_h % 24) * 15;
            const [alt, az] = equatorial_to_horizontal(
                ra_deg, dec_deg, year, month, day, hour, minute, second, timezone, longitude, latitude
            );
            if (alt >= 0) {
                const [x, y] = horizontal_to_screen_xy(az, alt, R);
                points.push([x, y]);
            } else {
                points.push(null);
            }
        }
    }

    // 使用抗锯齿 draw_line 连接可见段
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        if (p1 && p2) {
            draw_line(frame_buffer, fb_width, fb_height, p1[0], p1[1], p2[0], p2[1], line_weight, colorR, colorG, colorB);
        }
    }
}


























// 计算大气散射强度
function calculate_scattered_pixel(ray_vec, sun_vec) {
    if (isNaN(ray_vec[2])) return [0, 0, 0];

    const ray_length = Math.sqrt(ray_vec[0] * ray_vec[0] + ray_vec[1] * ray_vec[1] + ray_vec[2] * ray_vec[2]);
    if (ray_length === 0) return [0, 0, 0];

    const ray_norm = [
        ray_vec[0] / ray_length,
        ray_vec[1] / ray_length,
        ray_vec[2] / ray_length,
    ];

    // 太阳方向归一化
    const sun_vec_radius = Math.sqrt(sun_vec[0] * sun_vec[0] + sun_vec[1] * sun_vec[1] + sun_vec[2] * sun_vec[2]);
    const sun_norm = [
        sun_vec[0] / sun_vec_radius,
        sun_vec[1] / sun_vec_radius,
        sun_vec[2] / sun_vec_radius,
    ];


    // 太阳光入射路径：计算仰角、天顶角、大气光学质量
    const sunElevation = Math.asin(Math.max(-1, Math.min(1, sun_norm[2]))); // [-π/2, π/2]
    const sunZenith = Math.PI / 2 - sunElevation; // [0, π]
    const sunElevationDeg = sunElevation * 180 / Math.PI;
    let sunAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (sunElevationDeg >= 0) {
        const theta = 90 - sunElevationDeg; // 天顶角 in degrees
        sunAirMass = 1.0 / (Math.cos(sunZenith) + 0.50572 * Math.pow(96.07995 - theta, -1.6364));
    }
    else {
        sunAirMass = 40;
    }


    // 观察者视线的仰角、天顶角、大气光学质量
    const viewZenithAngle = Math.acos(Math.max(0, Math.min(1, ray_norm[2])));
    const viewZenithDeg = viewZenithAngle * 180 / Math.PI;
    const viewElevationDeg = 90 - viewZenithDeg;
    let viewAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (viewElevationDeg >= 0) {
        const theta = 90 - viewZenithDeg; // 天顶角 in degrees
        viewAirMass = 1.0 / (Math.cos(viewZenithAngle) + 0.50572 * Math.pow(96.07995 - theta, -1.6364));
    }
    else {
        viewAirMass = 40;
    }


    // 观察方向与太阳方向夹角
    const cosTheta = ray_norm[0] * sun_norm[0] +
                    ray_norm[1] * sun_norm[1] +
                    ray_norm[2] * sun_norm[2];


    // 米氏散射相函数
    const miePhase = Math.pow(
        1 + PHYSICS.MIE_G * PHYSICS.MIE_G - 2 * PHYSICS.MIE_G * cosTheta,
        -1.5
    );


    // 瑞利散射相函数
    const rayleighPhase = (1 + cosTheta * cosTheta) / 4 * 3;


    // 计算视线方向的大气密度系数：直觉上来看，密度越大，对散射的贡献越大
    const H = PHYSICS.ATMOSPHERE_HEIGHT; // km，标高
    const mu = Math.max(0.01, ray_norm[2]); // 避免除零，mu = cos(天顶角)
    const densityFactor = Math.exp(-mu / H);


    // 分波长计算瑞利散射系数
    const wavelengths = PHYSICS.RAYLEIGH_WAVELENGTH_FACTORS;
    const rayleighBetaBase = PHYSICS.RAYLEIGH_BETA; // 参考波长下的 β
    const referenceWavelength = wavelengths[1]; // G分量作为参考（550nm）
    const betaRayleigh = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // betaRayleigh[i] = rayleighBetaBase * Math.pow(referenceWavelength / wavelengths[i], 4);
        const wl = referenceWavelength / wavelengths[i];
        const wlwl = wl * wl;
        betaRayleigh[i] = rayleighBetaBase * wlwl * wlwl;
    }


    // 米氏散射系数：当太阳接近地平线时，光线穿过更厚的低层大气，气溶胶路径长度剧增，米氏散射贡献显著上升
    const effectiveMieBeta = Math.min(PHYSICS.MIE_BETA_MAX, PHYSICS.MIE_BETA_BASE * sunAirMass);


    // 计算每个通道的散射强度（考虑光程衰减）
    const intensities = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // 散射光强度 ∝ 相函数 × exp(-totalBeta * sunAirMass) × density
        // 注意：实际是体散射积分，此处简化为比例模型
        const rayleighContrib = betaRayleigh[i] * rayleighPhase;
        const mieContrib = effectiveMieBeta * miePhase;
        const totalScattering = (rayleighContrib + mieContrib) * densityFactor;

        // 衰减：散射光在传播到观察者途中也会被吸收
        const totalBeta = betaRayleigh[i] + effectiveMieBeta; // 总消光系数（简化）
        // 独立发现的关键修正：衰减中加入时间调节因子，控制一天中不同时间的衰减强度，防止白天出现过于明显的维纳斯带
        // let scale = 0.5 * Math.cos(2 * sunElevation) + 0.501;
        let scale = (sunElevationDeg >= 0) ? Math.exp(- Math.pow((sunElevationDeg / 20), 4)) + 0.01 : 1;
        let attenuation = Math.exp(-totalBeta * viewAirMass * scale);


        // 臭氧吸收
        const ozoneTransmittance = Math.exp(-PHYSICS.OZONE_ABSORPTION[i] * sunAirMass * 0.8); // 调节因子

        intensities[i] = totalScattering * attenuation * ozoneTransmittance;
    }

    // 归一化或缩放到 [0,1]
    let [r, g, b] = intensities;

    // 太阳落到地平线以下时，进一步衰减散射光
    const night_attn = (sunElevationDeg >= 0) ? 1.0 : Math.max(0, Math.exp(0.016 * sunElevationDeg));
    r *= night_attn;
    g *= night_attn;
    b *= night_attn;

    // 全局增益
    const global_gain = 2.0;

    return [
        Math.min(1, r * global_gain), // R
        Math.min(1, g * global_gain), // G
        Math.min(1, b * global_gain)  // B
    ];
}










// 渲染整个天空
function render_all(frame_buffer, fb_width, fb_height, year, month, day, hour, minute, second, timezone, longitude, latitude) {

    // 北斗七星和北极星

    //            (RA)h   m   s    (Dec)d   m   s       Mag
    const beiji    = [2,  32, 9.3,      89, 16, 10.8,   2.09];
    const tianshu  = [11, 3,  45.2,     61, 44, 47.5,   1.95];
    const tianxuan = [11, 1,  52.5,     56, 22, 43.0,   2.34];
    const tianji   = [11, 53, 51.4,     53, 41, 24.5,   2.42];
    const tianquan = [12, 15, 27.0,     57, 1,  39.6,   3.33];
    const yuheng   = [12, 54, 2.8,      55, 57, 16.2,   1.75];
    const kaiyang  = [13, 23, 56.3,     54, 55, 11.3,   2.25];
    const yaoguang = [13, 47, 32.2,     49, 18, 28.7,   1.80];

    const beiji_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(beiji[0], beiji[1], beiji[2]), dec_dms_to_decimal(beiji[3], beiji[4], beiji[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const tianshu_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(tianshu[0], tianshu[1], tianshu[2]), dec_dms_to_decimal(tianshu[3], tianshu[4], tianshu[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const tianxuan_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(tianxuan[0], tianxuan[1], tianxuan[2]), dec_dms_to_decimal(tianxuan[3], tianxuan[4], tianxuan[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const tianji_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(tianji[0], tianji[1], tianji[2]), dec_dms_to_decimal(tianji[3], tianji[4], tianji[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const tianquan_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(tianquan[0], tianquan[1], tianquan[2]), dec_dms_to_decimal(tianquan[3], tianquan[4], tianquan[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const yuheng_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(yuheng[0], yuheng[1], yuheng[2]), dec_dms_to_decimal(yuheng[3], yuheng[4], yuheng[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const kaiyang_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(kaiyang[0], kaiyang[1], kaiyang[2]), dec_dms_to_decimal(kaiyang[3], kaiyang[4], kaiyang[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);
    const yaoguang_hc = equatorial_to_horizontal(
                        ra_hms_to_deg(yaoguang[0], yaoguang[1], yaoguang[2]), dec_dms_to_decimal(yaoguang[3], yaoguang[4], yaoguang[5]),
                        year, month, day, hour, minute, second, timezone, longitude, latitude);

    const beiji_proj_xy = horizontal_to_screen_xy(beiji_hc[1], beiji_hc[0], RADIUS);
    const tianshu_proj_xy = horizontal_to_screen_xy(tianshu_hc[1], tianshu_hc[0], RADIUS);
    const tianxuan_proj_xy = horizontal_to_screen_xy(tianxuan_hc[1], tianxuan_hc[0], RADIUS);
    const tianji_proj_xy = horizontal_to_screen_xy(tianji_hc[1], tianji_hc[0], RADIUS);
    const tianquan_proj_xy = horizontal_to_screen_xy(tianquan_hc[1], tianquan_hc[0], RADIUS);
    const yuheng_proj_xy = horizontal_to_screen_xy(yuheng_hc[1], yuheng_hc[0], RADIUS);
    const kaiyang_proj_xy = horizontal_to_screen_xy(kaiyang_hc[1], kaiyang_hc[0], RADIUS);
    const yaoguang_proj_xy = horizontal_to_screen_xy(yaoguang_hc[1], yaoguang_hc[0], RADIUS);

    const stars = [
        [beiji_proj_xy[0], beiji_proj_xy[1], Math.random() * 0.5 -1.5 + beiji[6]],
        [tianshu_proj_xy[0], tianshu_proj_xy[1], Math.random() * 0.5 -1.5 + tianshu[6]],
        [tianxuan_proj_xy[0], tianxuan_proj_xy[1], Math.random() * 0.5 -1.5 + tianxuan[6]],
        [tianji_proj_xy[0], tianji_proj_xy[1], Math.random() * 0.5 -1.5 + tianji[6]],
        [tianquan_proj_xy[0], tianquan_proj_xy[1], Math.random() * 0.5 -1.5 + tianquan[6]],
        [yuheng_proj_xy[0], yuheng_proj_xy[1], Math.random() * 0.5 -1.5 + yuheng[6]],
        [kaiyang_proj_xy[0], kaiyang_proj_xy[1], Math.random() * 0.5 -1.5 + kaiyang[6]],
        [yaoguang_proj_xy[0], yaoguang_proj_xy[1], Math.random() * 0.5 -1.5 + yaoguang[6]],
    ];

    // 计算北天极投影位置 TODO 与观测点纬度有关
    const np_proj_xy = horizontal_to_screen_xy(0, latitude, RADIUS);

    // 计算太阳位置
    const sun_horizontal_coord = where_is_the_sun(year, month, day, hour, minute, second, timezone, longitude, latitude);
    const sun_vec = horizontal_to_xyz(sun_horizontal_coord[1], sun_horizontal_coord[0], RADIUS);
    const sun_proj_xy = horizontal_to_screen_xy(sun_horizontal_coord[1], sun_horizontal_coord[0], RADIUS);

    // 计算月球位置、月相、月球方向角
    const moon_horizontal_coord = where_is_the_moon(year, month, day, hour, minute, second, timezone, longitude, latitude);
    const moon_proj_xy = horizontal_to_screen_xy(moon_horizontal_coord[1], moon_horizontal_coord[0], RADIUS);
    const mphase = moon_phase(year, month, day, hour, minute, second, timezone);

    let xa = moon_proj_xy[0];
    let ya = moon_proj_xy[1];
    let xb = np_proj_xy[0];
    let yb = np_proj_xy[1];

    let tilt_rad = Math.acos((-xa * (xb - xa) - ya * (yb - ya)) / (Math.sqrt(xa*xa+ya*ya) * Math.sqrt((xb-xa)*(xb-xa) + (yb-ya)*(yb-ya))));

    const moon_radius = Math.round(RADIUS * 0.08);

    draw_moon(
        frame_buffer, RADIUS*2, RADIUS*2, moon_proj_xy[0], moon_proj_xy[1],
        0.8, moon_radius, 180 * (mphase + 1), (to_deg(tilt_rad) + 180));

    const sun_radius = Math.round(RADIUS * 0.02);

    draw_sun(frame_buffer, RADIUS*2, RADIUS*2, sun_proj_xy[0], sun_proj_xy[1], sun_horizontal_coord[0], sun_radius);

    // 大气散射
    for (let y = 0; y < fb_height; y+=2) { // NOTE 两倍降采样
        for (let x = 0; x < fb_width; x+=2) { // NOTE 两倍降采样
            let pixel_index = (y * fb_width + x) * 4;

            // 观察者到该像素的方向向量（从屏幕坐标系转回地平天球的笛卡尔坐标系）
            let ray_vec = screen_xy_to_xyz(x, y);
            const scattered_sky_pixel = calculate_scattered_pixel(ray_vec, sun_vec);

            frame_buffer[pixel_index    ] += Math.min(255, scattered_sky_pixel[0] * 255);
            frame_buffer[pixel_index + 1] += Math.min(255, scattered_sky_pixel[1] * 255);
            frame_buffer[pixel_index + 2] += Math.min(255, scattered_sky_pixel[2] * 255);
            frame_buffer[pixel_index + 3] = 255;

            // NOTE 两倍降采样

            pixel_index = (y * fb_width + (x+1)) * 4;
            frame_buffer[pixel_index    ] += Math.min(255, scattered_sky_pixel[0] * 255);
            frame_buffer[pixel_index + 1] += Math.min(255, scattered_sky_pixel[1] * 255);
            frame_buffer[pixel_index + 2] += Math.min(255, scattered_sky_pixel[2] * 255);
            frame_buffer[pixel_index + 3] = 255;

            pixel_index = ((y+1) * fb_width + x) * 4;
            frame_buffer[pixel_index    ] += Math.min(255, scattered_sky_pixel[0] * 255);
            frame_buffer[pixel_index + 1] += Math.min(255, scattered_sky_pixel[1] * 255);
            frame_buffer[pixel_index + 2] += Math.min(255, scattered_sky_pixel[2] * 255);
            frame_buffer[pixel_index + 3] = 255;

            pixel_index = ((y+1) * fb_width + (x+1)) * 4;
            frame_buffer[pixel_index    ] += Math.min(255, scattered_sky_pixel[0] * 255);
            frame_buffer[pixel_index + 1] += Math.min(255, scattered_sky_pixel[1] * 255);
            frame_buffer[pixel_index + 2] += Math.min(255, scattered_sky_pixel[2] * 255);
            frame_buffer[pixel_index + 3] = 255;
        }
    }

    draw_star(frame_buffer, RADIUS*2, RADIUS*2, stars);

    if (sun_horizontal_coord[0] > 0) {
        star_burst_filter(frame_buffer, RADIUS*2, RADIUS*2, sun_proj_xy[0], sun_proj_xy[1], 0, 0.97, 160);
    }

    draw_horizon(frame_buffer, RADIUS*2, RADIUS*2, null, 0, 0); // 填充黑色

    draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS-1, 2, 128, 128, 128, 255);
    draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS / 3, 1, 16, 16, 16, 255);
    draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS / 3 * 2, 1, 16, 16, 16, 255);

    draw_line(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, 0, RADIUS, RADIUS*2, 1, 16, 16, 16);
    draw_line(frame_buffer, RADIUS*2, RADIUS*2, 0, RADIUS, RADIUS*2, RADIUS, 1, 16, 16, 16);


    // 绘制赤道天球子午圈
    for (let i = 0; i < 24; i += 2) {
        let line_width = (i === 0 || i == 12) ? 3 : 2;
        draw_celestial_circle(
            frame_buffer, RADIUS*2, RADIUS*2,
            true, i, null,
            line_width, 8, 16, 32,
            year, month, day, hour, minute, second, timezone, longitude, latitude
        );
    }

    // 绘制赤道天球等纬度圈
    for (let i = -90; i < 90; i += 10) {
        let line_width = (i === 0) ? 3 : 2;
        draw_celestial_circle(
            frame_buffer, RADIUS*2, RADIUS*2,
            false, null, i,
            line_width, 8, 16, 32,
            year, month, day, hour, minute, second, timezone, longitude, latitude
        );
    }

}





class SkyCanvas {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        this.canvas.width = RADIUS * 2;
        this.canvas.height = RADIUS * 2;

        function adaptRatio(context) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
            return devicePixelRatio / backingStoreRatio;
        }
        this.RATIO = adaptRatio(this.ctx);
        this.canvas.width = Math.floor(this.canvas.width * this.RATIO);
        this.canvas.height = Math.floor(this.canvas.height * this.RATIO);
        RADIUS *= this.RATIO;
        RADIUS = Math.floor(RADIUS);
    }
}





window.onload = function() {
    const sky = new SkyCanvas('skyCanvas');
    const imageData = sky.ctx.createImageData(sky.canvas.width, sky.canvas.height);
    const frame_buffer = imageData.data;

    // FPS计算相关
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;

    function draw() {
        counter += 60;

        // 每帧重绘
        frame_buffer.fill(0);

        const longitude = 119.0;
        const latitude = 31.0;
        const timezone = 8.0;

        const second = counter % 60;
        const minute = Math.floor(counter / 60) % 60;
        const hour = Math.floor(counter / 3600) % 24;

        const current_date = new Date();
        const day = current_date.getDate();
        const month = current_date.getMonth() + 1;
        const year = current_date.getFullYear();

        document.getElementById('datetime').innerHTML = `${year}-${month}-${day} ${hour}:${minute}:${second}`;

        render_all(frame_buffer, sky.canvas.width, sky.canvas.height, year, month, day, hour, minute, second, timezone, longitude, latitude);

        sky.ctx.putImageData(imageData, 0, 0);

        // 计算FPS计算
        frameCount++;
        const now = performance.now();
        if (now - lastTime >= 500) { // 每隔多少毫秒统计一次
            fps = Math.round((frameCount * 1000) / (now - lastTime));
            document.getElementById('fps').textContent = `FPS: ${fps}`;
            frameCount = 0;
            lastTime = now;
        }

        requestAnimationFrame(draw);
    }

    draw();
};
    </script>
</body>
</html>
