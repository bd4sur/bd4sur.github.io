<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>玲珑天象仪</title>
    <style>
body {
    background-color: #000000;
    color: #fff;
    font-size: 14px;
    /* touch-action: none; */
}
button {
    border: none;
    background-color: #2f2f2f;
    color: #989898;
    padding: 3px 6px;
    font-size: 13px;
}
.status_label {
    font-size: smaller;
}
    </style>
</head>
<body>
    <div class="container" style="text-align: center;">
        <div><b>玲珑天象仪</b><br>Planetarium Linglong</div>
        <div style="font-size: smaller;">&copy; 2011-2026 BD4SUR</div>
        <div style="margin: 3px 0;">
            <button id="toggle_equatorial_coord">赤道坐标<br><span class="status_label" id="eqa_status">-</span></button>
            <button id="toggle_horizontal_coord">地平坐标<br><span class="status_label" id="hor_status">-</span></button>
            <button id="toggle_star_burst">星芒<br><span class="status_label" id="star_burst_status">-</span></button>
            <button id="toggle_atmospheric_scattering">大气散射<br><span class="status_label" id="scattering_status">-</span></button>
        </div>
        <div style="margin: 3px 0;">
            <button id="toggle_ecliptic_circle">黄道<br><span class="status_label" id="ecliptic_circle_status">-</span></button>
            <button id="toggle_planet">行星<br><span class="status_label" id="planet_status">-</span></button>
            <button id="toggle_star_name">恒星名称<br><span class="status_label" id="star_name_status">-</span></button>
            <button id="toggle_planet_name">行星名称<br><span class="status_label" id="planet_name_status">-</span></button>
            <button id="toggle_landscape">地景<br><span class="status_label" id="landscape_status">-</span></button>
        </div>

        <canvas id="skyCanvas" width="240" height="240" style="width: 240px; height: 240px;"></canvas>

        <div id="datetime">-</div>
        <div id="coord">Lon: <span id="longitude">-</span>° Lat: <span id="latitude">-</span>°</div>
        <div style="margin: 3px 0;">
            <button id="toggle_realtime">实时天象<br><span class="status_label" id="realtime_status">-</span></button>
            <button id="toggle_timemachine">时光机<br><span class="status_label" id="timemachine_status">-</span></button>
            <button id="toggle_opt_sym">折半渲染<br><span class="status_label" id="opt_sym_status">-</span></button>
            <button id="toggle_opt_bilinear">双线性插值<br><span class="status_label" id="opt_bilinear_status">-</span></button>
        </div>
        <table style="margin: 0px auto;">
            <tr>
                <td><button id="set_time">设置时间</button></td>
                <td><button id="cam_pitch_up">仰</button></td>
                <td><button id="set_coord">设置位置</button></td>
            </tr>
            <tr>
                <td><button id="cam_rot_eastward">东</button></td>
                <td><button id="cam_reset">归中</button></td>
                <td><button id="cam_rot_westward">西</button></td>
            </tr>
            <tr>
                <td><button id="cam_zoom_in">推</button></td>
                <td><button id="cam_pitch_down">俯</button></td>
                <td><button id="cam_zoom_out">拉</button></td>
            </tr>
        </table>
        <div id="fps">FPS: --</div>
        <div style="font-size: smaller; text-align: left; max-width: 320px; margin: 0 auto; color: #aaaaaa;">
            <p><b>主要参考文献</b></p>
            <ol>
                <li>Nishita T, et al. <b>Display of The Earth Taking into Account Atmospheric Scattering</b>. 1993.</li>
                <li>Meeus J. <b>Astronomical Algorithms (Second Edition)</b>. 1998.</li>
            </ol>
        </div>
    </div>

    <script src="../script/glyph.js"></script>
    <script src="../script/vsop87c_milli.js"></script>
    <script src="../script/eph.js"></script>
    <script>



const USE_FISHEYE_PROJECTION = true; // 是否使用鱼眼投影（否则使用XY投影）

// 是否启用赤道坐标圈
let enable_equatorial_coord = true;
// 是否启用地平坐标
let enable_horizontal_coord = true;
// 是否启用星芒效果
let enable_star_burst = true;
// 大气散射模型（0-不启用；1-简化模型；2-西田模型）
let enable_atmospheric_scattering = 2;
// 是否显示恒星名称
let enable_star_name = true;
// 是否显示大行星
let enable_planet = true;
// 是否显示大行星名称
let enable_planet_name = true;
// 是否显示黄道
let enable_ecliptic_circle = true;

// 是否展示实时天象（置位后将enable_timemachine_running设为false）
let enable_realtime = true;
// 时光机状态（以尽可能快的速度渲染并绘制）
let enable_timemachine_running = false;

// 是否启用基于对称性的渲染优化
let enable_opt_sym = false;
// 是否启用双线性插值
let enable_opt_bilinear = true;

// 地景选项：0-无地景
let landscape_index = 1;



let moon_texture_width = 64;
let moon_texture_height = 64;
let moon_texture_rgba = null;
let img_moon_texture = new Image();

img_moon_texture.src = '../image/H/moon.jpg';
img_moon_texture.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img_moon_texture.width;
    canvas.height = img_moon_texture.height;
    moon_texture_width = img_moon_texture.width;
    moon_texture_height = img_moon_texture.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img_moon_texture, 0, 0);
    moon_texture_rgba = ctx.getImageData(0, 0, img_moon_texture.width, img_moon_texture.height).data; // Uint8ClampedArray
    // console.log(JSON.stringify(Array.from(moon_texture_rgba)));
};




let landscape_texture_width = 600;
let landscape_texture_height = 600;
let landscape_texture_rgba = null;
let img_landscape_texture = new Image();
const LANDSCAPES = [
    ["", ""],
    ["../image/H/landscape_0.jpg", "草原1"],
    ["../image/H/landscape_1.jpg", "草原2"],
    ["../image/H/landscape_2.jpg", "雪地"],
    ["../image/H/landscape_3.jpg", "海洋"]
];






let counter = 0;
let timemachine_start_time = new Date();

let RADIUS = 120;

// 物理常数
const PHYSICS = {
    // 大气光学参数
    MIE_G: 0.9,           // 米氏散射不对称因子
    RAYLEIGH_BETA: 0.3,  // 瑞利散射系数 感觉是海拔越高越小
    MIE_BETA_BASE: 0.001,      // 米氏散射系数 越大光斑越大
    MIE_BETA_MAX: 0.1,      // 米氏散射系数 越大光斑越大
    ATMOSPHERE_HEIGHT: 8.5, // 虚拟大气层厚度 (km)
    SUN_ANGULAR_SIZE: 0.5, // 太阳视直径 (度)

    // 波长相关的瑞利散射系数 (近似)
    RAYLEIGH_WAVELENGTH_FACTORS: [
        680, // Red
        550, // Green
        450  // Blue
    ],

    // 臭氧吸收系数
    OZONE_ABSORPTION: [
        0.005,  // Red   (650nm) — 弱吸收
        0.040,  // Green (550nm) — 中等吸收
        0.025   // Blue  (450nm) — 比绿光略弱（实际臭氧在~600nm最强，但简化模型）
    ],
};

// 行星相关常量（用于渲染）
//                      -     1Mer  2Ven  3Ear  4Mars 5Jup  6Sat  7Ura  8Nep
const PLANET_RADIUS  = [0.0,  1.0,  2.0,  0.0,  1.0,  3.0,  2.0,  1.0,  1.0 ];
const PLANET_COLOR_R = [0,    192,  255,  0,    255,  255,  192,  0,    192 ];
const PLANET_COLOR_G = [0,    192,  255,  0,    64,   192,  255,  255,  128 ];
const PLANET_COLOR_B = [0,    192,  64,   0,    0,    128,  128,  255,  255 ];
const PLANET_NAME    = ["", "水星", "金星", "地球", "火星", "木星", "土星", "天王星", "海王星"];

// 星表
const STARS = [
//(RA)h   m   s    (Dec)d   m   s       Mag
    [2,  32, 9.3,      89, 16, 10.8,   2.09], // 勾陈一（北极星）
    [11, 3,  45.2,     61, 44, 47.5,   1.95], // 天枢
    [11, 1,  52.5,     56, 22, 43.0,   2.34], // 天璇
    [11, 53, 51.4,     53, 41, 24.5,   2.42], // 天玑
    [12, 15, 27.0,     57, 1,  39.6,   3.33], // 天权
    [12, 54, 2.8,      55, 57, 16.2,   1.75], // 玉衡
    [13, 23, 56.3,     54, 55, 11.3,   2.25], // 开阳
    [13, 47, 32.2,     49, 18, 28.7,   1.80], // 摇光

    [6,  45, 91.0,    -16, 43, 35.0,  -1.46], // 天狼
    [14, 15, 37.6,     19, 9,  53.3,  -0.05], // 大角
    [18, 36, 55.2,     38, 46, 59.8,   0.03], // 织女一
    [19, 50, 46.6,      8, 52, 10.9,   0.76], // 河鼓二
];

const STAR_NAME = [
    "北极星", "天枢", "", "", "", "", "开阳", "",
    "天狼", "大角", "织女一", "河鼓二", "M31",
    "参宿四", "", "", "", "", "", "参宿七", ""
];





// 从星等转换为相对亮度（归一化到 [0,1]，mag=0 → 1.0，mag=6 → ~0.01）
// 增加一个衰减系数（平均蓝天亮度），以便白天能够掩盖亮星
function magnitude_to_relative_luminance(mag) {
    return 0.7 * Math.pow(10, -0.4 * mag);
}

function to_rad(deg) {
    return deg * Math.PI / 180;
}

function to_deg(rad) {
    return rad * 180 / Math.PI;
}

// 将hms格式的赤经转为度数
function ra_hms_to_deg(h, m, s) {
    let totalHours = h + m / 60.0 + s / 3600.0;
    let degrees = totalHours * 15.0;
    degrees = degrees % 360;
    if (degrees < 0) degrees += 360;
    return degrees;
}

// 将度分秒格式的赤纬转为度数
function dec_dms_to_decimal(d, m, s) {
    const sign = d < 0 ? -1 : 1;
    const absD = Math.abs(d);
    const decimal = sign * (absD + m / 60 + s / 3600);
    return decimal;
}

// 地平天球的球坐标系→地平天球的笛卡尔坐标系
function horizontal_to_xyz(azimuth_deg, altitude_deg, radius) {
    const alt_rad = altitude_deg * Math.PI / 180;
    const azi_rad = azimuth_deg * Math.PI / 180;
    const r_xy = radius * Math.cos(alt_rad);
    return [
        r_xy * Math.sin(azi_rad),
        r_xy * Math.cos(azi_rad),
        radius * Math.sin(alt_rad)
    ];
}

// 笛卡尔坐标系 → 地平天球球坐标系 (altitude, azimuth, radius)
function xyz_to_horizontal(x, y, z) {
    // 1. 计算半径（处理原点情况）
    const R = Math.sqrt(x * x + y * y + z * z);
    if (R < 1e-15) {
        return [0, 0, 0]; // 原点无定义，返回默认值
    }

    // 2. 计算高度角（钳制避免浮点误差导致 asin 越界）
    let sinAlt = z / R;
    sinAlt = Math.max(-1, Math.min(1, sinAlt)); // 严格限制在 [-1, 1]
    const altitude_deg = Math.asin(sinAlt) * (180 / Math.PI);

    // 3. 处理天顶/天底（|z| ≈ R 时方位角无定义）
    if (Math.abs(z) >= R * (1 - 1e-10)) {
        return [altitude_deg, 0, R]; // 方位角设为0（惯例）
    }

    // 4. 计算方位角（核心：atan2(x, y) 对应原函数中的 azRad）
    const azRad = Math.atan2(x, y); // 注意参数顺序：x 对应 sin(azRad), y 对应 cos(azRad)
    let azimuth_deg = azRad * (180 / Math.PI) - 180; // 逆向抵消原函数的 +180°

    // 5. 归一化到 [0, 360)
    azimuth_deg = (azimuth_deg + 360) % 360;
    if (azimuth_deg >= 360) azimuth_deg -= 360; // 双保险（应对浮点误差）
    if (azimuth_deg < 0) azimuth_deg += 360;

    return [altitude_deg, azimuth_deg, R];
}


function cross(a, b) {
    return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
    ];
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function scale(v, n) {
    return [v[0] * n, v[1] * n, v[2] * n];
}
function sub(a, b) {
    return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
}
function norm(v) {
    const len = Math.hypot(v[0], v[1], v[2]);
    return (len < 1e-20) ? [0, 0, 0] : [v[0]/len, v[1]/len, v[2]/len];
}


// 地平天球的球坐标系→地平天球的笛卡尔坐标系→投影到地面投影坐标系
function fisheye_project(azimuth_deg, altitude_deg, R, center_x, center_y, view_alt, view_azi, f) {

    let v_view = norm(horizontal_to_xyz(view_azi, view_alt, R));
    let v = norm(horizontal_to_xyz(azimuth_deg, altitude_deg, R));

    let x_v = [0,0,0];
    let y_v = [0,0,0];

    // if (Math.abs(view_alt - 90) < 1e-5) { // 谨慎处理临界点附近的浮点误差问题
    //     v_view = [0, 0, 1];
    //     // NOTE 如果强行设置y_v，将失去天顶视角的旋转（某种 gimble lock？）
    //     y_v = [0, 1, 0]; // NOTE 方向的选择有任意性，与默认方向与坐标反解有关
    // }
    // else {
        let zenith = [0, 0, 1];
        let proj = scale(v_view, dot(zenith, v_view));
        y_v = norm(sub(zenith, proj));
    // }

    x_v = cross(y_v, v_view);

    let vx = dot(v, x_v);
    let vy = dot(v, y_v);
    let vz = dot(v, v_view);

    if (vz < -1) return [0, 0];

    const theta = Math.acos(vz); // rad
    const phi_v = -Math.atan2(vx, vy); // rad
    const r = (f * 2.0 * R / Math.PI) * theta;
    const x =  r * Math.sin(phi_v);
    const y = -r * Math.cos(phi_v);
    return [x + center_x, y + center_y];
}

function fisheye_unproject(scr_x, scr_y, R, center_x, center_y, view_alt, view_azi, f) {
    // 屏幕坐标转极坐标
    const dx = center_x - scr_x;
    const dy = center_y - scr_y;
    const r = Math.hypot(dx, dy);

    // 处理中心点退化
    let phi_prime = 0.0;
    if (r < 1e-6) {
        phi_prime = 0.0;
    }
    else {
        phi_prime = Math.atan2(dx, dy);
    }

    // 极坐标转单位向量
    let theta = (Math.PI / 2) * (r / (R * f));
    let pxy = Math.sin(theta);
    let p_prime = [
        pxy * Math.sin(phi_prime),
        pxy * Math.cos(phi_prime),
        Math.cos(theta)
    ];

    // 构建旋转矩阵转置
    let V_alt_rad = to_rad(view_alt);
    let V_azi_rad = to_rad(view_azi);

    // 视线向量v
    let v = [
        Math.cos(V_alt_rad) * Math.sin(V_azi_rad),
        Math.cos(V_alt_rad) * Math.cos(V_azi_rad),
        Math.sin(V_alt_rad)
    ];

    // 构建y'轴
    let dot = v[2]; // dot(zenith=[0,0,1], v) => vz
    let y_prime = [-dot * v[0], -dot * v[1], 1.0 - dot * v[2]];
    y_prime = norm(y_prime);

    // 构建x'轴
    let x_prime = cross(y_prime, v);
    x_prime = norm(x_prime);

    // 局部坐标转地平坐标
    let px = x_prime[0] * p_prime[0] + y_prime[0] * p_prime[1] + v[0] * p_prime[2];
    let py = x_prime[1] * p_prime[0] + y_prime[1] * p_prime[1] + v[1] * p_prime[2];
    let pz = x_prime[2] * p_prime[0] + y_prime[2] * p_prime[1] + v[2] * p_prime[2];

    // 归一化到R
    return scale(norm([px, py, pz]), R);
}











// 通过屏幕坐标和地平方位坐标，反解视线方向
function find_view_dir(alt, azi, R, x, y, center_x, center_y, f, last_alt = 90, last_azi = 0) {

    // ===== 将last参数转换为单位向量（用于解选择）=====
    let last_vec;
    try {
        // last_alt是view_alt格式（0-180），需转为常规仰角：常规仰角 = 180 - view_alt
        const last_conventional_alt = 180 - last_alt;
        last_vec = norm(horizontal_to_xyz(last_azi, last_conventional_alt, 1.0));
        // 验证有效性
        if (!isFinite(last_vec[0]) || Math.abs(dot(last_vec, last_vec) - 1) > 1e-6) throw new Error();
    } catch (e) {
        // 回退到天顶（安全默认值）
        last_vec = [0, 0, 1];
    }
    
    // ===== 主逻辑：解析求解 =====
    // 1. 目标点单位向量
    const P = norm(horizontal_to_xyz(azi, alt, 1.0));
    
    // 2. 投影偏移处理
    const dx = x - center_x;
    const dy = y - center_y;
    const r = Math.hypot(dx, dy);
    
    // 特殊情况：投影中心点
    if (r < 1e-10) {
        const view_alt = 180 - alt;
        return [view_alt, (azi % 360 + 360) % 360];
    }
    
    // 3. 计算球面参数
    let theta = r * Math.PI / (2 * f * R);
    theta = Math.max(0, Math.min(Math.PI, theta));
    const phi_v = Math.atan2(dx, -dy); // 由投影公式反推
    const k = Math.sin(theta) * Math.cos(phi_v);
    const c = P[2]; // P·Z
    const cos_theta = Math.cos(theta);
    
    // 4. 求解二次方程 A·a² + B·a + C = 0 (a = S·Z)
    const A = cos_theta * cos_theta + k * k;
    const B = -2 * c * cos_theta;
    const C = c * c - k * k;
    const discriminant = B * B - 4 * A * C;
    
    // 无实数解时直接进入数值优化
    if (discriminant < -1e-12) {
        return find_view_dir_numerical(alt, azi, R, x, y, center_x, center_y, f, last_alt, last_azi);
    }
    
    // 5. 生成候选解
    const candidates = [];
    const sqrt_disc = Math.sqrt(Math.max(0, discriminant));
    const a_candidates = [
        (-B + sqrt_disc) / (2 * A),
        (-B - sqrt_disc) / (2 * A)
    ];
    
    for (const a_raw of a_candidates) {
        const a = Math.max(-1, Math.min(1, a_raw));
        const R0_sq = 1 - a * a;
        if (R0_sq < -1e-10) continue;
        const R0 = Math.sqrt(Math.max(0, R0_sq));
        
        const D = cos_theta - a * c;
        const Px = P[0], Py = P[1];
        const len_sq = Px * Px + Py * Py;
        
        // P在z轴上的特殊情况
        if (len_sq < 1e-20) {
            if (Math.abs(D) > 1e-8) continue;
            if (R0 < 1e-10) candidates.push([0, 0, a]);
            else {
                candidates.push([0, R0, a]);
                candidates.push([0, -R0, a]);
            }
            continue;
        }
        
        const len = Math.sqrt(len_sq);
        const nx = Px / len, ny = Py / len;
        const dist = Math.abs(D) / len;
        if (dist > R0 + 1e-8) continue;
        
        const base_x = (D / len) * nx;
        const base_y = (D / len) * ny;
        const tx = -ny, ty = nx;
        const h = Math.sqrt(Math.max(0, R0_sq - (D * D) / len_sq));
        
        candidates.push([base_x + h * tx, base_y + h * ty, a]);
        candidates.push([base_x - h * tx, base_y - h * ty, a]);
    }
    
    // 6. 验证候选解（消除增根）
    const valid_candidates = [];
    for (const S_raw of candidates) {
        const S = norm(S_raw);
        if (!isFinite(S[0])) continue;
        
        const a = S[2];
        const left = c - a * cos_theta;
        const right = k * Math.sqrt(Math.max(0, 1 - a * a));
        
        // 符号与数值验证（容忍浮点误差）
        if (Math.abs(left - right) < 1e-6 * (Math.abs(left) + Math.abs(right) + 1)) {
            valid_candidates.push(S);
        }
    }
    
    // 7. 优先选择与last最接近的有效解
    if (valid_candidates.length > 0) {
        // 按与last_vec的角距离升序排序
        valid_candidates.sort((s1, s2) => {
            const cos1 = Math.max(-1, Math.min(1, dot(s1, last_vec)));
            const cos2 = Math.max(-1, Math.min(1, dot(s2, last_vec)));
            return Math.acos(cos1) - Math.acos(cos2);
        });
        
        // 转换最优解为view_alt/view_azi格式
        const S = valid_candidates[0];
        const sz = Math.max(-1, Math.min(1, S[2]));
        const alt_s = Math.asin(sz) * 180 / Math.PI; // 常规仰角
        let azi_s = Math.atan2(S[0], S[1]) * 180 / Math.PI;
        
        const view_alt = 180 - alt_s;
        azi_s = (azi_s % 360 + 360) % 360;
        return [view_alt, azi_s];
    }
    
    // 8. 解析法失败：调用数值优化（传入last参数）
    return find_view_dir_numerical(alt, azi, R, x, y, center_x, center_y, f, last_alt, last_azi);
}

// ===== 数值优化后备方案（增强：使用last作为初始点）=====
function find_view_dir_numerical(alt, azi, R, x, y, center_x, center_y, f, last_alt, last_azi) {

    console.log("find_view_dir_numerical");

    // 投影计算（简化版）
    function fisheye_project(view_alt, view_azi) {
        const v_view = norm(horizontal_to_xyz(view_azi, 180 - view_alt, 1));
        const v = norm(horizontal_to_xyz(azi, alt, 1));
        
        let y_v;
        if (Math.abs(view_alt - 90) < 1e-5) {
            y_v = [0, 1, 0];
        } else {
            const zenith = [0, 0, 1];
            const proj_scale = dot(zenith, v_view);
            const proj = [v_view[0]*proj_scale, v_view[1]*proj_scale, v_view[2]*proj_scale];
            y_v = norm([zenith[0]-proj[0], zenith[1]-proj[1], zenith[2]-proj[2]]);
        }
        const x_v = cross(y_v, v_view);
        
        const vx = dot(v, x_v);
        const vy = dot(v, y_v);
        const vz = dot(v, v_view);
        if (vz <= -1) return [center_x, center_y];
        
        const theta = Math.acos(Math.max(-1, Math.min(1, vz)));
        const phi_v = -Math.atan2(vx, vy);
        const r_proj = (f * 2 * R / Math.PI) * theta;
        return [
            r_proj * Math.sin(phi_v) + center_x,
            -r_proj * Math.cos(phi_v) + center_y
        ];
    }
    
    // ===== 关键增强：以last为初始点构建单纯形 =====
    const alt0 = Math.max(0, Math.min(180, last_alt));
    const azi0 = (last_azi % 360 + 360) % 360;
    
    // 构建非退化单纯形（last为中心，两个小扰动）
    let simplex = [
        [alt0, azi0], // 最优猜测点
        [Math.max(0, Math.min(180, alt0 + 5)), azi0], // 仰角扰动
        [alt0, (azi0 + 15) % 360] // 方位角扰动（避免与仰角扰动共线）
    ];
    
    // Nelder-Mead优化（精简版）
    const max_iter = 80;
    const tol = 1e-4;
    
    for (let iter = 0; iter < max_iter; iter++) {
        // 计算投影误差
        const errors = simplex.map(p => {
            const [px, py] = fisheye_project(p[0], p[1]);
            return Math.hypot(px - x, py - y);
        });
        
        // 排序：best → worst
        const indices = [0,1,2].sort((i,j) => errors[i] - errors[j]);
        simplex = [simplex[indices[0]], simplex[indices[1]], simplex[indices[2]]];
        errors.sort((a,b) => a - b);
        
        if (errors[2] - errors[0] < tol) break;
        
        // 计算centroid（除最差点外）
        const centroid = [
            (simplex[0][0] + simplex[1][0]) / 2,
            (simplex[0][1] + simplex[1][1]) / 2
        ];
        
        // 反射
        const reflected = [
            2*centroid[0] - simplex[2][0],
            2*centroid[1] - simplex[2][1]
        ];
        reflected[0] = Math.max(0, Math.min(180, reflected[0]));
        reflected[1] = (reflected[1] % 360 + 360) % 360;
        
        const ref_err = (() => {
            const [px, py] = fisheye_project(reflected[0], reflected[1]);
            return Math.hypot(px - x, py - y);
        })();
        
        // 标准Nelder-Mead操作
        if (ref_err < errors[0]) {
            // 扩展
            const expanded = [
                centroid[0] + 2*(reflected[0] - centroid[0]),
                centroid[1] + 2*(reflected[1] - centroid[1])
            ];
            expanded[0] = Math.max(0, Math.min(180, expanded[0]));
            expanded[1] = (expanded[1] % 360 + 360) % 360;
            const exp_err = (() => {
                const [px, py] = fisheye_project(expanded[0], expanded[1]);
                return Math.hypot(px - x, py - y);
            })();
            simplex[2] = exp_err < ref_err ? expanded : reflected;
        } else if (ref_err < errors[1]) {
            simplex[2] = reflected;
        } else {
            // 收缩
            const contracted = [
                centroid[0] + 0.5*(simplex[2][0] - centroid[0]),
                centroid[1] + 0.5*(simplex[2][1] - centroid[1])
            ];
            contracted[0] = Math.max(0, Math.min(180, contracted[0]));
            contracted[1] = (contracted[1] % 360 + 360) % 360;
            const cont_err = (() => {
                const [px, py] = fisheye_project(contracted[0], contracted[1]);
                return Math.hypot(px - x, py - y);
            })();
            if (cont_err < errors[2]) {
                simplex[2] = contracted;
            } else {
                // 全局收缩（向best点）
                for (let i = 1; i < 3; i++) {
                    simplex[i] = [
                        simplex[0][0] + 0.5*(simplex[i][0] - simplex[0][0]),
                        simplex[0][1] + 0.5*(simplex[i][1] - simplex[0][1])
                    ];
                    simplex[i][0] = Math.max(0, Math.min(180, simplex[i][0]));
                    simplex[i][1] = (simplex[i][1] % 360 + 360) % 360;
                }
            }
        }
    }
    
    // 返回最优解（已归一化）
    const best = simplex[0];
    return [
        Math.max(0, Math.min(180, best[0])),
        (best[1] % 360 + 360) % 360
    ];
}





















// 地平天球的球坐标系→地平天球的笛卡尔坐标系→投影到地面投影坐标系
function horizontal_to_screen_xy(azimuth_deg, altitude_deg, R, center_x, center_y) {
    // 鱼眼投影
    if (USE_FISHEYE_PROJECTION) {
        const az_rad = (-azimuth_deg * Math.PI) / 180; // 因为是躺在地上看天，所以方位角是从正北逆时针旋转
        const alt_rad = (altitude_deg * Math.PI) / 180;
        // 天顶距（zenith distance）θ = π/2 - altitude
        const theta = Math.PI / 2 - alt_rad; // 弧度
        // 等距鱼眼投影：r ∝ θ，且当地平线（θ = π/2）时 r = R
        // 所以 r = R * (θ / (π/2)) = (2R / π) * θ
        const r = (2 * R / Math.PI) * theta;
        // 投影到平面：X指向东（注意因为是躺在地上看天，所以东是屏幕坐标系的左侧/负半轴），Y指向北
        // azimuth=0°（北）→ (0, r)；azimuth=90°（东）→ (r, 0)
        const X = r * Math.sin(az_rad);
        const Y = -r * Math.cos(az_rad);
        return [X + center_x, Y + center_y];
    }
    // XY投影：笛卡尔坐标系的XY直接垂直投射到地平面上
    else {
        const xyz = horizontal_to_xyz(azimuth_deg, altitude_deg, R);
        if (altitude_deg >= 0) {
            return [xyz[0] + center_x, xyz[1] + center_y]; // 转到canvas的屏幕坐标系
        }
        else {
            return [xyz[0] - center_x, xyz[1] - center_y]; // 地平面以下的，移出canvas显示范围
        }
    }
}


// 屏幕坐标系→地面投影坐标系→反演回地平天球的直角坐标系
function screen_xy_to_xyz(scr_x, scr_y) {
    const cx = RADIUS;
    const cy = RADIUS;
    const dx = scr_x - cx;
    const dy = scr_y - cy;
    let hor_xyz = [0, 0, 0];
    // 鱼眼投影
    if (USE_FISHEYE_PROJECTION) {
        let r = Math.sqrt(dx*dx + dy*dy) / RADIUS; // 归一化半径
        if (r <= 1) {
            const theta = r * Math.PI / 2; // 天顶角
            const phi = Math.atan2(dy, dx); // 方位角
            hor_xyz = [
                RADIUS * Math.sin(theta) * Math.cos(phi),
                RADIUS * Math.sin(theta) * Math.sin(phi),
                RADIUS * Math.cos(theta)
            ];
        }
    }
    // XY投影
    else {
        hor_xyz = [ dx, dy, Math.sqrt(RADIUS*RADIUS - (dx*dx + dy*dy)) ];
    }
    return hor_xyz;
}


function get_luminance(r, g, b) {
    return 0.299 * r + 0.587 * g + 0.114 * b;
}







function star_burst_filter(frame_buffer, width, height, sun_screen_x, sun_screen_y, sunBrightness) {
    // 亮度阈值
    const threshold = 0.9;

    const cx = sun_screen_x;
    const cy = sun_screen_y;
    const ix = Math.floor(cx), iy = Math.floor(cy);
    if (ix < 0 || ix >= width || iy < 0 || iy >= height) return;

    // 1. 读取原图中该像素的亮度
    const idx = (iy * width + ix) * 4;
    const r = frame_buffer[idx] / 255;
    const g = frame_buffer[idx + 1] / 255;
    const b = frame_buffer[idx + 2] / 255;
    const lum = get_luminance(r, g, b);

    if (lum <= threshold) return; // 不够亮，不绘制星芒

    // 2. 计算星芒颜色和强度
    const factor = Math.min(1, (lum - threshold) * 5);
    const sr = r * factor * 255;
    const sg = g * factor * 255;
    const sb = b * factor * 255;

    // 3. 绘制星芒（沿4个方向双向延伸）
    const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
    const blurLength = 100;
    const decay = 0.97;

    for (const [dx, dy] of directions) {
        const len = Math.hypot(dx, dy);
        const ndx = dx / len, ndy = dy / len;

        for (let d = 1; d <= blurLength; d++) {
            const alpha = Math.pow(decay, d);
            if (alpha < 0.01) break;

            // 正向
            let px = Math.floor(cx + ndx * d);
            let py = Math.floor(cy + ndy * d);
            if (px >= 0 && px < width && py >= 0 && py < height) {
                const i = (py * width + px) * 4;
                frame_buffer[i]     = Math.min(255, frame_buffer[i]     + sr * alpha);
                frame_buffer[i + 1] = Math.min(255, frame_buffer[i + 1] + sg * alpha);
                frame_buffer[i + 2] = Math.min(255, frame_buffer[i + 2] + sb * alpha);
            }

            // 反向
            px = Math.floor(cx - ndx * d);
            py = Math.floor(cy - ndy * d);
            if (px >= 0 && px < width && py >= 0 && py < height) {
                const i = (py * width + px) * 4;
                frame_buffer[i]     = Math.min(255, frame_buffer[i]     + sr * alpha);
                frame_buffer[i + 1] = Math.min(255, frame_buffer[i + 1] + sg * alpha);
                frame_buffer[i + 2] = Math.min(255, frame_buffer[i + 2] + sb * alpha);
            }
        }
    }
}




function draw_line(frame_buffer, fb_width, fb_height, x1, y1, x2, y2, line_width, r, g, b) {
    if (line_width <= 0) return;

    // 确保颜色在 [0, 255] 范围内
    const cr = Math.max(0, Math.min(255, Math.round(r)));
    const cg = Math.max(0, Math.min(255, Math.round(g)));
    const cb = Math.max(0, Math.min(255, Math.round(b)));

    const dx = x2 - x1;
    const dy = y2 - y1;
    const len_sq = dx * dx + dy * dy;

    if (len_sq === 0) {
        // 退化为点：绘制圆形
        const radius = line_width / 2;
        const r_sq = radius * radius;
        const xMin = Math.max(0, Math.floor(x1 - radius));
        const xMax = Math.min(fb_width - 1, Math.ceil(x1 + radius));
        const yMin = Math.max(0, Math.floor(y1 - radius));
        const yMax = Math.min(fb_height - 1, Math.ceil(y1 + radius));

        for (let y = yMin; y <= yMax; y++) {
            for (let x = xMin; x <= xMax; x++) {
                const dist_sq = (x - x1) * (x - x1) + (y - y1) * (y - y1);
                if (dist_sq <= r_sq) {
                    const idx = (y * fb_width + x) * 4;
                    frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + cr);
                    frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + cg);
                    frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + cb);
                    frame_buffer[idx + 3] = 255;
                }
            }
        }
        return;
    }

    const len = Math.sqrt(len_sq);
    const inv_len = 1 / len;
    const nx = -dy * inv_len; // 法向量（垂直于线段）
    const ny = dx * inv_len;

    const half_w = line_width / 2;

    // 包围盒（含线宽）
    const xMin = Math.max(0, Math.floor(Math.min(x1, x2) - half_w));
    const xMax = Math.min(fb_width - 1, Math.ceil(Math.max(x1, x2) + half_w));
    const yMin = Math.max(0, Math.floor(Math.min(y1, y2) - half_w));
    const yMax = Math.min(fb_height - 1, Math.ceil(Math.max(y1, y2) + half_w));

    for (let y = yMin; y <= yMax; y++) {
        for (let x = xMin; x <= xMax; x++) {
            // 计算点 (x, y) 到线段的有符号距离
            const px = x - x1;
            const py = y - y1;

            // 投影长度（参数 t）
            const t = (px * dx + py * dy) / len_sq;
            let closest_x, closest_y;

            if (t < 0) {
                closest_x = x1;
                closest_y = y1;
            } else if (t > 1) {
                closest_x = x2;
                closest_y = y2;
            } else {
                closest_x = x1 + t * dx;
                closest_y = y1 + t * dy;
            }

            const dist = Math.sqrt((x - closest_x) * (x - closest_x) + (y - closest_y) * (y - closest_y));

            if (dist > half_w) continue;

            // 抗锯齿：边缘平滑过渡（可选，此处使用简单线性）
            let alpha = 1.0;
            const edge_fade = 1.0; // 像素，可调
            if (dist > half_w - edge_fade) {
                alpha = (half_w - dist) / edge_fade;
                alpha = Math.max(0, Math.min(1, alpha));
            }

            const idx = (y * fb_width + x) * 4;
            const add_r = cr * alpha;
            const add_g = cg * alpha;
            const add_b = cb * alpha;

            frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + add_r);
            frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + add_g);
            frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + add_b);
            frame_buffer[idx + 3] = 255;
        }
    }
}


function draw_circle_outline(frame_buffer, fb_width, fb_height, center_x, center_y, radius, line_weight, red, green, blue, alpha) {
    if (radius <= 0 || line_weight <= 0) return;

    const r = Math.max(0, Math.min(255, Math.round(red)));
    const g = Math.max(0, Math.min(255, Math.round(green)));
    const b = Math.max(0, Math.min(255, Math.round(blue)));
    const a = Math.max(0, Math.min(255, Math.round(alpha)));

    // 计算内外半径（考虑线宽居中）
    const halfWeight = line_weight / 2;
    const outerR = radius + halfWeight;
    const innerR = Math.max(0, radius - halfWeight);

    const outerRSq = outerR * outerR;
    const innerRSq = innerR * innerR;

    // 包围盒（含线宽）
    const xMin = Math.max(0, Math.floor(center_x - outerR));
    const xMax = Math.min(fb_width - 1, Math.ceil(center_x + outerR));
    const yMin = Math.max(0, Math.floor(center_y - outerR));
    const yMax = Math.min(fb_height - 1, Math.ceil(center_y + outerR));

    for (let y = yMin; y <= yMax; y++) {
        for (let x = xMin; x <= xMax; x++) {
            const dx = x - center_x;
            const dy = y - center_y;
            const distSq = dx * dx + dy * dy;

            // 判断是否在环形区域内（包含外边界，排除内边界）
            if (distSq < outerRSq && distSq >= innerRSq) {
                const idx = (y * fb_width + x) * 4;
                frame_buffer[idx]     = Math.min(255, frame_buffer[idx]     + r);
                frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + g);
                frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + b);
                frame_buffer[idx + 3] = Math.min(255, frame_buffer[idx + 2] + a);
            }
        }
    }
}


// 地面填充纯黑色
function draw_horizon(frame_buffer, fb_width, fb_height, R, center_x, center_y, view_alt, view_azi, f, sun_alt) {
    function getPixel(tex, x, y, c) {
        return tex[((y * landscape_texture_width + x) * 4) + c];
    }
    const margin = 10;
    const k = Math.max(0.2, Math.sin(to_rad(sun_alt)) * 1.5);
    for (let y = 0; y < fb_height; y++) {
        for (let x = 0; x < fb_width; x++) {
            const [hx, hy, hz] = fisheye_unproject(x, y, R, center_x, center_y, view_alt, view_azi, f);
            if (hz < 0) {
                if (landscape_texture_rgba === null) {
                    const idx = (y * fb_width + x) * 4;
                    frame_buffer[idx + 0] = 0;     // R
                    frame_buffer[idx + 1] = 0;     // G
                    frame_buffer[idx + 2] = 0;     // B
                    frame_buffer[idx + 3] = 255;   // A
                }
                else {
                    // 反解此处的xyz坐标，转为地平坐标
                    let [alt, azi, rr] = xyz_to_horizontal(hx, hy, hz);
                    // 再转为地面贴图上的xy坐标
                    let [tx, ty] = horizontal_to_screen_xy(-azi, -alt, 300, 300, 300); // R略小于地面贴图的半径，注意修改其中的center_x/y

                    const r = getPixel(landscape_texture_rgba, Math.floor(tx), Math.floor(ty), 0);
                    const g = getPixel(landscape_texture_rgba, Math.floor(tx), Math.floor(ty), 1);
                    const b = getPixel(landscape_texture_rgba, Math.floor(tx), Math.floor(ty), 2);

                    const idx = (y * fb_width + x) * 4;
                    frame_buffer[idx + 0] = r * k;     // R
                    frame_buffer[idx + 1] = g * k;     // G
                    frame_buffer[idx + 2] = b * k;     // B
                    frame_buffer[idx + 3] = 255;   // A
                }
            }
            else if (landscape_texture_rgba === null &&hz <= margin && hz >= 0) {
                let c = 0;
                const t = hz / margin;
                const idx = (y * fb_width + x) * 4;
                frame_buffer[idx + 0] = c + t * (frame_buffer[idx + 0] - c);     // R
                frame_buffer[idx + 1] = c + t * (frame_buffer[idx + 1] - c);     // G
                frame_buffer[idx + 2] = c + t * (frame_buffer[idx + 2] - c);     // B
                frame_buffer[idx + 3] = 255;   // A
            }
        }
    }
}



function draw_sun(frame_buffer, fb_width, fb_height, sun_x, sun_y, sun_altitude_deg, sun_radius) {
    // 1. 太阳半径（随高度变化）：地平线附近略大
    const baseRadius = (sun_radius < 6) ? 6 : sun_radius; // 像素
    const radius = baseRadius * (1 + 0.20 * Math.max(0, 1 - sun_altitude_deg / 10)); // 地平线+15%

    // 2. 光晕半径（可调）
    const glowRadius = 6; // Math.max(radius, 6); // 可根据需要调整

    // 3. 太阳颜色：随高度从红→黄→白
    let r, g, b;
    if (sun_altitude_deg < 5) {
        // 接近地平线：深红到橙
        const t = Math.min(1, sun_altitude_deg / 5);
        r = 255;
        g = Math.round(160 * t);
        b = Math.round(40 * t);
    } else if (sun_altitude_deg < 15) {
        // 低空：橙黄
        const t = (sun_altitude_deg - 5) / 10;
        r = 255;
        g = Math.round(160 + 95 * t);
        b = Math.round(40 + 60 * t);
    } else {
        // 中天：白色
        r = 255;
        g = 255;
        b = 255;
    }

    // 4. 抗锯齿边缘宽度
    const edgeSmoothWidth = 1;

    // 5. 绘制太阳本体（带软边缘）
    for (let dy = -glowRadius; dy <= glowRadius; dy++) {
        for (let dx = -glowRadius; dx <= glowRadius; dx++) {
            const dist = Math.sqrt(dx * dx + dy * dy);
            const px = Math.floor(sun_x + dx);
            const py = Math.floor(sun_y + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            // 背景颜色（用于混合）
            const bgR = frame_buffer[idx] / 255;
            const bgG = frame_buffer[idx + 1] / 255;
            const bgB = frame_buffer[idx + 2] / 255;

            // === 太阳光晕（指数衰减）===
            let glow = 0;
            if (dist > radius && dist <= glowRadius) {
                // 光晕强度随距离衰减
                glow = Math.exp(-(dist / glowRadius) * 3);
            }

            // === 太阳本体（带抗锯齿）===
            let diskWeight = 0;
            if (dist <= radius + edgeSmoothWidth) {
                if (dist <= radius - edgeSmoothWidth) {
                    diskWeight = 1.0;
                }
                else if (dist < radius + edgeSmoothWidth) {
                    const t = (radius + edgeSmoothWidth - dist) / (2 * edgeSmoothWidth);
                    diskWeight = Math.max(0, Math.min(1, t * t * (3 - 2 * t))); // smoothstep
                }
            }

            // 合并：中心最亮（diskWeight=1），向外过渡到光晕
            const totalR = diskWeight * r + glow * r;
            const totalG = diskWeight * g + glow * g;
            const totalB = diskWeight * b + glow * b;

            // 混合到背景（直接覆盖或叠加，这里选择叠加以保留星芒基础）
            frame_buffer[idx]     = Math.min(255, bgR * 255 + totalR);
            frame_buffer[idx + 1] = Math.min(255, bgG * 255 + totalG);
            frame_buffer[idx + 2] = Math.min(255, bgB * 255 + totalB);
        }
    }
}



// 基于球面几何 terminator 的月相绘制（带物理合理的软边缘）
function draw_moon(frame_buffer, fb_width, fb_height, center_x, center_y, lum, radius, phase_deg, bright_limb_pos_angle_deg, surface_tilt_deg) {
    const moonX = center_x;
    const moonY = center_y;
    const moonRadius = radius;

    // 相位角（日地距角）
    const cosPhase = Math.cos(to_rad(phase_deg));
    const sinPhase = Math.sin(to_rad(phase_deg));
    const sunDirX = cosPhase * Math.cos(to_rad(bright_limb_pos_angle_deg));
    const sunDirY = cosPhase * Math.sin(to_rad(bright_limb_pos_angle_deg));
    const sunDirZ = sinPhase;

    const sunLen = Math.sqrt(sunDirX * sunDirX + sunDirY * sunDirY + sunDirZ * sunDirZ);
    const sunUnitX = sunLen > 0 ? sunDirX / sunLen : 1;
    const sunUnitY = sunLen > 0 ? sunDirY / sunLen : 0;
    const sunUnitZ = sunLen > 0 ? sunDirZ / sunLen : 0;

    // 颜色与环境光
    const litColor = [220, 220, 200];
    const darkColor = [10, 10, 20];
    const ambient = 0.01;

    // 半影角宽度（弧度）：太阳角半径 ≈ 0.0047 rad，取稍大值保证可见性
    const PENUMBRA_HALF_ANGLE = 0.2; // ≈ 0.5°

    // 抗锯齿过渡带宽度（像素）
    const edgeSmoothWidth = 1.0;

    const r2 = moonRadius * moonRadius;
    for (let dy = -moonRadius; dy <= moonRadius; dy++) {
        for (let dx = -moonRadius; dx <= moonRadius; dx++) {
            const distSq = dx * dx + dy * dy;
            const distance = Math.sqrt(distSq);

            if (distance > moonRadius + edgeSmoothWidth) continue;

            const px = Math.floor(moonX + dx);
            const py = Math.floor(moonY + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            // === 1. 计算抗锯齿权重（基于圆盘覆盖比例）===
            let moonWeight;
            if (distance <= moonRadius - edgeSmoothWidth) {
                moonWeight = 1.0; // 完全在内部
            }
            else if (distance >= moonRadius + edgeSmoothWidth) {
                moonWeight = 0.0; // 完全在外部（应跳过，但保留以防边界误差）
                continue;
            }
            else {
                // 平滑过渡 [moonRadius - w, moonRadius + w]
                const t = (moonRadius + edgeSmoothWidth - distance) / (2 * edgeSmoothWidth);
                moonWeight = Math.max(0, Math.min(1, t)); // 线性插值，也可用 smoothstep
                // 可选更平滑：moonWeight = t * t * (3 - 2 * t);
            }

            if (moonWeight <= 0) continue;




            // 构造单位球面上的表面点（归一化位置向量 = 法向量）
            const len = Math.sqrt(dx * dx + dy * dy + r2 - dx * dx - dy * dy); // = moonRadius
            // 实际上，(dx, dy, dz) 在半径为 moonRadius 的球面上，所以单位向量为：
            const nx = dx / moonRadius;
            const ny = dy / moonRadius;
            const nz = Math.sqrt(Math.max(0, r2 - dx * dx - dy * dy)) / moonRadius;

            // 关键：计算该点与 terminator 的球面角距离
            // terminator 是太阳方向与月球中心构成的大圆
            // 点积 dot = cos(θ)，其中 θ 是表面点与太阳方向的夹角
            const dot = nx * sunUnitX + ny * sunUnitY + nz * sunUnitZ;

            // θ = acos(dot)，但避免 acos 开销，直接用 dot 表示角度关系
            // terminator 位于 dot = 0（即 θ = 90°）
            // 我们定义 signed_angle_dist ∝ -dot （因为 dot>0 为亮区）
            // 将角距离映射为线性过渡变量（单位：弧度等效）

            // 使用小角度近似：angle ≈ sqrt(1 - dot^2) 不适用；更简单：
            // 直接用 dot 作为“余弦空间”的代理变量，其梯度在 terminator 附近 ≈ 1/rad
            // 因此，我们定义“有效角偏移”为：
            const angleFromTerminator = Math.acos(Math.max(-1, Math.min(1, dot))) - Math.PI / 2; // ∈ [-π/2, π/2]

            // 或者更高效（避免 acos）：利用 sin(θ - π/2) = -cosθ = -dot
            // 在 terminator 附近（θ≈π/2），有 θ - π/2 ≈ -dot （一阶泰勒）
            // 所以可用：approxAngle = -dot （单位为“弧度等效”，需缩放）
            // 但为保精度，这里采用 acos 方法（可选优化见注释）

            // === 软边缘判断 ===
            let intensity;
            if (angleFromTerminator >= PENUMBRA_HALF_ANGLE) {
                intensity = 1.0; // 完全照亮
            } else if (angleFromTerminator <= -PENUMBRA_HALF_ANGLE) {
                intensity = ambient; // 完全背光
            } else {
                // 映射到 [0,1]
                const t = (angleFromTerminator + PENUMBRA_HALF_ANGLE) / (2 * PENUMBRA_HALF_ANGLE);
                const smoothT = t * t * (3 - 2 * t); // smoothstep
                intensity = ambient + (1 - ambient) * smoothT;
            }

            // 调整全局亮度
            intensity *= lum;






            // === 纹理映射：先绕 Z 轴旋转 -alpha，再映射到经纬度 ===
            let u_norm = dx / moonRadius;   // ∈ [-1, 1]
            let v_norm = dy / moonRadius;   // ∈ [-1, 1]

            // 绕原点旋转 -alpha（使贴图随光照方向对齐）
            const cosA = Math.cos(-to_rad(surface_tilt_deg));
            const sinA = Math.sin(-to_rad(surface_tilt_deg));
            const u_rot = u_norm * cosA - v_norm * sinA;
            const v_rot = u_norm * sinA + v_norm * cosA;

            // 映射到 [0,1] 贴图空间
            let u = (u_rot + 1) * 0.5; // [-1,1] → [0,1]
            let v = (v_rot + 1) * 0.5;

            // 可选：限制在 [0,1] 内（避免边缘采样异常）
            if (u < 0 || u > 1 || v < 0 || v > 1) {
                // 可选择 clamp 或 skip；这里 clamp 更安全
                u = Math.max(0, Math.min(1, u));
                v = Math.max(0, Math.min(1, v));
            }

            // 双线性采样
            const tx = u * moon_texture_width - 0.5;
            const ty = v * moon_texture_height - 0.5;

            const x0 = Math.floor(tx);
            const y0 = Math.floor(ty);
            const x1 = (x0 + 1) % moon_texture_width;
            const y1 = Math.min(y0 + 1, moon_texture_height - 1);

            const wx = tx - x0;
            const wy = ty - y0;

            function getPixel(tex, x, y, c) {
                return tex[((y * moon_texture_width + x) * 4) + c];
            }

            const c00_r = getPixel(moon_texture_rgba, x0, y0, 0);
            const c00_g = getPixel(moon_texture_rgba, x0, y0, 1);
            const c00_b = getPixel(moon_texture_rgba, x0, y0, 2);

            const c10_r = getPixel(moon_texture_rgba, x1, y0, 0);
            const c10_g = getPixel(moon_texture_rgba, x1, y0, 1);
            const c10_b = getPixel(moon_texture_rgba, x1, y0, 2);

            const c01_r = getPixel(moon_texture_rgba, x0, y1, 0);
            const c01_g = getPixel(moon_texture_rgba, x0, y1, 1);
            const c01_b = getPixel(moon_texture_rgba, x0, y1, 2);

            const c11_r = getPixel(moon_texture_rgba, x1, y1, 0);
            const c11_g = getPixel(moon_texture_rgba, x1, y1, 1);
            const c11_b = getPixel(moon_texture_rgba, x1, y1, 2);

            // bilinear interpolation
            const r0 = c00_r + wx * (c10_r - c00_r);
            const g0 = c00_g + wx * (c10_g - c00_g);
            const b0 = c00_b + wx * (c10_b - c00_b);

            const r1 = c01_r + wx * (c11_r - c01_r);
            const g1 = c01_g + wx * (c11_g - c01_g);
            const b1 = c01_b + wx * (c11_b - c01_b);

            let texR = r0 + wy * (r1 - r0);
            let texG = g0 + wy * (g1 - g0);
            let texB = b0 + wy * (b1 - b0);

            // 应用光照强度
            let r = Math.round(texR * intensity);
            let g = Math.round(texG * intensity);
            let b = Math.round(texB * intensity);

            r = isNaN(r) ? 0 : r;
            g = isNaN(g) ? 0 : g;
            b = isNaN(b) ? 0 : b;

            frame_buffer[idx + 0] = Math.min(255, frame_buffer[idx + 0] + moonWeight * r);
            frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + moonWeight * g);
            frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + moonWeight * b);
        }
    }
}



function draw_star(frame_buffer, fb_width, fb_height, sx, sy, magnitude, radius, red, green, blue) {

    const maxGlowRadius = 2; // 光晕最大半径（像素）

    const starLumBase = magnitude_to_relative_luminance(magnitude);

    // 获取背景亮度用于对比度抑制
    const bgIdx = Math.round(sy * fb_width + sx) * 4;
    const bgR = frame_buffer[bgIdx] / 255;
    const bgG = frame_buffer[bgIdx + 1] / 255;
    const bgB = frame_buffer[bgIdx + 2] / 255;
    const bgLum = 0.299 * bgR + 0.587 * bgG + 0.114 * bgB;

    // 遍历光晕区域（正方形包围圆）
    const R = radius + maxGlowRadius;
    for (let dy = -R; dy <= R; dy++) {
        for (let dx = -R; dx <= R; dx++) {
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > R) continue;

            const px = Math.round(sx + dx);
            const py = Math.round(sy + dy);
            if (px < 0 || px >= fb_width || py < 0 || py >= fb_height) continue;

            const idx = (py * fb_width + px) * 4;

            let starLum = 0;
            if (dist <= radius) {
                starLum = starLumBase;
            }
            // 光晕衰减
            else if (dist > radius) {
                starLum = starLumBase * Math.exp(-dist * 1);
            }

            // 对比度抑制：白天背景亮时，星星和光晕都应被压制
            const contrast = starLum / (bgLum + 0.001);
            let visibility = 1.0;
            if (contrast < 1.0) {
                // visibility = Math.pow(contrast, 3);
                visibility = contrast * contrast * contrast;
            }
            starLum *= visibility;

            // 转为 0–255 范围
            const r = Math.min(255, starLum * red);
            const g = Math.min(255, starLum * green);
            const b = Math.min(255, starLum * blue);

            // 叠加到 RGB（保持白色光晕，可改为彩色）
            frame_buffer[idx + 0] = Math.min(255, frame_buffer[idx + 0] + r);
            frame_buffer[idx + 1] = Math.min(255, frame_buffer[idx + 1] + g);
            frame_buffer[idx + 2] = Math.min(255, frame_buffer[idx + 2] + b);
        }
    }
}


/**
 * 绘制赤道坐标系下的子午圈或纬度圈（投影到地平屏幕）
 * @param {Uint8ClampedArray} frame_buffer - 帧缓冲区
 * @param {number} fb_width - 缓冲区宽度
 * @param {number} fb_height - 缓冲区高度
 * @param {boolean} isMeridian - true: 子午圈（固定RA）；false: 纬度圈（固定Dec）
 * @param {number|null} ra_hours - 子午圈的赤经（小时），仅当 isMeridian=true 时有效
 * @param {number|null} dec_deg - 纬度圈的赤纬（度），仅当 isMeridian=false 时有效
 * @param {number} line_weight - 线宽（像素），建议 ≥1
 * @param {number} colorR, colorG, colorB - RGB 颜色分量 [0-255]
 * @param {number} year, month, day, hour, minute, second, timezone, longitude, latitude - 观测参数
 */
function draw_celestial_circle(
    frame_buffer, fb_width, fb_height,
    sky_radius, center_x, center_y,
    view_alt, view_azi, f,
    isMeridian, ra_hours, dec_deg,
    line_weight, colorR, colorG, colorB,
    year, month, day, hour, minute, second, timezone, longitude, latitude
) {
    const POINTS = 360; // 提高采样密度以获得更平滑曲线
    const R = sky_radius;

    let points = [];

    if (isMeridian) {
        // 子午圈：固定 RA，遍历 Dec ∈ [-90°, +90°]
        if (ra_hours === null || ra_hours < 0 || ra_hours > 24) return;
        const ra_deg = (ra_hours % 24) * 15;
        for (let i = 0; i <= POINTS; i++) {
            const dec = -90 + (180 * i / POINTS);
            const [alt, az] = equatorial_to_horizontal(
                ra_deg, dec, year, month, day, hour, minute, second, timezone, longitude, latitude
            );
            if (alt >= 0) {
                const [x, y] = fisheye_project(az, alt, R, center_x, center_y, view_alt, view_azi, f);
                points.push([x, y]);
            } else {
                points.push(null);
            }
        }
    } else {
        // 纬度圈：固定 Dec，遍历 RA ∈ [0h, 24h)
        if (dec_deg === null || dec_deg < -90 || dec_deg > 90) return;
        for (let i = 0; i <= POINTS; i++) {
            const ra_h = 24 * i / POINTS;
            const ra_deg = (ra_h % 24) * 15;
            const [alt, az] = equatorial_to_horizontal(
                ra_deg, dec_deg, year, month, day, hour, minute, second, timezone, longitude, latitude
            );
            if (alt >= 0) {
                const [x, y] = fisheye_project(az, alt, R, center_x, center_y, view_alt, view_azi, f);
                points.push([x, y]);
            } else {
                points.push(null);
            }
        }
    }

    // 使用抗锯齿 draw_line 连接可见段
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        if (p1 && p2) {
            draw_line(frame_buffer, fb_width, fb_height, p1[0], p1[1], p2[0], p2[1], line_weight, colorR, colorG, colorB);
        }
    }
}


function draw_ecliptic_circle(
    frame_buffer, fb_width, fb_height,
    sky_radius, center_x, center_y,
    view_alt, view_azi, f,
    line_weight, colorR, colorG, colorB,
    year, month, day, hour, minute, second, timezone, longitude, latitude
) {
    const POINTS = 360; // 提高采样密度以获得更平滑曲线
    const R = sky_radius;

    let points = [];

    for (let i = 0; i <= POINTS; i++) {
        // 计算黄道上各点的赤经赤纬
        let lmd = (360.0 * i / POINTS);
        const [RA, Dec] = ecliptic_to_equatorial(lmd, 0);
        // 将其转为地平坐标
        const [alt, az] = equatorial_to_horizontal(
            RA, Dec, year, month, day, hour, minute, second, timezone, longitude, latitude
        );
        if (alt >= 0) {
            const [x, y] = fisheye_project(az, alt, R, center_x, center_y, view_alt, view_azi, f);
            points.push([x, y]);
        } else {
            points.push(null);
        }
    }

    // 使用抗锯齿 draw_line 连接可见段
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        if (p1 && p2) {
            draw_line(frame_buffer, fb_width, fb_height, p1[0], p1[1], p2[0], p2[1], line_weight, colorR, colorG, colorB);
        }
    }
}























// 计算大气散射强度（模型1）
function scatter_model_1(ray_vec, sun_vec) {

    // 返回值
    let red = 0;
    let green = 0;
    let blue = 0;

    // 视线向量归一化
    const ray_length = Math.sqrt(ray_vec[0] * ray_vec[0] + ray_vec[1] * ray_vec[1] + ray_vec[2] * ray_vec[2]);
    if (ray_length === 0) {
        red = 0;
        green = 0;
        blue = 0;
        return [red, green, blue];
    }
    const ray_norm = [];
    ray_norm[0] = ray_vec[0] / ray_length;
    ray_norm[1] = ray_vec[1] / ray_length;
    ray_norm[2] = ray_vec[2] / ray_length;


    // 太阳方向归一化
    const sun_vec_radius = Math.sqrt(sun_vec[0] * sun_vec[0] + sun_vec[1] * sun_vec[1] + sun_vec[2] * sun_vec[2]);
    if (sun_vec_radius === 0) {
        red = 0;
        green = 0;
        blue = 0;
        return [red, green, blue];
    }
    const sun_norm = [];
    sun_norm[0] = sun_vec[0] / sun_vec_radius;
    sun_norm[1] = sun_vec[1] / sun_vec_radius;
    sun_norm[2] = sun_vec[2] / sun_vec_radius;


    // 太阳光入射路径：计算仰角、天顶角、大气光学质量
    const sunElevation = Math.asin(Math.max(-1, Math.min(1, sun_norm[2]))); // [-π/2, π/2]
    const sunElevationDeg = sunElevation * 180 / Math.PI;
    const sunZenith = Math.PI / 2 - sunElevation; // [0, π]
    const sunZenithDeg = sunZenith * 180 / Math.PI;
    let sunAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (sunElevationDeg >= 0) {
        sunAirMass = 1.0 / (Math.cos(sunZenith) + 0.50572 * Math.pow(96.07995 - sunZenithDeg, -1.6364));
    }
    else {
        sunAirMass = 40;
    }


    // 观察者视线的仰角、天顶角、大气光学质量
    const viewZenith = Math.acos(Math.max(0, Math.min(1, ray_norm[2])));
    const viewZenithDeg = viewZenith * 180 / Math.PI;
    const viewElevationDeg = 90 - viewZenithDeg;
    let viewAirMass;
    // Kasten-Young, Ref. https://kexue.fm/archives/396
    if (viewElevationDeg >= 0) {
        viewAirMass = 1.0 / (Math.cos(viewZenith) + 0.50572 * Math.pow(96.07995 - viewZenithDeg, -1.6364));
    }
    else {
        viewAirMass = 40;
    }


    // 观察方向与太阳方向夹角余弦
    const cosTheta = ray_norm[0] * sun_norm[0] + ray_norm[1] * sun_norm[1] + ray_norm[2] * sun_norm[2];


    // 米氏散射相函数
    const miePhase = Math.pow(1 + PHYSICS.MIE_G * PHYSICS.MIE_G - 2 * PHYSICS.MIE_G * cosTheta, -1.5);


    // 瑞利散射相函数
    const rayleighPhase = (1 + cosTheta * cosTheta) / 4 * 3;


    // 计算视线方向的大气密度系数：直觉上来看，密度越大，对散射的贡献越大
    const H = PHYSICS.ATMOSPHERE_HEIGHT; // km，标高
    const mu = Math.max(0.01, ray_norm[2]); // 避免除零，mu = cos(天顶角)
    const densityFactor = Math.exp(-mu / H);


    // 分波长计算瑞利散射系数
    const wavelengths = PHYSICS.RAYLEIGH_WAVELENGTH_FACTORS;
    const rayleighBetaBase = PHYSICS.RAYLEIGH_BETA; // 参考波长下的 β
    const referenceWavelength = wavelengths[1]; // G分量作为参考（550nm）
    const betaRayleigh = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // betaRayleigh[i] = rayleighBetaBase * Math.pow(referenceWavelength / wavelengths[i], 4);
        const wl = referenceWavelength / wavelengths[i];
        const wlwl = wl * wl;
        betaRayleigh[i] = rayleighBetaBase * wlwl * wlwl;
    }


    // 米氏散射系数：地平线附近，气溶胶浓度剧增（用viewAirMass模拟），米氏散射贡献显著上升
    const effectiveMieBeta = Math.min(PHYSICS.MIE_BETA_MAX, PHYSICS.MIE_BETA_BASE * viewAirMass);


    // 计算每个通道的散射强度（考虑光程衰减）
    const intensities = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // 散射光强度 ∝ 相函数 × exp(-totalBeta * sunAirMass) × density
        // 注意：实际是体散射积分，此处简化为比例模型
        const rayleighContrib = betaRayleigh[i] * rayleighPhase;
        const mieContrib = effectiveMieBeta * miePhase;

        const totalBeta = betaRayleigh[i] + effectiveMieBeta; // 总消光系数（简化）

        // 衰减：散射光在传播到观察者途中也会被吸收
        // 关键修正：衰减中加入时间调节因子，控制一天中不同时间的衰减强度，防止白天出现过于明显的维纳斯带
        // let attn_scale = 0.5 * Math.cos(2 * sunElevation) + 0.501;
        let attn_scale = (sunElevationDeg >= 0) ? Math.exp(- Math.pow((sunElevationDeg / 20), 4)) + 0.01 : 1;
        let attenuation = Math.exp(-totalBeta * viewAirMass * attn_scale);

        const totalScattering = (rayleighContrib + mieContrib) * attenuation * densityFactor;

        // 臭氧吸收
        const ozoneTransmittance = Math.exp(-PHYSICS.OZONE_ABSORPTION[i] * sunAirMass * 0.8); // 调节因子

        intensities[i] = totalScattering * ozoneTransmittance;
    }

    // 归一化或缩放到 [0,1]
    red   = intensities[0];
    green = intensities[1];
    blue  = intensities[2];

    // 太阳落到地平线以下时，进一步衰减散射光
    const night_attn = (sunElevationDeg >= 0) ? 1.0 : Math.max(0, Math.exp(0.016 * sunElevationDeg));
    red   *= night_attn;
    green *= night_attn;
    blue  *= night_attn;

    // 全局增益
    const global_gain = 2.0;

    return [
        Math.min(1, red   * global_gain), // R
        Math.min(1, green * global_gain), // G
        Math.min(1, blue  * global_gain)  // B
    ];
}




// 计算大气散射强度（模型2：Nishita模型）
// Ref. https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky.html
function scatter_model_2(ray_vec, sun_vec) {

    // 返回值
    let red = 0;
    let green = 0;
    let blue = 0;

    // 视线向量归一化
    const ray_length = Math.sqrt(ray_vec[0] * ray_vec[0] + ray_vec[1] * ray_vec[1] + ray_vec[2] * ray_vec[2]);
    if (ray_length === 0) {
        red = 0;
        green = 0;
        blue = 0;
        return [red, green, blue];
    }
    const ray_norm = [];
    ray_norm[0] = ray_vec[0] / ray_length;
    ray_norm[1] = ray_vec[1] / ray_length;
    ray_norm[2] = ray_vec[2] / ray_length;


    // 太阳方向归一化
    const sun_vec_radius = Math.sqrt(sun_vec[0] * sun_vec[0] + sun_vec[1] * sun_vec[1] + sun_vec[2] * sun_vec[2]);
    if (sun_vec_radius === 0) {
        red = 0;
        green = 0;
        blue = 0;
        return [red, green, blue];
    }
    const sun_norm = [];
    sun_norm[0] = sun_vec[0] / sun_vec_radius;
    sun_norm[1] = sun_vec[1] / sun_vec_radius;
    sun_norm[2] = sun_vec[2] / sun_vec_radius;


    // 太阳光入射路径：计算仰角、天顶角、大气光学质量
    const sunElevation = Math.asin(Math.max(-1, Math.min(1, sun_norm[2]))); // [-π/2, π/2]
    const sunElevationDeg = sunElevation * 180 / Math.PI;

    // 观察者视线的仰角、天顶角、大气光学质量
    const viewZenith = Math.acos(Math.max(0, Math.min(1, ray_norm[2])));
    const viewZenithDeg = viewZenith * 180 / Math.PI;
    const viewElevationDeg = 90 - viewZenithDeg;

    // 观察方向与太阳方向夹角余弦
    const cosTheta = ray_norm[0] * sun_norm[0] + ray_norm[1] * sun_norm[1] + ray_norm[2] * sun_norm[2];

    // 米氏散射相函数
    const g = 0.76;
    const miePhase = 3.0 / (8.0 * Math.PI) * ((1.0 - g*g) * (1 + cosTheta * cosTheta)) / ((2.0 + g*g) * Math.pow(1.0 + g*g - 2.0 * g * cosTheta, 1.5));

    // 瑞利散射相函数
    const rayleighPhase = (1 + cosTheta * cosTheta) / 4 * 3;

    // 分波长计算瑞利散射系数
    const wavelengths = PHYSICS.RAYLEIGH_WAVELENGTH_FACTORS;
    const rayleighBetaBase = 0.04; // 参考波长下的 β
    const referenceWavelength = wavelengths[1]; // G分量作为参考（550nm）
    const betaRayleigh = [];
    for (let i = 0; i < wavelengths.length; i++) {
        // betaRayleigh[i] = rayleighBetaBase * Math.pow(referenceWavelength / wavelengths[i], 4);
        const wl = referenceWavelength / wavelengths[i];
        const wlwl = wl * wl;
        betaRayleigh[i] = rayleighBetaBase * wlwl * wlwl;
    }

    // 米氏散射beta
    const beta_Mie = 0.05;

    const H = 8.0; // 大气层厚度
    const H_R = 8.0;
    const H_M = 1.2;
    const R = (sunElevationDeg >= 0) ? ((3000-300) * Math.exp(-sunElevationDeg * 0.1) + 300) : ((3000-60) * Math.exp(sunElevationDeg * 0.2) + 60);

    const S = 4;

    // 已知三角形ABC，AB固定为(R-H)，AC固定为R，角B=α+90°，求BC关于α的表达式。

    const view_alt = (viewElevationDeg >= 90) ? (180 - viewElevationDeg) : viewElevationDeg;
    const cos_view_alt = Math.cos(to_rad(view_alt));
    const sin_view_alt = Math.sin(to_rad(view_alt));
    const Lray = Math.sqrt(R*R - (R-H)*(R-H) * cos_view_alt * cos_view_alt) - (R-H) * sin_view_alt;

    const sun_alt = (sunElevationDeg >= 90) ? (180 - sunElevationDeg) : sunElevationDeg;
    const cos_sun_alt = Math.cos(to_rad(sun_alt));
    const sin_sun_alt = Math.sin(to_rad(sun_alt));
    const Lsun = Math.sqrt(R*R - (R-H)*(R-H) * cos_sun_alt * cos_sun_alt) - (R-H) * sin_sun_alt;

    let sum_R_r = 0; let sum_R_g = 0; let sum_R_b = 0;
    let sum_M_r = 0; let sum_M_g = 0; let sum_M_b = 0;
    let depth_R = 0;
    let depth_M = 0;

    for (let i = 0; i < S; i++) {
        let t = i / S;

        let L_t = t * Lray;
        let dl = L_t / S;
        let h_R_t = t * H_R;
        let h_M_t = t * H_M;
        let density_R_t = Math.exp(-h_R_t / H_R);
        let density_M_t = Math.exp(-h_M_t / H_M);

        depth_R += density_R_t * dl;
        depth_M += density_M_t * dl;

        let depth_sun_R = 0;
        let depth_sun_M = 0;

        let Lsun_t = (1-t) * Lsun;
        let dlsun = Lsun_t / S;

        for (let j = 0; j < S; j++) {
            let n = j / S;
            let hsun_R = h_R_t + n * (1-t) * H_R;
            let hsun_M = h_M_t + n * (1-t) * H_M;
            let density_sun_R = Math.exp(-hsun_R / H_R);
            let density_sun_M = Math.exp(-hsun_M / H_M);
            depth_sun_R += density_sun_R * dlsun;
            depth_sun_M += density_sun_M * dlsun;
        }

        let tau_r = betaRayleigh[0] * (depth_sun_R + depth_R) + beta_Mie * (depth_sun_M + depth_M) * 1.1;
        let tau_g = betaRayleigh[1] * (depth_sun_R + depth_R) + beta_Mie * (depth_sun_M + depth_M) * 1.1;
        let tau_b = betaRayleigh[2] * (depth_sun_R + depth_R) + beta_Mie * (depth_sun_M + depth_M) * 1.1;

        let attn_r = Math.exp(-tau_r);
        let attn_g = Math.exp(-tau_g);
        let attn_b = Math.exp(-tau_b);

        sum_R_r += attn_r * depth_R; sum_R_g += attn_g * depth_R; sum_R_b += attn_b * depth_R;
        sum_M_r += attn_r * depth_M; sum_M_g += attn_g * depth_M; sum_M_b += attn_b * depth_M;
    }

    // 臭氧吸收
    const oz_factor = 0.16;
    const oz_r = Math.exp(-PHYSICS.OZONE_ABSORPTION[0] * Lsun * oz_factor);
    const oz_g = Math.exp(-PHYSICS.OZONE_ABSORPTION[1] * Lsun * oz_factor);
    const oz_b = Math.exp(-PHYSICS.OZONE_ABSORPTION[2] * Lsun * oz_factor);

    red   = (sum_R_r * betaRayleigh[0] * rayleighPhase + sum_M_r * beta_Mie * miePhase) * oz_r;
    green = (sum_R_g * betaRayleigh[1] * rayleighPhase + sum_M_g * beta_Mie * miePhase) * oz_g;
    blue  = (sum_R_b * betaRayleigh[2] * rayleighPhase + sum_M_b * beta_Mie * miePhase) * oz_b;

    // 全局增益
    const global_gain = 2.4;

    return [
        Math.min(1, red   * global_gain), // R
        Math.min(1, green * global_gain), // G
        Math.min(1, blue  * global_gain)  // B
    ];
}



function calculate_scattered_pixel(ray_vec, sun_vec, model_index) {
    if (model_index === 1) {
        return scatter_model_1(ray_vec, sun_vec);
    }
    else if (model_index === 2) {
        return scatter_model_2(ray_vec, sun_vec);
    }
    else {
        return [0,0,0];
    }
}



function set_pixel(frame_buffer, fb_width, fb_height, x, y, r, g, b) {
    let pixel_index = (y * fb_width + x) * 4;
    frame_buffer[pixel_index    ] = Math.min(255, r);
    frame_buffer[pixel_index + 1] = Math.min(255, g);
    frame_buffer[pixel_index + 2] = Math.min(255, b);
    frame_buffer[pixel_index + 3] = 255;
}



// 渲染整个天空
function render_all(
    frame_buffer, fb_width, fb_height,
    sky_radius, center_x, center_y,
    view_alt, view_azi, f,
    year, month, day, hour, minute, second, timezone, longitude, latitude
) {

    // 计算太阳位置
    const sun_horizontal_coord = where_is_the_sun(year, month, day, hour, minute, second, timezone, longitude, latitude);
    const sun_vec = horizontal_to_xyz(sun_horizontal_coord[1], sun_horizontal_coord[0], RADIUS);
    const sun_proj_xy = fisheye_project(sun_horizontal_coord[1], sun_horizontal_coord[0], RADIUS, center_x, center_y, view_alt, view_azi, f);


    // 计算月球位置、月相、月球方向角

    let jd = julian_day(year, month, day, hour, minute, second, timezone);

    let moon_ec = calculate_lunar_equatorial_coordinates(jd);
    let moon_RA = moon_ec[0];
    let moon_Dec = moon_ec[1];

    let moon_hc = equatorial_to_horizontal(moon_RA, moon_Dec, year, month, day, hour, minute, second, timezone, longitude, latitude);
    let moon_azi = moon_hc[1];
    let moon_alt = moon_hc[0];

    // 计算月球的屏幕投影坐标
    let moon_proj_xy = fisheye_project(moon_azi, moon_alt, RADIUS, center_x, center_y, view_alt, view_azi, f);

    const xa = moon_proj_xy[0];
    const ya = moon_proj_xy[1];

    // 以下是计算月面贴图的北极（月球地理北极）相对于屏幕y轴的旋转角
    // 这一步是旋转月球地理北极，使其指向其所在的天球子午圈北向切线方向，为后面计算月球亮区旋转角作准备
    // 天球赤道坐标系经圈（子午圈）上，月亮所在位置往北2度的位置，在屏幕上的投影坐标

    let northdelta_hc = equatorial_to_horizontal(
        moon_RA, moon_Dec + 2, year, month, day, hour, minute, second, timezone,
        longitude, latitude);

    let northdelta_azi = northdelta_hc[1];
    let northdelta_alt = northdelta_hc[0];

    let northdelta_scr_xy = fisheye_project(northdelta_azi, northdelta_alt, RADIUS, center_x, center_y, view_alt, view_azi, f);
    let xb = northdelta_scr_xy[0];
    let yb = northdelta_scr_xy[1];

    // 计算月面贴图的北极（月球地理北极）相对于屏幕y轴的旋转角
    let tilt_rad = Math.atan2(xb-xa, -(yb-ya)); // 屏幕坐标系y向下为正
    let tilt_deg = normalize_angle(to_deg(tilt_rad));

    // 月面视圆盘的亮区拱点，在天球赤道坐标系背景上，相对于天北极方向向东的偏转角度
    let bright_pos_deg = moon_bright_limb_pos_angle(year, month, day, hour, minute, second, timezone);
    bright_pos_deg = normalize_angle(bright_pos_deg);
    // 假定月面亮区两端永远是月球的地理南北极
    bright_pos_deg = normalize_angle(tilt_deg - (bright_pos_deg-90)); // NOTE 仰视东西颠倒；亮区拱点和亮区的尖尖相差90度

    // 月相
    let moon_i = moon_phase(year, month, day, hour, minute, second, timezone);
    let phase_deg = normalize_angle(moon_i - 90);


    // 大气散射
    if (enable_atmospheric_scattering > 0) {

        const sky_radius = RADIUS;
        const center_x = RADIUS;
        const center_y = RADIUS;

        let C = 8; // 降采样因子
        if (sun_horizontal_coord[0] < -18.0) {
            C = (enable_opt_bilinear && !enable_opt_sym) ? 16 : 8;
        }
        else {
            C = (enable_opt_bilinear && !enable_opt_sym) ? 8 : 2;
        }

        if (enable_opt_sym) {
            for (let y = 0; y < fb_height; y+=2) {
                for (let x = 0; x < fb_width; x+=2) {

                    // 计算太阳与圆心的连线法向量，进而计算半圆范围和镜像点坐标
                    let dx = sun_proj_xy[0] - center_x;
                    let dy = sun_proj_xy[1] - center_y;
                    let t = ((x - center_x) * dx + (y - center_y) * dy) / (dx * dx + dy * dy);
                    let xx = Math.floor(sky_radius * 2 + 2 * t * dx - x);
                    let yy = Math.floor(sky_radius * 2 + 2 * t * dy - y);

                    if ((xx - center_x) * (xx - center_x) + (yy - center_y) * (yy - center_y) > sky_radius * sky_radius ||
                        (x - center_x) * (x - center_x) + (y - center_y) * (y - center_y) > sky_radius * sky_radius
                    ) {
                        continue;
                    }

                    let c0 = (-center_x) * dy - (-center_y) * dx;
                    let nx = (c0 > 0) ? (dy) : (-dy);
                    let ny = (c0 > 0) ? (-dx) : (dx);

                    let dp = nx * (x - center_x) + ny * (y - center_y);

                    if (dp >= 0) {
                        // 观察者到该像素的方向向量（从屏幕坐标系转回地平天球的笛卡尔坐标系）
                        let ray_vec = fisheye_unproject(x, y, sky_radius, center_x, center_y, view_alt, view_azi, f);
                        const ssp = calculate_scattered_pixel(ray_vec, sun_vec, enable_atmospheric_scattering);

                        set_pixel(frame_buffer, fb_width, fb_height, (x+0), (y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+0), (y+1), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+0), (y+2), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+1), (y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+1), (y+1), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+1), (y+2), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+2), (y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+2), (y+1), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (x+2), (y+2), ssp[0]*255, ssp[1]*255, ssp[2]*255);

                        let offset_x = (dy/dx < 1 && dy/dx >= 0) ? 1 : 0;
                        let offset_y = (dy/dx >= 1 && dy/dx >= 0) ? 1 : 0;
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+0), (yy+offset_y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+0), (yy+offset_y+1), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+0), (yy+offset_y+2), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+1), (yy+offset_y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+1), (yy+offset_y+1), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+1), (yy+offset_y+2), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+2), (yy+offset_y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+2), (yy+offset_y+1), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                        set_pixel(frame_buffer, fb_width, fb_height, (xx+offset_x+2), (yy+offset_y+2), ssp[0]*255, ssp[1]*255, ssp[2]*255);

                    }
                }
            }
        }
        else {

            for (let y = 0; y < fb_height; y+=C) {
                for (let x = 0; x < fb_width; x+=C) {

                    // 观察者到该像素的方向向量（从屏幕坐标系转回地平天球的笛卡尔坐标系）
                    let ray_vec = fisheye_unproject(x, y, sky_radius, center_x, center_y, view_alt, view_azi, f);
                    const ssp = calculate_scattered_pixel(ray_vec, sun_vec, enable_atmospheric_scattering);

                    if (enable_opt_bilinear) {
                        set_pixel(frame_buffer, fb_width, fb_height, (x+0), (y+0), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                    }
                    else {
                        for (let i = 0; i < C; i++) {
                            for (let j = 0; j < C; j++) {
                                set_pixel(frame_buffer, fb_width, fb_height, (x+j), (y+i), ssp[0]*255, ssp[1]*255, ssp[2]*255);
                            }
                        }
                    }
                }
            }
        }

        if (enable_opt_bilinear) {

            // 双线性插值以缓解块效应
            for (let y = 0; y < fb_height; y+=C) {
                for (let x = 0; x < fb_width; x+=C) {

                    // const r2 = (x-center_x)*(x-center_x) + (y-center_y)*(y-center_y);
                    // if (r2 > (sky_radius+C)*(sky_radius+C)) continue;

                    let idx_11 = ((y+0) * fb_width + (x+0)) * 4;
                    let idx_12 = ((y+0) * fb_width + (x+C)) * 4;
                    let idx_21 = ((y+C) * fb_width + (x+0)) * 4;
                    let idx_22 = ((y+C) * fb_width + (x+C)) * 4;

                    let r11 = frame_buffer[idx_11 + 0] ?? 0; let r12 = frame_buffer[idx_12 + 0] ?? 0; let r21 = frame_buffer[idx_21 + 0] ?? 0; let r22 = frame_buffer[idx_22 + 0] ?? 0;
                    let g11 = frame_buffer[idx_11 + 1] ?? 0; let g12 = frame_buffer[idx_12 + 1] ?? 0; let g21 = frame_buffer[idx_21 + 1] ?? 0; let g22 = frame_buffer[idx_22 + 1] ?? 0;
                    let b11 = frame_buffer[idx_11 + 2] ?? 0; let b12 = frame_buffer[idx_12 + 2] ?? 0; let b21 = frame_buffer[idx_21 + 2] ?? 0; let b22 = frame_buffer[idx_22 + 2] ?? 0;

                    // 检查并处理黑边
                    if (r11+b11+g11 === 0) {
                        if      (r22+b22+g22 != 0) { r11 = r22; g11 = g22; b11 = b22; }
                        else if (r12+b12+g12 != 0) { r11 = r12; g11 = g12; b11 = b12; }
                        else if (r21+b21+g21 != 0) { r11 = r21; g11 = g21; b11 = b21; }
                    }
                    if (r12+b12+g12 === 0) {
                        if      (r22+b22+g22 != 0) { r12 = r22; g12 = g22; b12 = b22; }
                        else if (r11+b11+g11 != 0) { r12 = r11; g12 = g11; b12 = b11; }
                        else if (r21+b21+g21 != 0) { r12 = r21; g12 = g21; b12 = b21; }
                    }
                    if (r21+b21+g21 === 0) {
                        if      (r22+b22+g22 != 0) { r21 = r22; g21 = g22; b21 = b22; }
                        else if (r11+b11+g11 != 0) { r21 = r11; g21 = g11; b21 = b11; }
                        else if (r12+b12+g12 != 0) { r21 = r12; g21 = g12; b21 = b12; }
                    }
                    if (r22+b22+g22 === 0) {
                        if      (r21+b21+g21 != 0) { r22 = r21; g22 = g21; b22 = b21; }
                        else if (r11+b11+g11 != 0) { r22 = r11; g22 = g11; b22 = b11; }
                        else if (r12+b12+g12 != 0) { r22 = r12; g22 = g12; b22 = b12; }
                    }

                    for (let i = 0; i < C; i++) {
                        for (let j = 0; j < C; j++) {
                            let idx = ((y+i) * fb_width + (x+j)) * 4;
                            let v = i/C;
                            let u = j/C;
                            frame_buffer[idx + 0] = (1-u)*(1-v)*r11 + u*(1-v)*r12 + (1-u)*v*r21 + u*v*r22;
                            frame_buffer[idx + 1] = (1-u)*(1-v)*g11 + u*(1-v)*g12 + (1-u)*v*g21 + u*v*g22;
                            frame_buffer[idx + 2] = (1-u)*(1-v)*b11 + u*(1-v)*b12 + (1-u)*v*b21 + u*v*b22;
                        }
                    }
                }
            }
        }
    }



    const moon_radius = Math.round(RADIUS * 0.08);

    draw_moon(
        frame_buffer, RADIUS*2, RADIUS*2, moon_proj_xy[0], moon_proj_xy[1],
        0.8, moon_radius, phase_deg, bright_pos_deg, tilt_deg);


    const sun_radius = Math.round(RADIUS * 0.02);

    draw_sun(frame_buffer, RADIUS*2, RADIUS*2, sun_proj_xy[0], sun_proj_xy[1], sun_horizontal_coord[0], sun_radius);

    // 绘制星芒
    if (enable_star_burst && sun_horizontal_coord[0] > 0) {
        star_burst_filter(frame_buffer, RADIUS*2, RADIUS*2, sun_proj_xy[0], sun_proj_xy[1], 0, 0.97, 160);
    }

    // 绘制恒星等其他天体
    const mag_offset = -2;
    for (let i = 0; i < STARS.length; i++) {
        const star_item = STARS[i];
        const star_ec = equatorial_to_horizontal(
                            ra_hms_to_deg(star_item[0], star_item[1], star_item[2]),
                            dec_dms_to_decimal(star_item[3], star_item[4], star_item[5]),
                            year, month, day, hour, minute, second, timezone, longitude, latitude);

        const proj_xy = fisheye_project(star_ec[1], star_ec[0], RADIUS, center_x, center_y, view_alt, view_azi, f);
        const mag = Math.random() * 0.5 + mag_offset + star_item[6];
        draw_star(frame_buffer, RADIUS*2, RADIUS*2, proj_xy[0], proj_xy[1], mag, 1, 255, 255, 255);
        if (enable_star_name) {
            fb_draw_textline(frame_buffer, fb_width, fb_height, STAR_NAME[i], proj_xy[0]+3, proj_xy[1]+3, 255, 255, 255);
        }
    }

    // 绘制黄道
    if (enable_ecliptic_circle) {
        draw_ecliptic_circle(
            frame_buffer, fb_width, fb_height,
            sky_radius, center_x, center_y,
            view_alt, view_azi, f,
            6, 16, 16, 0,
            year, month, day, hour, minute, second, timezone, longitude, latitude
        );
    }

    // 绘制大行星
    if (enable_planet) {
        for (let i = 8; i >= 1; i--) { // 之所以倒数，是为了让靠近太阳的行星后绘制，使其覆盖在远离太阳的行星上面
            if (i == 3) continue; // 跳过地球

            const planet_hc = where_is_the_planet(year, month, day, hour, minute, second, timezone, longitude, latitude, i);
            const planet_azi = planet_hc[1];
            const planet_alt = planet_hc[0];

            const planet_proj_xy = fisheye_project(planet_azi, planet_alt, RADIUS, center_x, center_y, view_alt, view_azi, f);
            const planet_proj_x = planet_proj_xy[0];
            const planet_proj_y = planet_proj_xy[1];

            draw_star(frame_buffer, RADIUS*2, RADIUS*2, planet_proj_x, planet_proj_y,
                0, PLANET_RADIUS[i], PLANET_COLOR_R[i], PLANET_COLOR_G[i], PLANET_COLOR_B[i]);

            if (enable_planet_name) {
                fb_draw_textline(frame_buffer, fb_width, fb_height, PLANET_NAME[i], planet_proj_x+3, planet_proj_y+3, PLANET_COLOR_R[i], PLANET_COLOR_G[i], PLANET_COLOR_B[i]);
            }
        }
    }


    // 绘制赤道坐标网格
    if (enable_equatorial_coord) {
        // 绘制赤道天球子午圈
        for (let i = 0; i < 24; i += 2) {
            let line_width = (i === 0 || i == 12) ? 3 : 2;
            draw_celestial_circle(
                frame_buffer, RADIUS*2, RADIUS*2,
                sky_radius, center_x, center_y,
                view_alt, view_azi, f,
                true, i, null,
                line_width, 8, 16, 32,
                year, month, day, hour, minute, second, timezone, longitude, latitude
            );
        }
        // 绘制赤道天球等纬度圈
        for (let i = -90; i < 90; i += 10) {
            let line_width = (i === 0) ? 3 : 2;
            draw_celestial_circle(
                frame_buffer, RADIUS*2, RADIUS*2,
                sky_radius, center_x, center_y,
                view_alt, view_azi, f,
                false, null, i,
                line_width, 8, 16, 32,
                year, month, day, hour, minute, second, timezone, longitude, latitude
            );
        }
    }

    // 绘制方位文字
    if (enable_horizontal_coord) {
        let lable_north = fisheye_project(0, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "北", lable_north[0], lable_north[1], 255, 0, 0);
        let lable_east = fisheye_project(90, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "东", lable_east[0], lable_east[1], 255, 0, 0);
        let lable_south = fisheye_project(180, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "南", lable_south[0], lable_south[1], 255, 0, 0);
        let lable_west = fisheye_project(270, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "西", lable_west[0], lable_west[1], 255, 0, 0);

        let lable_pos = fisheye_project(30, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "30", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(60, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "60", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(120, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "120", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(150, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "150", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(210, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "210", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(240, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "240", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(300, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "300", lable_pos[0], lable_pos[1], 255, 0, 0);
        lable_pos = fisheye_project(330, 6, sky_radius, center_x, center_y, view_alt, view_azi, f);
        fb_draw_textline_centered(frame_buffer, fb_width, fb_height, "330", lable_pos[0], lable_pos[1], 255, 0, 0);
    }

    // 绘制地景（天空投影圆盘之外的部分）
    draw_horizon(frame_buffer, RADIUS*2, RADIUS*2, sky_radius, center_x, center_y, view_alt, view_azi, f, sun_horizontal_coord[0]);

    // 绘制地平坐标网格
    // if (enable_horizontal_coord) {
    //     draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS-1, 2, 128, 128, 128, 255);
    //     draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS / 3, 1, 16, 16, 16, 255);
    //     draw_circle_outline(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, RADIUS, RADIUS / 3 * 2, 1, 16, 16, 16, 255);
    //     draw_line(frame_buffer, RADIUS*2, RADIUS*2, RADIUS, 0, RADIUS, RADIUS*2, 1, 16, 16, 16);
    //     draw_line(frame_buffer, RADIUS*2, RADIUS*2, 0, RADIUS, RADIUS*2, RADIUS, 1, 16, 16, 16);
    // }

}












const sky_radius = RADIUS;
const center_x = RADIUS;
const center_y = RADIUS;

let view_alt = 90; // 90度为地平天顶
let view_azi = 180; // 0度为正南
let view_range = 1.0;

let longitude = 119.0;
let latitude = 31.0;
let timezone = 8.0;

let second = 0;
let minute = 0;
let hour = 12;

let day = 11;
let month = 2;
let year = 2026;


let isDrawing = false;
let last_point_alt = 0;
let last_point_azi = 0;




class SkyCanvas {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        this.canvas.width = RADIUS * 2;
        this.canvas.height = RADIUS * 2;

        function adaptRatio(context) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
            return devicePixelRatio / backingStoreRatio;
        }
        this.RATIO = adaptRatio(this.ctx);
        this.canvas.width = Math.floor(this.canvas.width * this.RATIO);
        this.canvas.height = Math.floor(this.canvas.height * this.RATIO);
        RADIUS *= this.RATIO;
        RADIUS = Math.floor(RADIUS);
    }
}



function load_landscape_texture(idx) {
    if (idx === 0) {
        landscape_texture_rgba = null;
    }
    else {
        img_landscape_texture.src = LANDSCAPES[idx][0];
        img_landscape_texture.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img_landscape_texture.width;
            canvas.height = img_landscape_texture.height;
            landscape_texture_width = img_landscape_texture.width;
            landscape_texture_height = img_landscape_texture.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img_landscape_texture, 0, 0);
            landscape_texture_rgba = ctx.getImageData(0, 0, img_landscape_texture.width, img_landscape_texture.height).data; // Uint8ClampedArray
            // console.log(JSON.stringify(Array.from(landscape_texture_rgba)));
        };
    }
}



function refresh_button_status() {
    let status = null;

    // toggle_equatorial_coord
    if (!enable_equatorial_coord) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("eqa_status").innerHTML = status;

    // toggle_horizontal_coord
    if (!enable_horizontal_coord) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("hor_status").innerHTML = status;

    // toggle_star_burst
    if (!enable_star_burst) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("star_burst_status").innerHTML = status;

    // toggle_atmospheric_scattering
    if (enable_atmospheric_scattering === 0) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else if (enable_atmospheric_scattering === 1) {
        status = `<span style="color: #00cccc;">简化模型</span>`;
    }
    else if (enable_atmospheric_scattering === 2) {
        status = `<span style="color: #00cccc;">西田模型</span>`;
    }
    document.getElementById("scattering_status").innerHTML = status;

    // toggle_planet
    if (!enable_planet) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("planet_status").innerHTML = status;

    // toggle_star_name
    if (!enable_star_name) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("star_name_status").innerHTML = status;

    // enable_planet_name
    if (!enable_planet_name) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("planet_name_status").innerHTML = status;

    // toggle_ecliptic_circle
    if (!enable_ecliptic_circle) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("ecliptic_circle_status").innerHTML = status;

    // toggle_realtime
    if (!enable_realtime) {
        status = `<span style="color: #aa0000;">停用</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">启用</span>`;
    }
    document.getElementById("realtime_status").innerHTML = status;

    // toggle_timemachine
    if (!enable_timemachine_running) {
        status = `<span style="color: #aa0000;">停止</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">运行</span>`;
    }
    document.getElementById("timemachine_status").innerHTML = status;

    // toggle_opt_sym
    if (!enable_opt_sym) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("opt_sym_status").innerHTML = status;

    // toggle_opt_bilinear
    if (!enable_opt_bilinear) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cc00;">开启</span>`;
    }
    document.getElementById("opt_bilinear_status").innerHTML = status;

    // toggle_landscape
    if (landscape_index === 0) {
        status = `<span style="color: #aa0000;">关闭</span>`;
    }
    else {
        status = `<span style="color: #00cccc;">${LANDSCAPES[landscape_index][1]}</span>`;
    }
    document.getElementById("landscape_status").innerHTML = status;



    document.getElementById("longitude").innerHTML = String(longitude);
    document.getElementById("latitude").innerHTML = String(latitude);

}




load_landscape_texture(landscape_index);


window.onload = function() {

    document.getElementById("cam_pitch_up").addEventListener("click", function(e) {
        view_alt += 10;
        if (view_alt >= 90) view_alt = 90;
        refresh_button_status();
    });
    document.getElementById("cam_pitch_down").addEventListener("click", function(e) {
        view_alt -= 10;
        if (view_alt <= -90) view_alt = -90;
        refresh_button_status();
    });
    document.getElementById("cam_rot_eastward").addEventListener("click", function(e) {
        view_azi -= 10;
        if (view_azi <= 0) view_azi = 360;
        refresh_button_status();
    });
    document.getElementById("cam_rot_westward").addEventListener("click", function(e) {
        view_azi += 10;
        if (view_azi >= 360) view_azi = 0;
        refresh_button_status();
    });
    document.getElementById("cam_zoom_in").addEventListener("click", function(e) {
        view_range += 0.1;
        if (view_range >= 5.0) view_range = 5.0;
        refresh_button_status();
    });
    document.getElementById("cam_zoom_out").addEventListener("click", function(e) {
        view_range -= 0.1;
        if (view_range <= 0.1) view_range = 0.1;
        refresh_button_status();
    });
    document.getElementById("cam_reset").addEventListener("click", function(e) {
        view_alt = 90;
        view_azi = 180;
        view_range = 1.0;
        refresh_button_status();
    });

    document.getElementById("toggle_equatorial_coord").addEventListener("click", function(e) {
        enable_equatorial_coord = !enable_equatorial_coord;
        refresh_button_status();
    });
    document.getElementById("toggle_horizontal_coord").addEventListener("click", function(e) {
        enable_horizontal_coord = !enable_horizontal_coord;
        refresh_button_status();
    });
    document.getElementById("toggle_star_burst").addEventListener("click", function(e) {
        enable_star_burst = !enable_star_burst;
        refresh_button_status();
    });
    document.getElementById("toggle_atmospheric_scattering").addEventListener("click", function(e) {
        enable_atmospheric_scattering++;
        enable_atmospheric_scattering = enable_atmospheric_scattering % 3;
        refresh_button_status();
    });
    document.getElementById("toggle_planet").addEventListener("click", function(e) {
        enable_planet = !enable_planet;
        refresh_button_status();
    });
    document.getElementById("toggle_star_name").addEventListener("click", function(e) {
        enable_star_name = !enable_star_name;
        refresh_button_status();
    });
    document.getElementById("toggle_planet_name").addEventListener("click", function(e) {
        enable_planet_name = !enable_planet_name;
        refresh_button_status();
    });
    document.getElementById("toggle_ecliptic_circle").addEventListener("click", function(e) {
        enable_ecliptic_circle = !enable_ecliptic_circle;
        refresh_button_status();
    });

    document.getElementById("toggle_timemachine").addEventListener("click", function(e) {
        if (enable_realtime) {
            timemachine_start_time = new Date();
        }
        if (enable_timemachine_running) {
            timemachine_start_time = new Date();
            enable_timemachine_running = false;
        }
        else {
            enable_timemachine_running = true;
        }
        enable_realtime = false;
        refresh_button_status();
    });

    document.getElementById("toggle_realtime").addEventListener("click", function(e) {
        enable_realtime = !enable_realtime;
        refresh_button_status();
    });

    document.getElementById("toggle_opt_sym").addEventListener("click", function(e) {
        enable_opt_sym = !enable_opt_sym;
        refresh_button_status();
    });
    document.getElementById("toggle_opt_bilinear").addEventListener("click", function(e) {
        enable_opt_bilinear = !enable_opt_bilinear;
        refresh_button_status();
    });

    document.getElementById("toggle_landscape").addEventListener("click", function(e) {
        landscape_index++;
        if (landscape_index >= LANDSCAPES.length) landscape_index = 0;
        load_landscape_texture(landscape_index);
        refresh_button_status();
    });


    document.getElementById("set_time").addEventListener("click", function(e) {
        enable_realtime = false;
        enable_timemachine_running = false;
        year = Number(prompt(`输入年份`));
        month = Number(prompt(`输入月份`));
        day = Number(prompt(`输入日期`));
        hour = Number(prompt(`输入时`));
        minute = Number(prompt(`输入分`));
        second = 0;
        refresh_button_status();
    });

    document.getElementById("set_coord").addEventListener("click", function(e) {
        longitude = Number(prompt(`输入经度（十进制，东为正）`));
        latitude = Number(prompt(`输入纬度（十进制，北为正）`));
        refresh_button_status();
    });


    const sky = new SkyCanvas('skyCanvas');
    const imageData = sky.ctx.createImageData(sky.canvas.width, sky.canvas.height);
    const frame_buffer = imageData.data;

    const canvas = sky.canvas;
    const ctx = sky.ctx;



    // 获取事件在 Canvas 内的 CSS 像素坐标
    function getCanvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.type.startsWith('touch')) {
            const touch = e.touches[0] || e.changedTouches[0];
            clientX = touch.clientX;
            clientY = touch.clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        // 转换为 Canvas 内的 CSS 像素坐标（非物理像素）
        return {
            x: (clientX - rect.left) * (canvas.width / rect.width) / sky.RATIO,
            y: (clientY - rect.top) * (canvas.height / rect.height) / sky.RATIO
        };
    }

    // 开始绘制
    function startDrawing(e) {
        e.preventDefault(); // 阻止触摸默认行为（滚动/缩放）
        isDrawing = true;
        const pos = getCanvasPos(e);

        let xyz = fisheye_unproject(pos.x, pos.y, sky_radius, center_x, center_y, view_alt, view_azi, view_range);
        let hc = xyz_to_horizontal(xyz[0], xyz[1], xyz[2]);
        last_point_alt = hc[0];
        last_point_azi = hc[1];

    }

    // 绘制中
    function drag(e) {
        if (!isDrawing) return;
        e.preventDefault(); // 阻止触摸滚动
        const pos = getCanvasPos(e);

        let view_dir = find_view_dir(last_point_alt, last_point_azi, sky_radius, pos.x, pos.y, center_x, center_y, view_range, view_alt, view_azi);

        view_alt = view_dir[0];
        view_azi = view_dir[1];

        let xyz = fisheye_unproject(pos.x, pos.y, sky_radius, center_x, center_y, view_alt, view_azi, view_range);
        let hc = xyz_to_horizontal(xyz[0], xyz[1], xyz[2]);
        last_point_alt = hc[0];
        last_point_azi = hc[1];
    }

    // 停止绘制
    function stopDrawing() {
        isDrawing = false;
    }

    // 事件绑定
    sky.canvas.addEventListener('mousedown', startDrawing);
    sky.canvas.addEventListener('mousemove', drag);
    sky.canvas.addEventListener('mouseup', stopDrawing);
    sky.canvas.addEventListener('mouseout', stopDrawing); // 鼠标移出 Canvas 停止绘制

    // 触摸事件（移动端）
    sky.canvas.addEventListener('touchstart', startDrawing, { passive: false });
    sky.canvas.addEventListener('touchmove', drag, { passive: false });
    sky.canvas.addEventListener('touchend', stopDrawing);
    sky.canvas.addEventListener('touchcancel', stopDrawing);

    // FPS计算相关
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;

    function draw() {
        // 每帧重绘
        frame_buffer.fill(0);
        for (let i = 3; i < sky.canvas.width * sky.canvas.height * 4; i+=4) {
            frame_buffer[i] = 255;
        }

        if (enable_realtime) {
            const current_date = new Date();
            day = current_date.getDate();
            month = current_date.getMonth() + 1;
            year = current_date.getFullYear();
            second = current_date.getSeconds();
            minute = current_date.getMinutes();
            hour = current_date.getHours();
        }
        else {
            if (enable_timemachine_running) {
                const new_date = new Date();
                new_date.setTime(timemachine_start_time.getTime() + counter);
                day = new_date.getDate();
                month = new_date.getMonth() + 1;
                year = new_date.getFullYear();
                second = new_date.getSeconds();
                minute = new_date.getMinutes();
                hour = new_date.getHours();

                counter += 120000;
            }
        }

        document.getElementById('datetime').innerHTML = `${year}-${month}-${day} ${hour}:${minute}:${second}`;

        render_all(
            frame_buffer, sky.canvas.width, sky.canvas.height,
            RADIUS, RADIUS, RADIUS,
            view_alt, view_azi, view_range,
            year, month, day, hour, minute, second, timezone, longitude, latitude);

        sky.ctx.putImageData(imageData, 0, 0);

        // 计算FPS计算
        frameCount++;
        const now = performance.now();
        if (now - lastTime >= 500) { // 每隔多少毫秒统计一次
            fps = Math.round((frameCount * 1000) / (now - lastTime));
            document.getElementById('fps').textContent = `FPS: ${fps}`;
            frameCount = 0;
            lastTime = now;
        }

        requestAnimationFrame(draw);
    }

    draw();

    refresh_button_status();
};
    </script>
</body>
</html>
